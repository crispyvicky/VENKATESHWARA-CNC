"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfkit";
exports.ids = ["vendor-chunks/pdfkit"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdfkit/js/pdfkit.es.js":
/*!*********************************************!*\
  !*** ./node_modules/pdfkit/js/pdfkit.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto-js */ \"(rsc)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fontkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fontkit */ \"(rsc)/./node_modules/fontkit/dist/module.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var linebreak__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! linebreak */ \"(rsc)/./node_modules/linebreak/dist/module.mjs\");\n/* harmony import */ var jpeg_exif__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jpeg-exif */ \"(rsc)/./node_modules/jpeg-exif/lib/index.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! png-js */ \"(rsc)/./node_modules/png-js/png-node.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(png_js__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\n/*\r\nPDFAbstractReference - abstract class for PDF reference\r\n*/\n\nclass PDFAbstractReference {\n  toString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\n/*\r\nPDFTree - abstract base class for name and number tree objects\r\n*/\nclass PDFTree {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._items = {};\n    // disable /Limits output for this tree\n    this.limits = typeof options.limits === 'boolean' ? options.limits : true;\n  }\n  add(key, val) {\n    return this._items[key] = val;\n  }\n  get(key) {\n    return this._items[key];\n  }\n  toString() {\n    // Needs to be sorted by key\n    const sortedKeys = Object.keys(this._items).sort((a, b) => this._compareKeys(a, b));\n    const out = ['<<'];\n    if (this.limits && sortedKeys.length > 1) {\n      const first = sortedKeys[0],\n        last = sortedKeys[sortedKeys.length - 1];\n      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last)])}`);\n    }\n    out.push(`  /${this._keysName()} [`);\n    for (let key of sortedKeys) {\n      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);\n    }\n    out.push(']');\n    out.push('>>');\n    return out.join('\\n');\n  }\n  _compareKeys( /*a, b*/\n  ) {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _keysName() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _dataForKey( /*k*/\n  ) {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\n/*\r\nPDFObject - converts JavaScript types into their corresponding PDF types.\r\nBy Devon Govett\r\n*/\nconst pad = (str, length) => (Array(length + 1).join('0') + str).slice(-length);\nconst escapableRe = /[\\n\\r\\t\\b\\f()\\\\]/g;\nconst escapable = {\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\\\': '\\\\\\\\',\n  '(': '\\\\(',\n  ')': '\\\\)'\n};\n\n// Convert little endian UTF-16 to big endian\nconst swapBytes = function (buff) {\n  const l = buff.length;\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even');\n  } else {\n    for (let i = 0, end = l - 1; i < end; i += 2) {\n      const a = buff[i];\n      buff[i] = buff[i + 1];\n      buff[i + 1] = a;\n    }\n  }\n  return buff;\n};\nclass PDFObject {\n  static convert(object) {\n    let encryptFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    // String literals are converted to the PDF name type\n    if (typeof object === 'string') {\n      return `/${object}`;\n\n      // String objects are converted to PDF strings (UTF-16)\n    } else if (object instanceof String) {\n      let string = object;\n      // Detect if this is a unicode string\n      let isUnicode = false;\n      for (let i = 0, end = string.length; i < end; i++) {\n        if (string.charCodeAt(i) > 0x7f) {\n          isUnicode = true;\n          break;\n        }\n      }\n\n      // If so, encode it as big endian UTF-16\n      let stringBuffer;\n      if (isUnicode) {\n        stringBuffer = swapBytes(Buffer.from(`\\ufeff${string}`, 'utf16le'));\n      } else {\n        stringBuffer = Buffer.from(string.valueOf(), 'ascii');\n      }\n\n      // Encrypt the string when necessary\n      if (encryptFn) {\n        string = encryptFn(stringBuffer).toString('binary');\n      } else {\n        string = stringBuffer.toString('binary');\n      }\n\n      // Escape characters as required by the spec\n      string = string.replace(escapableRe, c => escapable[c]);\n      return `(${string})`;\n\n      // Buffers are converted to PDF hex strings\n    } else if (Buffer.isBuffer(object)) {\n      return `<${object.toString('hex')}>`;\n    } else if (object instanceof PDFAbstractReference || object instanceof PDFTree) {\n      return object.toString();\n    } else if (object instanceof Date) {\n      let string = `D:${pad(object.getUTCFullYear(), 4)}` + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z';\n\n      // Encrypt the string when necessary\n      if (encryptFn) {\n        string = encryptFn(Buffer.from(string, 'ascii')).toString('binary');\n\n        // Escape characters as required by the spec\n        string = string.replace(escapableRe, c => escapable[c]);\n      }\n      return `(${string})`;\n    } else if (Array.isArray(object)) {\n      const items = object.map(e => PDFObject.convert(e, encryptFn)).join(' ');\n      return `[${items}]`;\n    } else if ({}.toString.call(object) === '[object Object]') {\n      const out = ['<<'];\n      for (let key in object) {\n        const val = object[key];\n        out.push(`/${key} ${PDFObject.convert(val, encryptFn)}`);\n      }\n      out.push('>>');\n      return out.join('\\n');\n    } else if (typeof object === 'number') {\n      return PDFObject.number(object);\n    } else {\n      return `${object}`;\n    }\n  }\n  static number(n) {\n    if (n > -1e21 && n < 1e21) {\n      return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n  }\n}\n\n/*\r\nPDFReference - represents a reference to another object in the PDF object heirarchy\r\nBy Devon Govett\r\n*/\nclass PDFReference extends PDFAbstractReference {\n  constructor(document, id) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.document = document;\n    this.id = id;\n    this.data = data;\n    this.gen = 0;\n    this.compress = this.document.compress && !this.data.Filter;\n    this.uncompressedLength = 0;\n    this.buffer = [];\n  }\n  write(chunk) {\n    if (!Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk + '\\n', 'binary');\n    }\n    this.uncompressedLength += chunk.length;\n    if (this.data.Length == null) {\n      this.data.Length = 0;\n    }\n    this.buffer.push(chunk);\n    this.data.Length += chunk.length;\n    if (this.compress) {\n      return this.data.Filter = 'FlateDecode';\n    }\n  }\n  end(chunk) {\n    if (chunk) {\n      this.write(chunk);\n    }\n    return this.finalize();\n  }\n  finalize() {\n    this.offset = this.document._offset;\n    const encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;\n    if (this.buffer.length) {\n      this.buffer = Buffer.concat(this.buffer);\n      if (this.compress) {\n        this.buffer = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(this.buffer);\n      }\n      if (encryptFn) {\n        this.buffer = encryptFn(this.buffer);\n      }\n      this.data.Length = this.buffer.length;\n    }\n    this.document._write(`${this.id} ${this.gen} obj`);\n    this.document._write(PDFObject.convert(this.data, encryptFn));\n    if (this.buffer.length) {\n      this.document._write('stream');\n      this.document._write(this.buffer);\n      this.buffer = []; // free up memory\n      this.document._write('\\nendstream');\n    }\n    this.document._write('endobj');\n    this.document._refEnd(this);\n  }\n  toString() {\n    return `${this.id} ${this.gen} R`;\n  }\n}\n\n/*\r\nPDFPage - represents a single page in the PDF document\r\nBy Devon Govett\r\n*/\n\nconst DEFAULT_MARGINS = {\n  top: 72,\n  left: 72,\n  bottom: 72,\n  right: 72\n};\nconst SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\nclass PDFPage {\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.document = document;\n    this.size = options.size || 'letter';\n    this.layout = options.layout || 'portrait';\n\n    // process margins\n    if (typeof options.margin === 'number') {\n      this.margins = {\n        top: options.margin,\n        left: options.margin,\n        bottom: options.margin,\n        right: options.margin\n      };\n\n      // default to 1 inch margins\n    } else {\n      this.margins = options.margins || DEFAULT_MARGINS;\n    }\n\n    // calculate page dimensions\n    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];\n    this.width = dimensions[this.layout === 'portrait' ? 0 : 1];\n    this.height = dimensions[this.layout === 'portrait' ? 1 : 0];\n    this.content = this.document.ref();\n\n    // Initialize the Font, XObject, and ExtGState dictionaries\n    this.resources = this.document.ref({\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']\n    });\n\n    // The page dictionary\n    this.dictionary = this.document.ref({\n      Type: 'Page',\n      Parent: this.document._root.data.Pages,\n      MediaBox: [0, 0, this.width, this.height],\n      Contents: this.content,\n      Resources: this.resources\n    });\n    this.markings = [];\n  }\n\n  // Lazily create these objects\n  get fonts() {\n    const data = this.resources.data;\n    return data.Font != null ? data.Font : data.Font = {};\n  }\n  get xobjects() {\n    const data = this.resources.data;\n    return data.XObject != null ? data.XObject : data.XObject = {};\n  }\n  get ext_gstates() {\n    const data = this.resources.data;\n    return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};\n  }\n  get patterns() {\n    const data = this.resources.data;\n    return data.Pattern != null ? data.Pattern : data.Pattern = {};\n  }\n  get colorSpaces() {\n    const data = this.resources.data;\n    return data.ColorSpace || (data.ColorSpace = {});\n  }\n  get annotations() {\n    const data = this.dictionary.data;\n    return data.Annots != null ? data.Annots : data.Annots = [];\n  }\n  get structParentTreeKey() {\n    const data = this.dictionary.data;\n    return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();\n  }\n  maxY() {\n    return this.height - this.margins.bottom;\n  }\n  write(chunk) {\n    return this.content.write(chunk);\n  }\n  end() {\n    this.dictionary.end();\n    this.resources.end();\n    return this.content.end();\n  }\n}\n\n/*\r\nPDFNameTree - represents a name tree object\r\n*/\nclass PDFNameTree extends PDFTree {\n  _compareKeys(a, b) {\n    return a.localeCompare(b);\n  }\n  _keysName() {\n    return \"Names\";\n  }\n  _dataForKey(k) {\n    return new String(k);\n  }\n}\n\n/**\r\n * Check if value is in a range group.\r\n * @param {number} value\r\n * @param {number[]} rangeGroup\r\n * @returns {boolean}\r\n */\nfunction inRange(value, rangeGroup) {\n  if (value < rangeGroup[0]) return false;\n  let startRange = 0;\n  let endRange = rangeGroup.length / 2;\n  while (startRange <= endRange) {\n    const middleRange = Math.floor((startRange + endRange) / 2);\n\n    // actual array index\n    const arrayIndex = middleRange * 2;\n\n    // Check if value is in range pointed by actual index\n    if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {\n      return true;\n    }\n    if (value > rangeGroup[arrayIndex + 1]) {\n      // Search Right Side Of Array\n      startRange = middleRange + 1;\n    } else {\n      // Search Left Side Of Array\n      endRange = middleRange - 1;\n    }\n  }\n  return false;\n}\n\n// prettier-ignore-start\n/**\r\n * A.1 Unassigned code points in Unicode 3.2\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-A.1\r\n */\nconst unassigned_code_points = [0x0221, 0x0221, 0x0234, 0x024f, 0x02ae, 0x02af, 0x02ef, 0x02ff, 0x0350, 0x035f, 0x0370, 0x0373, 0x0376, 0x0379, 0x037b, 0x037d, 0x037f, 0x0383, 0x038b, 0x038b, 0x038d, 0x038d, 0x03a2, 0x03a2, 0x03cf, 0x03cf, 0x03f7, 0x03ff, 0x0487, 0x0487, 0x04cf, 0x04cf, 0x04f6, 0x04f7, 0x04fa, 0x04ff, 0x0510, 0x0530, 0x0557, 0x0558, 0x0560, 0x0560, 0x0588, 0x0588, 0x058b, 0x0590, 0x05a2, 0x05a2, 0x05ba, 0x05ba, 0x05c5, 0x05cf, 0x05eb, 0x05ef, 0x05f5, 0x060b, 0x060d, 0x061a, 0x061c, 0x061e, 0x0620, 0x0620, 0x063b, 0x063f, 0x0656, 0x065f, 0x06ee, 0x06ef, 0x06ff, 0x06ff, 0x070e, 0x070e, 0x072d, 0x072f, 0x074b, 0x077f, 0x07b2, 0x0900, 0x0904, 0x0904, 0x093a, 0x093b, 0x094e, 0x094f, 0x0955, 0x0957, 0x0971, 0x0980, 0x0984, 0x0984, 0x098d, 0x098e, 0x0991, 0x0992, 0x09a9, 0x09a9, 0x09b1, 0x09b1, 0x09b3, 0x09b5, 0x09ba, 0x09bb, 0x09bd, 0x09bd, 0x09c5, 0x09c6, 0x09c9, 0x09ca, 0x09ce, 0x09d6, 0x09d8, 0x09db, 0x09de, 0x09de, 0x09e4, 0x09e5, 0x09fb, 0x0a01, 0x0a03, 0x0a04, 0x0a0b, 0x0a0e, 0x0a11, 0x0a12, 0x0a29, 0x0a29, 0x0a31, 0x0a31, 0x0a34, 0x0a34, 0x0a37, 0x0a37, 0x0a3a, 0x0a3b, 0x0a3d, 0x0a3d, 0x0a43, 0x0a46, 0x0a49, 0x0a4a, 0x0a4e, 0x0a58, 0x0a5d, 0x0a5d, 0x0a5f, 0x0a65, 0x0a75, 0x0a80, 0x0a84, 0x0a84, 0x0a8c, 0x0a8c, 0x0a8e, 0x0a8e, 0x0a92, 0x0a92, 0x0aa9, 0x0aa9, 0x0ab1, 0x0ab1, 0x0ab4, 0x0ab4, 0x0aba, 0x0abb, 0x0ac6, 0x0ac6, 0x0aca, 0x0aca, 0x0ace, 0x0acf, 0x0ad1, 0x0adf, 0x0ae1, 0x0ae5, 0x0af0, 0x0b00, 0x0b04, 0x0b04, 0x0b0d, 0x0b0e, 0x0b11, 0x0b12, 0x0b29, 0x0b29, 0x0b31, 0x0b31, 0x0b34, 0x0b35, 0x0b3a, 0x0b3b, 0x0b44, 0x0b46, 0x0b49, 0x0b4a, 0x0b4e, 0x0b55, 0x0b58, 0x0b5b, 0x0b5e, 0x0b5e, 0x0b62, 0x0b65, 0x0b71, 0x0b81, 0x0b84, 0x0b84, 0x0b8b, 0x0b8d, 0x0b91, 0x0b91, 0x0b96, 0x0b98, 0x0b9b, 0x0b9b, 0x0b9d, 0x0b9d, 0x0ba0, 0x0ba2, 0x0ba5, 0x0ba7, 0x0bab, 0x0bad, 0x0bb6, 0x0bb6, 0x0bba, 0x0bbd, 0x0bc3, 0x0bc5, 0x0bc9, 0x0bc9, 0x0bce, 0x0bd6, 0x0bd8, 0x0be6, 0x0bf3, 0x0c00, 0x0c04, 0x0c04, 0x0c0d, 0x0c0d, 0x0c11, 0x0c11, 0x0c29, 0x0c29, 0x0c34, 0x0c34, 0x0c3a, 0x0c3d, 0x0c45, 0x0c45, 0x0c49, 0x0c49, 0x0c4e, 0x0c54, 0x0c57, 0x0c5f, 0x0c62, 0x0c65, 0x0c70, 0x0c81, 0x0c84, 0x0c84, 0x0c8d, 0x0c8d, 0x0c91, 0x0c91, 0x0ca9, 0x0ca9, 0x0cb4, 0x0cb4, 0x0cba, 0x0cbd, 0x0cc5, 0x0cc5, 0x0cc9, 0x0cc9, 0x0cce, 0x0cd4, 0x0cd7, 0x0cdd, 0x0cdf, 0x0cdf, 0x0ce2, 0x0ce5, 0x0cf0, 0x0d01, 0x0d04, 0x0d04, 0x0d0d, 0x0d0d, 0x0d11, 0x0d11, 0x0d29, 0x0d29, 0x0d3a, 0x0d3d, 0x0d44, 0x0d45, 0x0d49, 0x0d49, 0x0d4e, 0x0d56, 0x0d58, 0x0d5f, 0x0d62, 0x0d65, 0x0d70, 0x0d81, 0x0d84, 0x0d84, 0x0d97, 0x0d99, 0x0db2, 0x0db2, 0x0dbc, 0x0dbc, 0x0dbe, 0x0dbf, 0x0dc7, 0x0dc9, 0x0dcb, 0x0dce, 0x0dd5, 0x0dd5, 0x0dd7, 0x0dd7, 0x0de0, 0x0df1, 0x0df5, 0x0e00, 0x0e3b, 0x0e3e, 0x0e5c, 0x0e80, 0x0e83, 0x0e83, 0x0e85, 0x0e86, 0x0e89, 0x0e89, 0x0e8b, 0x0e8c, 0x0e8e, 0x0e93, 0x0e98, 0x0e98, 0x0ea0, 0x0ea0, 0x0ea4, 0x0ea4, 0x0ea6, 0x0ea6, 0x0ea8, 0x0ea9, 0x0eac, 0x0eac, 0x0eba, 0x0eba, 0x0ebe, 0x0ebf, 0x0ec5, 0x0ec5, 0x0ec7, 0x0ec7, 0x0ece, 0x0ecf, 0x0eda, 0x0edb, 0x0ede, 0x0eff, 0x0f48, 0x0f48, 0x0f6b, 0x0f70, 0x0f8c, 0x0f8f, 0x0f98, 0x0f98, 0x0fbd, 0x0fbd, 0x0fcd, 0x0fce, 0x0fd0, 0x0fff, 0x1022, 0x1022, 0x1028, 0x1028, 0x102b, 0x102b, 0x1033, 0x1035, 0x103a, 0x103f, 0x105a, 0x109f, 0x10c6, 0x10cf, 0x10f9, 0x10fa, 0x10fc, 0x10ff, 0x115a, 0x115e, 0x11a3, 0x11a7, 0x11fa, 0x11ff, 0x1207, 0x1207, 0x1247, 0x1247, 0x1249, 0x1249, 0x124e, 0x124f, 0x1257, 0x1257, 0x1259, 0x1259, 0x125e, 0x125f, 0x1287, 0x1287, 0x1289, 0x1289, 0x128e, 0x128f, 0x12af, 0x12af, 0x12b1, 0x12b1, 0x12b6, 0x12b7, 0x12bf, 0x12bf, 0x12c1, 0x12c1, 0x12c6, 0x12c7, 0x12cf, 0x12cf, 0x12d7, 0x12d7, 0x12ef, 0x12ef, 0x130f, 0x130f, 0x1311, 0x1311, 0x1316, 0x1317, 0x131f, 0x131f, 0x1347, 0x1347, 0x135b, 0x1360, 0x137d, 0x139f, 0x13f5, 0x1400, 0x1677, 0x167f, 0x169d, 0x169f, 0x16f1, 0x16ff, 0x170d, 0x170d, 0x1715, 0x171f, 0x1737, 0x173f, 0x1754, 0x175f, 0x176d, 0x176d, 0x1771, 0x1771, 0x1774, 0x177f, 0x17dd, 0x17df, 0x17ea, 0x17ff, 0x180f, 0x180f, 0x181a, 0x181f, 0x1878, 0x187f, 0x18aa, 0x1dff, 0x1e9c, 0x1e9f, 0x1efa, 0x1eff, 0x1f16, 0x1f17, 0x1f1e, 0x1f1f, 0x1f46, 0x1f47, 0x1f4e, 0x1f4f, 0x1f58, 0x1f58, 0x1f5a, 0x1f5a, 0x1f5c, 0x1f5c, 0x1f5e, 0x1f5e, 0x1f7e, 0x1f7f, 0x1fb5, 0x1fb5, 0x1fc5, 0x1fc5, 0x1fd4, 0x1fd5, 0x1fdc, 0x1fdc, 0x1ff0, 0x1ff1, 0x1ff5, 0x1ff5, 0x1fff, 0x1fff, 0x2053, 0x2056, 0x2058, 0x205e, 0x2064, 0x2069, 0x2072, 0x2073, 0x208f, 0x209f, 0x20b2, 0x20cf, 0x20eb, 0x20ff, 0x213b, 0x213c, 0x214c, 0x2152, 0x2184, 0x218f, 0x23cf, 0x23ff, 0x2427, 0x243f, 0x244b, 0x245f, 0x24ff, 0x24ff, 0x2614, 0x2615, 0x2618, 0x2618, 0x267e, 0x267f, 0x268a, 0x2700, 0x2705, 0x2705, 0x270a, 0x270b, 0x2728, 0x2728, 0x274c, 0x274c, 0x274e, 0x274e, 0x2753, 0x2755, 0x2757, 0x2757, 0x275f, 0x2760, 0x2795, 0x2797, 0x27b0, 0x27b0, 0x27bf, 0x27cf, 0x27ec, 0x27ef, 0x2b00, 0x2e7f, 0x2e9a, 0x2e9a, 0x2ef4, 0x2eff, 0x2fd6, 0x2fef, 0x2ffc, 0x2fff, 0x3040, 0x3040, 0x3097, 0x3098, 0x3100, 0x3104, 0x312d, 0x3130, 0x318f, 0x318f, 0x31b8, 0x31ef, 0x321d, 0x321f, 0x3244, 0x3250, 0x327c, 0x327e, 0x32cc, 0x32cf, 0x32ff, 0x32ff, 0x3377, 0x337a, 0x33de, 0x33df, 0x33ff, 0x33ff, 0x4db6, 0x4dff, 0x9fa6, 0x9fff, 0xa48d, 0xa48f, 0xa4c7, 0xabff, 0xd7a4, 0xd7ff, 0xfa2e, 0xfa2f, 0xfa6b, 0xfaff, 0xfb07, 0xfb12, 0xfb18, 0xfb1c, 0xfb37, 0xfb37, 0xfb3d, 0xfb3d, 0xfb3f, 0xfb3f, 0xfb42, 0xfb42, 0xfb45, 0xfb45, 0xfbb2, 0xfbd2, 0xfd40, 0xfd4f, 0xfd90, 0xfd91, 0xfdc8, 0xfdcf, 0xfdfd, 0xfdff, 0xfe10, 0xfe1f, 0xfe24, 0xfe2f, 0xfe47, 0xfe48, 0xfe53, 0xfe53, 0xfe67, 0xfe67, 0xfe6c, 0xfe6f, 0xfe75, 0xfe75, 0xfefd, 0xfefe, 0xff00, 0xff00, 0xffbf, 0xffc1, 0xffc8, 0xffc9, 0xffd0, 0xffd1, 0xffd8, 0xffd9, 0xffdd, 0xffdf, 0xffe7, 0xffe7, 0xffef, 0xfff8, 0x10000, 0x102ff, 0x1031f, 0x1031f, 0x10324, 0x1032f, 0x1034b, 0x103ff, 0x10426, 0x10427, 0x1044e, 0x1cfff, 0x1d0f6, 0x1d0ff, 0x1d127, 0x1d129, 0x1d1de, 0x1d3ff, 0x1d455, 0x1d455, 0x1d49d, 0x1d49d, 0x1d4a0, 0x1d4a1, 0x1d4a3, 0x1d4a4, 0x1d4a7, 0x1d4a8, 0x1d4ad, 0x1d4ad, 0x1d4ba, 0x1d4ba, 0x1d4bc, 0x1d4bc, 0x1d4c1, 0x1d4c1, 0x1d4c4, 0x1d4c4, 0x1d506, 0x1d506, 0x1d50b, 0x1d50c, 0x1d515, 0x1d515, 0x1d51d, 0x1d51d, 0x1d53a, 0x1d53a, 0x1d53f, 0x1d53f, 0x1d545, 0x1d545, 0x1d547, 0x1d549, 0x1d551, 0x1d551, 0x1d6a4, 0x1d6a7, 0x1d7ca, 0x1d7cd, 0x1d800, 0x1fffd, 0x2a6d7, 0x2f7ff, 0x2fa1e, 0x2fffd, 0x30000, 0x3fffd, 0x40000, 0x4fffd, 0x50000, 0x5fffd, 0x60000, 0x6fffd, 0x70000, 0x7fffd, 0x80000, 0x8fffd, 0x90000, 0x9fffd, 0xa0000, 0xafffd, 0xb0000, 0xbfffd, 0xc0000, 0xcfffd, 0xd0000, 0xdfffd, 0xe0000, 0xe0000, 0xe0002, 0xe001f, 0xe0080, 0xefffd];\n// prettier-ignore-end\n\nconst isUnassignedCodePoint = character => inRange(character, unassigned_code_points);\n\n// prettier-ignore-start\n/**\r\n * B.1 Commonly mapped to nothing\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-B.1\r\n */\nconst commonly_mapped_to_nothing = [0x00ad, 0x00ad, 0x034f, 0x034f, 0x1806, 0x1806, 0x180b, 0x180b, 0x180c, 0x180c, 0x180d, 0x180d, 0x200b, 0x200b, 0x200c, 0x200c, 0x200d, 0x200d, 0x2060, 0x2060, 0xfe00, 0xfe00, 0xfe01, 0xfe01, 0xfe02, 0xfe02, 0xfe03, 0xfe03, 0xfe04, 0xfe04, 0xfe05, 0xfe05, 0xfe06, 0xfe06, 0xfe07, 0xfe07, 0xfe08, 0xfe08, 0xfe09, 0xfe09, 0xfe0a, 0xfe0a, 0xfe0b, 0xfe0b, 0xfe0c, 0xfe0c, 0xfe0d, 0xfe0d, 0xfe0e, 0xfe0e, 0xfe0f, 0xfe0f, 0xfeff, 0xfeff];\n// prettier-ignore-end\n\nconst isCommonlyMappedToNothing = character => inRange(character, commonly_mapped_to_nothing);\n\n// prettier-ignore-start\n/**\r\n * C.1.2 Non-ASCII space characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.1.2\r\n */\nconst non_ASCII_space_characters = [0x00a0, 0x00a0 /* NO-BREAK SPACE */, 0x1680, 0x1680 /* OGHAM SPACE MARK */, 0x2000, 0x2000 /* EN QUAD */, 0x2001, 0x2001 /* EM QUAD */, 0x2002, 0x2002 /* EN SPACE */, 0x2003, 0x2003 /* EM SPACE */, 0x2004, 0x2004 /* THREE-PER-EM SPACE */, 0x2005, 0x2005 /* FOUR-PER-EM SPACE */, 0x2006, 0x2006 /* SIX-PER-EM SPACE */, 0x2007, 0x2007 /* FIGURE SPACE */, 0x2008, 0x2008 /* PUNCTUATION SPACE */, 0x2009, 0x2009 /* THIN SPACE */, 0x200a, 0x200a /* HAIR SPACE */, 0x200b, 0x200b /* ZERO WIDTH SPACE */, 0x202f, 0x202f /* NARROW NO-BREAK SPACE */, 0x205f, 0x205f /* MEDIUM MATHEMATICAL SPACE */, 0x3000, 0x3000 /* IDEOGRAPHIC SPACE */];\n// prettier-ignore-end\n\nconst isNonASCIISpaceCharacter = character => inRange(character, non_ASCII_space_characters);\n\n// prettier-ignore-start\nconst non_ASCII_controls_characters = [\n/**\r\n * C.2.2 Non-ASCII control characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.2\r\n */\n0x0080, 0x009f /* [CONTROL CHARACTERS] */, 0x06dd, 0x06dd /* ARABIC END OF AYAH */, 0x070f, 0x070f /* SYRIAC ABBREVIATION MARK */, 0x180e, 0x180e /* MONGOLIAN VOWEL SEPARATOR */, 0x200c, 0x200c /* ZERO WIDTH NON-JOINER */, 0x200d, 0x200d /* ZERO WIDTH JOINER */, 0x2028, 0x2028 /* LINE SEPARATOR */, 0x2029, 0x2029 /* PARAGRAPH SEPARATOR */, 0x2060, 0x2060 /* WORD JOINER */, 0x2061, 0x2061 /* FUNCTION APPLICATION */, 0x2062, 0x2062 /* INVISIBLE TIMES */, 0x2063, 0x2063 /* INVISIBLE SEPARATOR */, 0x206a, 0x206f /* [CONTROL CHARACTERS] */, 0xfeff, 0xfeff /* ZERO WIDTH NO-BREAK SPACE */, 0xfff9, 0xfffc /* [CONTROL CHARACTERS] */, 0x1d173, 0x1d17a /* [MUSICAL CONTROL CHARACTERS] */];\nconst non_character_codepoints = [\n/**\r\n * C.4 Non-character code points\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.4\r\n */\n0xfdd0, 0xfdef /* [NONCHARACTER CODE POINTS] */, 0xfffe, 0xffff /* [NONCHARACTER CODE POINTS] */, 0x1fffe, 0x1ffff /* [NONCHARACTER CODE POINTS] */, 0x2fffe, 0x2ffff /* [NONCHARACTER CODE POINTS] */, 0x3fffe, 0x3ffff /* [NONCHARACTER CODE POINTS] */, 0x4fffe, 0x4ffff /* [NONCHARACTER CODE POINTS] */, 0x5fffe, 0x5ffff /* [NONCHARACTER CODE POINTS] */, 0x6fffe, 0x6ffff /* [NONCHARACTER CODE POINTS] */, 0x7fffe, 0x7ffff /* [NONCHARACTER CODE POINTS] */, 0x8fffe, 0x8ffff /* [NONCHARACTER CODE POINTS] */, 0x9fffe, 0x9ffff /* [NONCHARACTER CODE POINTS] */, 0xafffe, 0xaffff /* [NONCHARACTER CODE POINTS] */, 0xbfffe, 0xbffff /* [NONCHARACTER CODE POINTS] */, 0xcfffe, 0xcffff /* [NONCHARACTER CODE POINTS] */, 0xdfffe, 0xdffff /* [NONCHARACTER CODE POINTS] */, 0xefffe, 0xeffff /* [NONCHARACTER CODE POINTS] */, 0x10fffe, 0x10ffff /* [NONCHARACTER CODE POINTS] */];\n\n/**\r\n * 2.3.  Prohibited Output\r\n */\nconst prohibited_characters = [\n/**\r\n * C.2.1 ASCII control characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.1\r\n */\n0, 0x001f /* [CONTROL CHARACTERS] */, 0x007f, 0x007f /* DELETE */,\n/**\r\n * C.8 Change display properties or are deprecated\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.8\r\n */\n0x0340, 0x0340 /* COMBINING GRAVE TONE MARK */, 0x0341, 0x0341 /* COMBINING ACUTE TONE MARK */, 0x200e, 0x200e /* LEFT-TO-RIGHT MARK */, 0x200f, 0x200f /* RIGHT-TO-LEFT MARK */, 0x202a, 0x202a /* LEFT-TO-RIGHT EMBEDDING */, 0x202b, 0x202b /* RIGHT-TO-LEFT EMBEDDING */, 0x202c, 0x202c /* POP DIRECTIONAL FORMATTING */, 0x202d, 0x202d /* LEFT-TO-RIGHT OVERRIDE */, 0x202e, 0x202e /* RIGHT-TO-LEFT OVERRIDE */, 0x206a, 0x206a /* INHIBIT SYMMETRIC SWAPPING */, 0x206b, 0x206b /* ACTIVATE SYMMETRIC SWAPPING */, 0x206c, 0x206c /* INHIBIT ARABIC FORM SHAPING */, 0x206d, 0x206d /* ACTIVATE ARABIC FORM SHAPING */, 0x206e, 0x206e /* NATIONAL DIGIT SHAPES */, 0x206f, 0x206f /* NOMINAL DIGIT SHAPES */,\n/**\r\n * C.7 Inappropriate for canonical representation\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.7\r\n */\n0x2ff0, 0x2ffb /* [IDEOGRAPHIC DESCRIPTION CHARACTERS] */,\n/**\r\n * C.5 Surrogate codes\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.5\r\n */\n0xd800, 0xdfff,\n/**\r\n * C.3 Private use\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\r\n */\n0xe000, 0xf8ff /* [PRIVATE USE, PLANE 0] */,\n/**\r\n * C.6 Inappropriate for plain text\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.6\r\n */\n0xfff9, 0xfff9 /* INTERLINEAR ANNOTATION ANCHOR */, 0xfffa, 0xfffa /* INTERLINEAR ANNOTATION SEPARATOR */, 0xfffb, 0xfffb /* INTERLINEAR ANNOTATION TERMINATOR */, 0xfffc, 0xfffc /* OBJECT REPLACEMENT CHARACTER */, 0xfffd, 0xfffd /* REPLACEMENT CHARACTER */,\n/**\r\n * C.9 Tagging characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.9\r\n */\n0xe0001, 0xe0001 /* LANGUAGE TAG */, 0xe0020, 0xe007f /* [TAGGING CHARACTERS] */,\n/**\r\n * C.3 Private use\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\r\n */\n\n0xf0000, 0xffffd /* [PRIVATE USE, PLANE 15] */, 0x100000, 0x10fffd /* [PRIVATE USE, PLANE 16] */];\n// prettier-ignore-end\n\nconst isProhibitedCharacter = character => inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);\n\n// prettier-ignore-start\n/**\r\n * D.1 Characters with bidirectional property \"R\" or \"AL\"\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.1\r\n */\nconst bidirectional_r_al = [0x05be, 0x05be, 0x05c0, 0x05c0, 0x05c3, 0x05c3, 0x05d0, 0x05ea, 0x05f0, 0x05f4, 0x061b, 0x061b, 0x061f, 0x061f, 0x0621, 0x063a, 0x0640, 0x064a, 0x066d, 0x066f, 0x0671, 0x06d5, 0x06dd, 0x06dd, 0x06e5, 0x06e6, 0x06fa, 0x06fe, 0x0700, 0x070d, 0x0710, 0x0710, 0x0712, 0x072c, 0x0780, 0x07a5, 0x07b1, 0x07b1, 0x200f, 0x200f, 0xfb1d, 0xfb1d, 0xfb1f, 0xfb28, 0xfb2a, 0xfb36, 0xfb38, 0xfb3c, 0xfb3e, 0xfb3e, 0xfb40, 0xfb41, 0xfb43, 0xfb44, 0xfb46, 0xfbb1, 0xfbd3, 0xfd3d, 0xfd50, 0xfd8f, 0xfd92, 0xfdc7, 0xfdf0, 0xfdfc, 0xfe70, 0xfe74, 0xfe76, 0xfefc];\n// prettier-ignore-end\n\nconst isBidirectionalRAL = character => inRange(character, bidirectional_r_al);\n\n// prettier-ignore-start\n/**\r\n * D.2 Characters with bidirectional property \"L\"\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.2\r\n */\nconst bidirectional_l = [0x0041, 0x005a, 0x0061, 0x007a, 0x00aa, 0x00aa, 0x00b5, 0x00b5, 0x00ba, 0x00ba, 0x00c0, 0x00d6, 0x00d8, 0x00f6, 0x00f8, 0x0220, 0x0222, 0x0233, 0x0250, 0x02ad, 0x02b0, 0x02b8, 0x02bb, 0x02c1, 0x02d0, 0x02d1, 0x02e0, 0x02e4, 0x02ee, 0x02ee, 0x037a, 0x037a, 0x0386, 0x0386, 0x0388, 0x038a, 0x038c, 0x038c, 0x038e, 0x03a1, 0x03a3, 0x03ce, 0x03d0, 0x03f5, 0x0400, 0x0482, 0x048a, 0x04ce, 0x04d0, 0x04f5, 0x04f8, 0x04f9, 0x0500, 0x050f, 0x0531, 0x0556, 0x0559, 0x055f, 0x0561, 0x0587, 0x0589, 0x0589, 0x0903, 0x0903, 0x0905, 0x0939, 0x093d, 0x0940, 0x0949, 0x094c, 0x0950, 0x0950, 0x0958, 0x0961, 0x0964, 0x0970, 0x0982, 0x0983, 0x0985, 0x098c, 0x098f, 0x0990, 0x0993, 0x09a8, 0x09aa, 0x09b0, 0x09b2, 0x09b2, 0x09b6, 0x09b9, 0x09be, 0x09c0, 0x09c7, 0x09c8, 0x09cb, 0x09cc, 0x09d7, 0x09d7, 0x09dc, 0x09dd, 0x09df, 0x09e1, 0x09e6, 0x09f1, 0x09f4, 0x09fa, 0x0a05, 0x0a0a, 0x0a0f, 0x0a10, 0x0a13, 0x0a28, 0x0a2a, 0x0a30, 0x0a32, 0x0a33, 0x0a35, 0x0a36, 0x0a38, 0x0a39, 0x0a3e, 0x0a40, 0x0a59, 0x0a5c, 0x0a5e, 0x0a5e, 0x0a66, 0x0a6f, 0x0a72, 0x0a74, 0x0a83, 0x0a83, 0x0a85, 0x0a8b, 0x0a8d, 0x0a8d, 0x0a8f, 0x0a91, 0x0a93, 0x0aa8, 0x0aaa, 0x0ab0, 0x0ab2, 0x0ab3, 0x0ab5, 0x0ab9, 0x0abd, 0x0ac0, 0x0ac9, 0x0ac9, 0x0acb, 0x0acc, 0x0ad0, 0x0ad0, 0x0ae0, 0x0ae0, 0x0ae6, 0x0aef, 0x0b02, 0x0b03, 0x0b05, 0x0b0c, 0x0b0f, 0x0b10, 0x0b13, 0x0b28, 0x0b2a, 0x0b30, 0x0b32, 0x0b33, 0x0b36, 0x0b39, 0x0b3d, 0x0b3e, 0x0b40, 0x0b40, 0x0b47, 0x0b48, 0x0b4b, 0x0b4c, 0x0b57, 0x0b57, 0x0b5c, 0x0b5d, 0x0b5f, 0x0b61, 0x0b66, 0x0b70, 0x0b83, 0x0b83, 0x0b85, 0x0b8a, 0x0b8e, 0x0b90, 0x0b92, 0x0b95, 0x0b99, 0x0b9a, 0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0ba3, 0x0ba4, 0x0ba8, 0x0baa, 0x0bae, 0x0bb5, 0x0bb7, 0x0bb9, 0x0bbe, 0x0bbf, 0x0bc1, 0x0bc2, 0x0bc6, 0x0bc8, 0x0bca, 0x0bcc, 0x0bd7, 0x0bd7, 0x0be7, 0x0bf2, 0x0c01, 0x0c03, 0x0c05, 0x0c0c, 0x0c0e, 0x0c10, 0x0c12, 0x0c28, 0x0c2a, 0x0c33, 0x0c35, 0x0c39, 0x0c41, 0x0c44, 0x0c60, 0x0c61, 0x0c66, 0x0c6f, 0x0c82, 0x0c83, 0x0c85, 0x0c8c, 0x0c8e, 0x0c90, 0x0c92, 0x0ca8, 0x0caa, 0x0cb3, 0x0cb5, 0x0cb9, 0x0cbe, 0x0cbe, 0x0cc0, 0x0cc4, 0x0cc7, 0x0cc8, 0x0cca, 0x0ccb, 0x0cd5, 0x0cd6, 0x0cde, 0x0cde, 0x0ce0, 0x0ce1, 0x0ce6, 0x0cef, 0x0d02, 0x0d03, 0x0d05, 0x0d0c, 0x0d0e, 0x0d10, 0x0d12, 0x0d28, 0x0d2a, 0x0d39, 0x0d3e, 0x0d40, 0x0d46, 0x0d48, 0x0d4a, 0x0d4c, 0x0d57, 0x0d57, 0x0d60, 0x0d61, 0x0d66, 0x0d6f, 0x0d82, 0x0d83, 0x0d85, 0x0d96, 0x0d9a, 0x0db1, 0x0db3, 0x0dbb, 0x0dbd, 0x0dbd, 0x0dc0, 0x0dc6, 0x0dcf, 0x0dd1, 0x0dd8, 0x0ddf, 0x0df2, 0x0df4, 0x0e01, 0x0e30, 0x0e32, 0x0e33, 0x0e40, 0x0e46, 0x0e4f, 0x0e5b, 0x0e81, 0x0e82, 0x0e84, 0x0e84, 0x0e87, 0x0e88, 0x0e8a, 0x0e8a, 0x0e8d, 0x0e8d, 0x0e94, 0x0e97, 0x0e99, 0x0e9f, 0x0ea1, 0x0ea3, 0x0ea5, 0x0ea5, 0x0ea7, 0x0ea7, 0x0eaa, 0x0eab, 0x0ead, 0x0eb0, 0x0eb2, 0x0eb3, 0x0ebd, 0x0ebd, 0x0ec0, 0x0ec4, 0x0ec6, 0x0ec6, 0x0ed0, 0x0ed9, 0x0edc, 0x0edd, 0x0f00, 0x0f17, 0x0f1a, 0x0f34, 0x0f36, 0x0f36, 0x0f38, 0x0f38, 0x0f3e, 0x0f47, 0x0f49, 0x0f6a, 0x0f7f, 0x0f7f, 0x0f85, 0x0f85, 0x0f88, 0x0f8b, 0x0fbe, 0x0fc5, 0x0fc7, 0x0fcc, 0x0fcf, 0x0fcf, 0x1000, 0x1021, 0x1023, 0x1027, 0x1029, 0x102a, 0x102c, 0x102c, 0x1031, 0x1031, 0x1038, 0x1038, 0x1040, 0x1057, 0x10a0, 0x10c5, 0x10d0, 0x10f8, 0x10fb, 0x10fb, 0x1100, 0x1159, 0x115f, 0x11a2, 0x11a8, 0x11f9, 0x1200, 0x1206, 0x1208, 0x1246, 0x1248, 0x1248, 0x124a, 0x124d, 0x1250, 0x1256, 0x1258, 0x1258, 0x125a, 0x125d, 0x1260, 0x1286, 0x1288, 0x1288, 0x128a, 0x128d, 0x1290, 0x12ae, 0x12b0, 0x12b0, 0x12b2, 0x12b5, 0x12b8, 0x12be, 0x12c0, 0x12c0, 0x12c2, 0x12c5, 0x12c8, 0x12ce, 0x12d0, 0x12d6, 0x12d8, 0x12ee, 0x12f0, 0x130e, 0x1310, 0x1310, 0x1312, 0x1315, 0x1318, 0x131e, 0x1320, 0x1346, 0x1348, 0x135a, 0x1361, 0x137c, 0x13a0, 0x13f4, 0x1401, 0x1676, 0x1681, 0x169a, 0x16a0, 0x16f0, 0x1700, 0x170c, 0x170e, 0x1711, 0x1720, 0x1731, 0x1735, 0x1736, 0x1740, 0x1751, 0x1760, 0x176c, 0x176e, 0x1770, 0x1780, 0x17b6, 0x17be, 0x17c5, 0x17c7, 0x17c8, 0x17d4, 0x17da, 0x17dc, 0x17dc, 0x17e0, 0x17e9, 0x1810, 0x1819, 0x1820, 0x1877, 0x1880, 0x18a8, 0x1e00, 0x1e9b, 0x1ea0, 0x1ef9, 0x1f00, 0x1f15, 0x1f18, 0x1f1d, 0x1f20, 0x1f45, 0x1f48, 0x1f4d, 0x1f50, 0x1f57, 0x1f59, 0x1f59, 0x1f5b, 0x1f5b, 0x1f5d, 0x1f5d, 0x1f5f, 0x1f7d, 0x1f80, 0x1fb4, 0x1fb6, 0x1fbc, 0x1fbe, 0x1fbe, 0x1fc2, 0x1fc4, 0x1fc6, 0x1fcc, 0x1fd0, 0x1fd3, 0x1fd6, 0x1fdb, 0x1fe0, 0x1fec, 0x1ff2, 0x1ff4, 0x1ff6, 0x1ffc, 0x200e, 0x200e, 0x2071, 0x2071, 0x207f, 0x207f, 0x2102, 0x2102, 0x2107, 0x2107, 0x210a, 0x2113, 0x2115, 0x2115, 0x2119, 0x211d, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128, 0x212a, 0x212d, 0x212f, 0x2131, 0x2133, 0x2139, 0x213d, 0x213f, 0x2145, 0x2149, 0x2160, 0x2183, 0x2336, 0x237a, 0x2395, 0x2395, 0x249c, 0x24e9, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035, 0x3038, 0x303c, 0x3041, 0x3096, 0x309d, 0x309f, 0x30a1, 0x30fa, 0x30fc, 0x30ff, 0x3105, 0x312c, 0x3131, 0x318e, 0x3190, 0x31b7, 0x31f0, 0x321c, 0x3220, 0x3243, 0x3260, 0x327b, 0x327f, 0x32b0, 0x32c0, 0x32cb, 0x32d0, 0x32fe, 0x3300, 0x3376, 0x337b, 0x33dd, 0x33e0, 0x33fe, 0x3400, 0x4db5, 0x4e00, 0x9fa5, 0xa000, 0xa48c, 0xac00, 0xd7a3, 0xd800, 0xfa2d, 0xfa30, 0xfa6a, 0xfb00, 0xfb06, 0xfb13, 0xfb17, 0xff21, 0xff3a, 0xff41, 0xff5a, 0xff66, 0xffbe, 0xffc2, 0xffc7, 0xffca, 0xffcf, 0xffd2, 0xffd7, 0xffda, 0xffdc, 0x10300, 0x1031e, 0x10320, 0x10323, 0x10330, 0x1034a, 0x10400, 0x10425, 0x10428, 0x1044d, 0x1d000, 0x1d0f5, 0x1d100, 0x1d126, 0x1d12a, 0x1d166, 0x1d16a, 0x1d172, 0x1d183, 0x1d184, 0x1d18c, 0x1d1a9, 0x1d1ae, 0x1d1dd, 0x1d400, 0x1d454, 0x1d456, 0x1d49c, 0x1d49e, 0x1d49f, 0x1d4a2, 0x1d4a2, 0x1d4a5, 0x1d4a6, 0x1d4a9, 0x1d4ac, 0x1d4ae, 0x1d4b9, 0x1d4bb, 0x1d4bb, 0x1d4bd, 0x1d4c0, 0x1d4c2, 0x1d4c3, 0x1d4c5, 0x1d505, 0x1d507, 0x1d50a, 0x1d50d, 0x1d514, 0x1d516, 0x1d51c, 0x1d51e, 0x1d539, 0x1d53b, 0x1d53e, 0x1d540, 0x1d544, 0x1d546, 0x1d546, 0x1d54a, 0x1d550, 0x1d552, 0x1d6a3, 0x1d6a8, 0x1d7c9, 0x20000, 0x2a6d6, 0x2f800, 0x2fa1d, 0xf0000, 0xffffd, 0x100000, 0x10fffd];\n// prettier-ignore-end\n\nconst isBidirectionalL = character => inRange(character, bidirectional_l);\n\n// 2.1.  Mapping\n\n/**\r\n * non-ASCII space characters [StringPrep, C.1.2] that can be\r\n * mapped to SPACE (U+0020)\r\n */\nconst mapping2space = isNonASCIISpaceCharacter;\n\n/**\r\n * the \"commonly mapped to nothing\" characters [StringPrep, B.1]\r\n * that can be mapped to nothing.\r\n */\nconst mapping2nothing = isCommonlyMappedToNothing;\n\n// utils\nconst getCodePoint = character => character.codePointAt(0);\nconst first = x => x[0];\nconst last = x => x[x.length - 1];\n\n/**\r\n * Convert provided string into an array of Unicode Code Points.\r\n * Based on https://stackoverflow.com/a/21409165/1556249\r\n * and https://www.npmjs.com/package/code-point-at.\r\n * @param {string} input\r\n * @returns {number[]}\r\n */\nfunction toCodePoints(input) {\n  const codepoints = [];\n  const size = input.length;\n  for (let i = 0; i < size; i += 1) {\n    const before = input.charCodeAt(i);\n    if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n      const next = input.charCodeAt(i + 1);\n      if (next >= 0xdc00 && next <= 0xdfff) {\n        codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n        i += 1;\n        continue;\n      }\n    }\n    codepoints.push(before);\n  }\n  return codepoints;\n}\n\n/**\r\n * SASLprep.\r\n * @param {string} input\r\n * @param {Object} opts\r\n * @param {boolean} opts.allowUnassigned\r\n * @returns {string}\r\n */\nfunction saslprep(input) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected string.');\n  }\n  if (input.length === 0) {\n    return '';\n  }\n\n  // 1. Map\n  const mapped_input = toCodePoints(input)\n  // 1.1 mapping to space\n  .map(character => mapping2space(character) ? 0x20 : character)\n  // 1.2 mapping to nothing\n  .filter(character => !mapping2nothing(character));\n\n  // 2. Normalize\n  const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize('NFKC');\n  const normalized_map = toCodePoints(normalized_input);\n\n  // 3. Prohibit\n  const hasProhibited = normalized_map.some(isProhibitedCharacter);\n  if (hasProhibited) {\n    throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');\n  }\n\n  // Unassigned Code Points\n  if (opts.allowUnassigned !== true) {\n    const hasUnassigned = normalized_map.some(isUnassignedCodePoint);\n    if (hasUnassigned) {\n      throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');\n    }\n  }\n\n  // 4. check bidi\n\n  const hasBidiRAL = normalized_map.some(isBidirectionalRAL);\n  const hasBidiL = normalized_map.some(isBidirectionalL);\n\n  // 4.1 If a string contains any RandALCat character, the string MUST NOT\n  // contain any LCat character.\n  if (hasBidiRAL && hasBidiL) {\n    throw new Error('String must not contain RandALCat and LCat at the same time,' + ' see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n\n  /**\r\n   * 4.2 If a string contains any RandALCat character, a RandALCat\r\n   * character MUST be the first character of the string, and a\r\n   * RandALCat character MUST be the last character of the string.\r\n   */\n\n  const isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));\n  const isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));\n  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n    throw new Error('Bidirectional RandALCat character must be the first and the last' + ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  return normalized_input;\n}\n\n/*\r\n   PDFSecurity - represents PDF security settings\r\n   By Yang Liu <hi@zesik.com>\r\n */\nclass PDFSecurity {\n  static generateFileID() {\n    let info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let infoStr = `${info.CreationDate.getTime()}\\n`;\n    for (let key in info) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (!info.hasOwnProperty(key)) {\n        continue;\n      }\n      infoStr += `${key}: ${info[key].valueOf()}\\n`;\n    }\n    return wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(infoStr));\n  }\n  static generateRandomWordArray(bytes) {\n    return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.random(bytes);\n  }\n  static create(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      return null;\n    }\n    return new PDFSecurity(document, options);\n  }\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      throw new Error('None of owner password and user password is defined.');\n    }\n    this.document = document;\n    this._setupEncryption(options);\n  }\n  _setupEncryption(options) {\n    switch (options.pdfVersion) {\n      case '1.4':\n      case '1.5':\n        this.version = 2;\n        break;\n      case '1.6':\n      case '1.7':\n        this.version = 4;\n        break;\n      case '1.7ext3':\n        this.version = 5;\n        break;\n      default:\n        this.version = 1;\n        break;\n    }\n    const encDict = {\n      Filter: 'Standard'\n    };\n    switch (this.version) {\n      case 1:\n      case 2:\n      case 4:\n        this._setupEncryptionV1V2V4(this.version, encDict, options);\n        break;\n      case 5:\n        this._setupEncryptionV5(encDict, options);\n        break;\n    }\n    this.dictionary = this.document.ref(encDict);\n  }\n  _setupEncryptionV1V2V4(v, encDict, options) {\n    let r, permissions;\n    switch (v) {\n      case 1:\n        r = 2;\n        this.keyBits = 40;\n        permissions = getPermissionsR2(options.permissions);\n        break;\n      case 2:\n        r = 3;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n      case 4:\n        r = 4;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n    }\n    const paddedUserPassword = processPasswordR2R3R4(options.userPassword);\n    const paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;\n    const ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);\n    this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);\n    let userPasswordEntry;\n    if (r === 2) {\n      userPasswordEntry = getUserPasswordR2(this.encryptionKey);\n    } else {\n      userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);\n    }\n    encDict.V = v;\n    if (v >= 2) {\n      encDict.Length = this.keyBits;\n    }\n    if (v === 4) {\n      encDict.CF = {\n        StdCF: {\n          AuthEvent: 'DocOpen',\n          CFM: 'AESV2',\n          Length: this.keyBits / 8\n        }\n      };\n      encDict.StmF = 'StdCF';\n      encDict.StrF = 'StdCF';\n    }\n    encDict.R = r;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.P = permissions;\n  }\n  _setupEncryptionV5(encDict, options) {\n    this.keyBits = 256;\n    const permissions = getPermissionsR3(options.permissions);\n    const processedUserPassword = processPasswordR5(options.userPassword);\n    const processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;\n    this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray);\n    const userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity.generateRandomWordArray);\n    const userKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);\n    const userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);\n    const ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity.generateRandomWordArray);\n    const ownerKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);\n    const ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);\n    const permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity.generateRandomWordArray);\n    encDict.V = 5;\n    encDict.Length = this.keyBits;\n    encDict.CF = {\n      StdCF: {\n        AuthEvent: 'DocOpen',\n        CFM: 'AESV3',\n        Length: this.keyBits / 8\n      }\n    };\n    encDict.StmF = 'StdCF';\n    encDict.StrF = 'StdCF';\n    encDict.R = 5;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);\n    encDict.P = permissions;\n    encDict.Perms = wordArrayToBuffer(permsEntry);\n  }\n  getEncryptFn(obj, gen) {\n    let digest;\n    if (this.version < 5) {\n      digest = this.encryptionKey.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([(obj & 0xff) << 24 | (obj & 0xff00) << 8 | obj >> 8 & 0xff00 | gen & 0xff, (gen & 0xff00) << 16], 5));\n    }\n    if (this.version === 1 || this.version === 2) {\n      let key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n      key.sigBytes = Math.min(16, this.keyBits / 8 + 5);\n      return buffer => wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key).ciphertext);\n    }\n    let key;\n    if (this.version === 4) {\n      key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([0x73416c54], 4)));\n    } else {\n      key = this.encryptionKey;\n    }\n    const iv = PDFSecurity.generateRandomWordArray(16);\n    const options = {\n      mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n      padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).Pkcs7,\n      iv\n    };\n    return buffer => wordArrayToBuffer(iv.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key, options).ciphertext));\n  }\n  end() {\n    this.dictionary.end();\n  }\n}\nfunction getPermissionsR2() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xffffffc0 >> 0;\n  if (permissionObject.printing) {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  return permissions;\n}\nfunction getPermissionsR3() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xfffff0c0 >> 0;\n  if (permissionObject.printing === 'lowResolution') {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.printing === 'highResolution') {\n    permissions |= 0b100000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  if (permissionObject.fillingForms) {\n    permissions |= 0b000100000000;\n  }\n  if (permissionObject.contentAccessibility) {\n    permissions |= 0b001000000000;\n  }\n  if (permissionObject.documentAssembly) {\n    permissions |= 0b010000000000;\n  }\n  return permissions;\n}\nfunction getUserPasswordR2(encryptionKey) {\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;\n}\nfunction getUserPasswordR3R4(documentId, encryptionKey) {\n  const key = encryptionKey.clone();\n  let cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(processPasswordR2R3R4().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId)));\n  for (let i = 0; i < 20; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16));\n}\nfunction getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {\n  let digest = paddedOwnerPassword;\n  let round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    digest = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n  }\n  const key = digest.clone();\n  key.sigBytes = keyBits / 8;\n  let cipher = paddedUserPassword;\n  round = r >= 3 ? 20 : 1;\n  for (let i = 0; i < round; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = digest.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher;\n}\nfunction getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {\n  let key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId));\n  const round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(key);\n    key.sigBytes = keyBits / 8;\n  }\n  return key;\n}\nfunction getUserPasswordR5(processedUserPassword, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);\n}\nfunction getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(userKeySalt));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);\n}\nfunction getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getEncryptionKeyR5(generateRandomWordArray) {\n  return generateRandomWordArray(32);\n}\nfunction getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {\n  const cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions), 0xffffffff, 0x54616462], 12).concat(generateRandomWordArray(4));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).ECB,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(cipher, encryptionKey, options).ciphertext;\n}\nfunction processPasswordR2R3R4() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const out = Buffer.alloc(32);\n  const length = password.length;\n  let index = 0;\n  while (index < length && index < 32) {\n    const code = password.charCodeAt(index);\n    if (code > 0xff) {\n      throw new Error('Password contains one or more invalid characters.');\n    }\n    out[index] = code;\n    index++;\n  }\n  while (index < 32) {\n    out[index] = PASSWORD_PADDING[index - length];\n    index++;\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction processPasswordR5() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  password = unescape(encodeURIComponent(saslprep(password)));\n  const length = Math.min(127, password.length);\n  const out = Buffer.alloc(length);\n  for (let i = 0; i < length; i++) {\n    out[i] = password.charCodeAt(i);\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction lsbFirstWord(data) {\n  return (data & 0xff) << 24 | (data & 0xff00) << 8 | data >> 8 & 0xff00 | data >> 24 & 0xff;\n}\nfunction wordArrayToBuffer(wordArray) {\n  const byteArray = [];\n  for (let i = 0; i < wordArray.sigBytes; i++) {\n    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 0xff);\n  }\n  return Buffer.from(byteArray);\n}\nconst PASSWORD_PADDING = [0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a];\n\nconst {\n  number\n} = PDFObject;\nclass PDFGradient {\n  constructor(doc) {\n    this.doc = doc;\n    this.stops = [];\n    this.embedded = false;\n    this.transform = [1, 0, 0, 1, 0, 0];\n  }\n  stop(pos, color, opacity) {\n    if (opacity == null) {\n      opacity = 1;\n    }\n    color = this.doc._normalizeColor(color);\n    if (this.stops.length === 0) {\n      if (color.length === 3) {\n        this._colorSpace = 'DeviceRGB';\n      } else if (color.length === 4) {\n        this._colorSpace = 'DeviceCMYK';\n      } else if (color.length === 1) {\n        this._colorSpace = 'DeviceGray';\n      } else {\n        throw new Error('Unknown color space');\n      }\n    } else if (this._colorSpace === 'DeviceRGB' && color.length !== 3 || this._colorSpace === 'DeviceCMYK' && color.length !== 4 || this._colorSpace === 'DeviceGray' && color.length !== 1) {\n      throw new Error('All gradient stops must use the same color space');\n    }\n    opacity = Math.max(0, Math.min(1, opacity));\n    this.stops.push([pos, color, opacity]);\n    return this;\n  }\n  setTransform(m11, m12, m21, m22, dx, dy) {\n    this.transform = [m11, m12, m21, m22, dx, dy];\n    return this;\n  }\n  embed(m) {\n    let fn;\n    const stopsLength = this.stops.length;\n    if (stopsLength === 0) {\n      return;\n    }\n    this.embedded = true;\n    this.matrix = m;\n\n    // if the last stop comes before 100%, add a copy at 100%\n    const last = this.stops[stopsLength - 1];\n    if (last[0] < 1) {\n      this.stops.push([1, last[1], last[2]]);\n    }\n    const bounds = [];\n    const encode = [];\n    const stops = [];\n    for (let i = 0; i < stopsLength - 1; i++) {\n      encode.push(0, 1);\n      if (i + 2 !== stopsLength) {\n        bounds.push(this.stops[i + 1][0]);\n      }\n      fn = this.doc.ref({\n        FunctionType: 2,\n        Domain: [0, 1],\n        C0: this.stops[i + 0][1],\n        C1: this.stops[i + 1][1],\n        N: 1\n      });\n      stops.push(fn);\n      fn.end();\n    }\n\n    // if there are only two stops, we don't need a stitching function\n    if (stopsLength === 1) {\n      fn = stops[0];\n    } else {\n      fn = this.doc.ref({\n        FunctionType: 3,\n        // stitching function\n        Domain: [0, 1],\n        Functions: stops,\n        Bounds: bounds,\n        Encode: encode\n      });\n      fn.end();\n    }\n    this.id = `Sh${++this.doc._gradCount}`;\n    const shader = this.shader(fn);\n    shader.end();\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 2,\n      Shading: shader,\n      Matrix: this.matrix.map(number)\n    });\n    pattern.end();\n    if (this.stops.some(stop => stop[2] < 1)) {\n      let grad = this.opacityGradient();\n      grad._colorSpace = 'DeviceGray';\n      for (let stop of this.stops) {\n        grad.stop(stop[0], [stop[2]]);\n      }\n      grad = grad.embed(this.matrix);\n      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];\n      const form = this.doc.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        FormType: 1,\n        BBox: pageBBox,\n        Group: {\n          Type: 'Group',\n          S: 'Transparency',\n          CS: 'DeviceGray'\n        },\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: grad\n          }\n        }\n      });\n      form.write('/Pattern cs /Sh1 scn');\n      form.end(`${pageBBox.join(' ')} re f`);\n      const gstate = this.doc.ref({\n        Type: 'ExtGState',\n        SMask: {\n          Type: 'Mask',\n          S: 'Luminosity',\n          G: form\n        }\n      });\n      gstate.end();\n      const opacityPattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 1,\n        PaintType: 1,\n        TilingType: 2,\n        BBox: pageBBox,\n        XStep: pageBBox[2],\n        YStep: pageBBox[3],\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: pattern\n          },\n          ExtGState: {\n            Gs1: gstate\n          }\n        }\n      });\n      opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');\n      opacityPattern.end(`${pageBBox.join(' ')} re f`);\n      this.doc.page.patterns[this.id] = opacityPattern;\n    } else {\n      this.doc.page.patterns[this.id] = pattern;\n    }\n    return pattern;\n  }\n  apply(stroke) {\n    // apply gradient transform to existing document ctm\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = this.transform;\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {\n      this.embed(m);\n    }\n    this.doc._setColorSpace('Pattern', stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`/${this.id} ${op}`);\n  }\n}\nclass PDFLinearGradient extends PDFGradient {\n  constructor(doc, x1, y1, x2, y2) {\n    super(doc);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 2,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.x2, this.y2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);\n  }\n}\nclass PDFRadialGradient extends PDFGradient {\n  constructor(doc, x1, y1, r1, x2, y2, r2) {\n    super(doc);\n    this.doc = doc;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.r1 = r1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.r2 = r2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 3,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);\n  }\n}\nvar Gradient = {\n  PDFGradient,\n  PDFLinearGradient,\n  PDFRadialGradient\n};\n\n/*\r\nPDF tiling pattern support. Uncolored only.\r\n */\n\nconst underlyingColorSpaces = ['DeviceCMYK', 'DeviceRGB'];\nclass PDFTilingPattern {\n  constructor(doc, bBox, xStep, yStep, stream) {\n    this.doc = doc;\n    this.bBox = bBox;\n    this.xStep = xStep;\n    this.yStep = yStep;\n    this.stream = stream;\n  }\n  createPattern() {\n    // no resources needed for our current usage\n    // required entry\n    const resources = this.doc.ref();\n    resources.end();\n    // apply default transform matrix (flipped in the default doc._ctm)\n    // see document.js & gradient.js\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 1,\n      // tiling\n      PaintType: 2,\n      // 1-colored, 2-uncolored\n      TilingType: 2,\n      // 2-no distortion\n      BBox: this.bBox,\n      XStep: this.xStep,\n      YStep: this.yStep,\n      Matrix: m.map(v => +v.toFixed(5)),\n      Resources: resources\n    });\n    pattern.end(this.stream);\n    return pattern;\n  }\n  embedPatternColorSpaces() {\n    // map each pattern to an underlying color space\n    // and embed on each page\n    underlyingColorSpaces.forEach(csName => {\n      const csId = this.getPatternColorSpaceId(csName);\n      if (this.doc.page.colorSpaces[csId]) return;\n      const cs = this.doc.ref(['Pattern', csName]);\n      cs.end();\n      this.doc.page.colorSpaces[csId] = cs;\n    });\n  }\n  getPatternColorSpaceId(underlyingColorspace) {\n    return `CsP${underlyingColorspace}`;\n  }\n  embed() {\n    if (!this.id) {\n      this.doc._patternCount = this.doc._patternCount + 1;\n      this.id = 'P' + this.doc._patternCount;\n      this.pattern = this.createPattern();\n    }\n\n    // patterns are embedded in each page\n    if (!this.doc.page.patterns[this.id]) {\n      this.doc.page.patterns[this.id] = this.pattern;\n    }\n  }\n  apply(stroke, patternColor) {\n    // do any embedding/creating that might be needed\n    this.embedPatternColorSpaces();\n    this.embed();\n    const normalizedColor = this.doc._normalizeColor(patternColor);\n    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);\n\n    // select one of the pattern color spaces\n    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));\n    this.doc._setColorSpace(csId, stroke);\n\n    // stroke/fill using the pattern and color (in the above underlying color space)\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`${normalizedColor.join(' ')} /${this.id} ${op}`);\n  }\n}\nvar pattern = {\n  PDFTilingPattern\n};\n\nconst {\n  PDFGradient: PDFGradient$1,\n  PDFLinearGradient: PDFLinearGradient$1,\n  PDFRadialGradient: PDFRadialGradient$1\n} = Gradient;\nconst {\n  PDFTilingPattern: PDFTilingPattern$1\n} = pattern;\nvar ColorMixin = {\n  initColor() {\n    // The opacity dictionaries\n    this._opacityRegistry = {};\n    this._opacityCount = 0;\n    this._patternCount = 0;\n    return this._gradCount = 0;\n  },\n  _normalizeColor(color) {\n    if (typeof color === 'string') {\n      if (color.charAt(0) === '#') {\n        if (color.length === 4) {\n          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, '#$1$1$2$2$3$3');\n        }\n        const hex = parseInt(color.slice(1), 16);\n        color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];\n      } else if (namedColors[color]) {\n        color = namedColors[color];\n      }\n    }\n    if (Array.isArray(color)) {\n      // RGB\n      if (color.length === 3) {\n        color = color.map(part => part / 255);\n        // CMYK\n      } else if (color.length === 4) {\n        color = color.map(part => part / 100);\n      }\n      return color;\n    }\n    return null;\n  },\n  _setColor(color, stroke) {\n    if (color instanceof PDFGradient$1) {\n      color.apply(stroke);\n      return true;\n      // see if tiling pattern, decode & apply it it\n    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern$1) {\n      color[0].apply(stroke, color[1]);\n      return true;\n    }\n    // any other case should be a normal color and not a pattern\n    return this._setColorCore(color, stroke);\n  },\n  _setColorCore(color, stroke) {\n    color = this._normalizeColor(color);\n    if (!color) {\n      return false;\n    }\n    const op = stroke ? 'SCN' : 'scn';\n    const space = this._getColorSpace(color);\n    this._setColorSpace(space, stroke);\n    color = color.join(' ');\n    this.addContent(`${color} ${op}`);\n    return true;\n  },\n  _setColorSpace(space, stroke) {\n    const op = stroke ? 'CS' : 'cs';\n    return this.addContent(`/${space} ${op}`);\n  },\n  _getColorSpace(color) {\n    return color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';\n  },\n  fillColor(color, opacity) {\n    const set = this._setColor(color, false);\n    if (set) {\n      this.fillOpacity(opacity);\n    }\n\n    // save this for text wrapper, which needs to reset\n    // the fill color on new pages\n    this._fillColor = [color, opacity];\n    return this;\n  },\n  strokeColor(color, opacity) {\n    const set = this._setColor(color, true);\n    if (set) {\n      this.strokeOpacity(opacity);\n    }\n    return this;\n  },\n  opacity(opacity) {\n    this._doOpacity(opacity, opacity);\n    return this;\n  },\n  fillOpacity(opacity) {\n    this._doOpacity(opacity, null);\n    return this;\n  },\n  strokeOpacity(opacity) {\n    this._doOpacity(null, opacity);\n    return this;\n  },\n  _doOpacity(fillOpacity, strokeOpacity) {\n    let dictionary, name;\n    if (fillOpacity == null && strokeOpacity == null) {\n      return;\n    }\n    if (fillOpacity != null) {\n      fillOpacity = Math.max(0, Math.min(1, fillOpacity));\n    }\n    if (strokeOpacity != null) {\n      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));\n    }\n    const key = `${fillOpacity}_${strokeOpacity}`;\n    if (this._opacityRegistry[key]) {\n      [dictionary, name] = this._opacityRegistry[key];\n    } else {\n      dictionary = {\n        Type: 'ExtGState'\n      };\n      if (fillOpacity != null) {\n        dictionary.ca = fillOpacity;\n      }\n      if (strokeOpacity != null) {\n        dictionary.CA = strokeOpacity;\n      }\n      dictionary = this.ref(dictionary);\n      dictionary.end();\n      const id = ++this._opacityCount;\n      name = `Gs${id}`;\n      this._opacityRegistry[key] = [dictionary, name];\n    }\n    this.page.ext_gstates[name] = dictionary;\n    return this.addContent(`/${name} gs`);\n  },\n  linearGradient(x1, y1, x2, y2) {\n    return new PDFLinearGradient$1(this, x1, y1, x2, y2);\n  },\n  radialGradient(x1, y1, r1, x2, y2, r2) {\n    return new PDFRadialGradient$1(this, x1, y1, r1, x2, y2, r2);\n  },\n  pattern(bbox, xStep, yStep, stream) {\n    return new PDFTilingPattern$1(this, bbox, xStep, yStep, stream);\n  }\n};\nvar namedColors = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\nlet cx, cy, px, py, sx, sy;\ncx = cy = px = py = sx = sy = 0;\nconst parameters = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nconst parse = function (path) {\n  let cmd;\n  const ret = [];\n  let args = [];\n  let curArg = '';\n  let foundDecimal = false;\n  let params = 0;\n  for (let c of path) {\n    if (parameters[c] != null) {\n      params = parameters[c];\n      if (cmd) {\n        // save existing command\n        if (curArg.length > 0) {\n          args[args.length] = +curArg;\n        }\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [];\n        curArg = '';\n        foundDecimal = false;\n      }\n      cmd = c;\n    } else if ([' ', ','].includes(c) || c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e' || c === '.' && foundDecimal) {\n      if (curArg.length === 0) {\n        continue;\n      }\n      if (args.length === params) {\n        // handle reused commands\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [+curArg];\n\n        // handle assumed commands\n        if (cmd === 'M') {\n          cmd = 'L';\n        }\n        if (cmd === 'm') {\n          cmd = 'l';\n        }\n      } else {\n        args[args.length] = +curArg;\n      }\n      foundDecimal = c === '.';\n\n      // fix for negative numbers or repeated decimals with no delimeter between commands\n      curArg = ['-', '.'].includes(c) ? c : '';\n    } else {\n      curArg += c;\n      if (c === '.') {\n        foundDecimal = true;\n      }\n    }\n  }\n\n  // add the last command\n  if (curArg.length > 0) {\n    if (args.length === params) {\n      // handle reused commands\n      ret[ret.length] = {\n        cmd,\n        args\n      };\n      args = [+curArg];\n\n      // handle assumed commands\n      if (cmd === 'M') {\n        cmd = 'L';\n      }\n      if (cmd === 'm') {\n        cmd = 'l';\n      }\n    } else {\n      args[args.length] = +curArg;\n    }\n  }\n  ret[ret.length] = {\n    cmd,\n    args\n  };\n  return ret;\n};\nconst apply = function (commands, doc) {\n  // current point, control point, and subpath starting point\n  cx = cy = px = py = sx = sy = 0;\n\n  // run the commands\n  for (let i = 0; i < commands.length; i++) {\n    const c = commands[i];\n    if (typeof runners[c.cmd] === 'function') {\n      runners[c.cmd](doc, c.args);\n    }\n  }\n};\nconst runners = {\n  M(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  m(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  C(doc, a) {\n    cx = a[4];\n    cy = a[5];\n    px = a[2];\n    py = a[3];\n    return doc.bezierCurveTo(...a);\n  },\n  c(doc, a) {\n    doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);\n    px = cx + a[2];\n    py = cy + a[3];\n    cx += a[4];\n    return cy += a[5];\n  },\n  S(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    return cy = a[3];\n  },\n  s(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  Q(doc, a) {\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    cy = a[3];\n    return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n  },\n  q(doc, a) {\n    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  T(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, a[0], a[1]);\n    px = cx - (px - cx);\n    py = cy - (py - cy);\n    cx = a[0];\n    return cy = a[1];\n  },\n  t(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n    cx += a[0];\n    return cy += a[1];\n  },\n  A(doc, a) {\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  a(doc, a) {\n    a[5] += cx;\n    a[6] += cy;\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  L(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  l(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  H(doc, a) {\n    cx = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  h(doc, a) {\n    cx += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  V(doc, a) {\n    cy = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  v(doc, a) {\n    cy += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  Z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  },\n  z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  }\n};\nconst solveArc = function (doc, x, y, coords) {\n  const [rx, ry, rot, large, sweep, ex, ey] = coords;\n  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (let seg of segs) {\n    const bez = segmentToBezier(...seg);\n    doc.bezierCurveTo(...bez);\n  }\n};\n\n// from Inkscape svgtopdf, thanks!\nconst arcToSegments = function (x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const th = rotateX * (Math.PI / 180);\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) {\n    sfactor_sq = 0;\n  }\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep === large) {\n    sfactor = -sfactor;\n  }\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  const result = [];\n  for (let i = 0; i < segments; i++) {\n    const th2 = th0 + i * th_arc / segments;\n    const th3 = th0 + (i + 1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n  return result;\n};\nconst segmentToBezier = function (cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const th_half = 0.5 * (th1 - th0);\n  const t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);\n  const x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n  const y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n  const x3 = cx + Math.cos(th1);\n  const y3 = cy + Math.sin(th1);\n  const x2 = x3 + t * Math.sin(th1);\n  const y2 = y3 - t * Math.cos(th1);\n  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n};\nclass SVGPath {\n  static apply(doc, path) {\n    const commands = parse(path);\n    apply(commands, doc);\n  }\n}\n\nconst {\n  number: number$1\n} = PDFObject;\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar VectorMixin = {\n  initVector() {\n    this._ctm = [1, 0, 0, 1, 0, 0]; // current transformation matrix\n    return this._ctmStack = [];\n  },\n  save() {\n    this._ctmStack.push(this._ctm.slice());\n    // TODO: save/restore colorspace and styles so not setting it unnessesarily all the time?\n    return this.addContent('q');\n  },\n  restore() {\n    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];\n    return this.addContent('Q');\n  },\n  closePath() {\n    return this.addContent('h');\n  },\n  lineWidth(w) {\n    return this.addContent(`${number$1(w)} w`);\n  },\n  _CAP_STYLES: {\n    BUTT: 0,\n    ROUND: 1,\n    SQUARE: 2\n  },\n  lineCap(c) {\n    if (typeof c === 'string') {\n      c = this._CAP_STYLES[c.toUpperCase()];\n    }\n    return this.addContent(`${c} J`);\n  },\n  _JOIN_STYLES: {\n    MITER: 0,\n    ROUND: 1,\n    BEVEL: 2\n  },\n  lineJoin(j) {\n    if (typeof j === 'string') {\n      j = this._JOIN_STYLES[j.toUpperCase()];\n    }\n    return this.addContent(`${j} j`);\n  },\n  miterLimit(m) {\n    return this.addContent(`${number$1(m)} M`);\n  },\n  dash(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const originalLength = length;\n    if (!Array.isArray(length)) {\n      length = [length, options.space || length];\n    }\n    const valid = length.every(x => Number.isFinite(x) && x > 0);\n    if (!valid) {\n      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);\n    }\n    length = length.map(number$1).join(' ');\n    return this.addContent(`[${length}] ${number$1(options.phase || 0)} d`);\n  },\n  undash() {\n    return this.addContent('[] 0 d');\n  },\n  moveTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} m`);\n  },\n  lineTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} l`);\n  },\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y)} c`);\n  },\n  quadraticCurveTo(cpx, cpy, x, y) {\n    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y)} v`);\n  },\n  rect(x, y, w, h) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} ${number$1(w)} ${number$1(h)} re`);\n  },\n  roundedRect(x, y, w, h, r) {\n    if (r == null) {\n      r = 0;\n    }\n    r = Math.min(r, 0.5 * w, 0.5 * h);\n\n    // amount to inset control points from corners (see `ellipse`)\n    const c = r * (1.0 - KAPPA);\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);\n    this.lineTo(x + w, y + h - r);\n    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);\n    this.lineTo(x + r, y + h);\n    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);\n    this.lineTo(x, y + r);\n    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);\n    return this.closePath();\n  },\n  ellipse(x, y, r1, r2) {\n    // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084\n    if (r2 == null) {\n      r2 = r1;\n    }\n    x -= r1;\n    y -= r2;\n    const ox = r1 * KAPPA;\n    const oy = r2 * KAPPA;\n    const xe = x + r1 * 2;\n    const ye = y + r2 * 2;\n    const xm = x + r1;\n    const ym = y + r2;\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    return this.closePath();\n  },\n  circle(x, y, radius) {\n    return this.ellipse(x, y, radius);\n  },\n  arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise == null) {\n      anticlockwise = false;\n    }\n    const TWO_PI = 2.0 * Math.PI;\n    const HALF_PI = 0.5 * Math.PI;\n    let deltaAng = endAngle - startAngle;\n    if (Math.abs(deltaAng) > TWO_PI) {\n      // draw only full circle if more than that is specified\n      deltaAng = TWO_PI;\n    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {\n      // necessary to flip direction of rendering\n      const dir = anticlockwise ? -1 : 1;\n      deltaAng = dir * TWO_PI + deltaAng;\n    }\n    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);\n    const segAng = deltaAng / numSegs;\n    const handleLen = segAng / HALF_PI * KAPPA * radius;\n    let curAng = startAngle;\n\n    // component distances between anchor point and control point\n    let deltaCx = -Math.sin(curAng) * handleLen;\n    let deltaCy = Math.cos(curAng) * handleLen;\n\n    // anchor point\n    let ax = x + Math.cos(curAng) * radius;\n    let ay = y + Math.sin(curAng) * radius;\n\n    // calculate and render segments\n    this.moveTo(ax, ay);\n    for (let segIdx = 0; segIdx < numSegs; segIdx++) {\n      // starting control point\n      const cp1x = ax + deltaCx;\n      const cp1y = ay + deltaCy;\n\n      // step angle\n      curAng += segAng;\n\n      // next anchor point\n      ax = x + Math.cos(curAng) * radius;\n      ay = y + Math.sin(curAng) * radius;\n\n      // next control point delta\n      deltaCx = -Math.sin(curAng) * handleLen;\n      deltaCy = Math.cos(curAng) * handleLen;\n\n      // ending control point\n      const cp2x = ax - deltaCx;\n      const cp2y = ay - deltaCy;\n\n      // render segment\n      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);\n    }\n    return this;\n  },\n  polygon() {\n    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n    this.moveTo(...(points.shift() || []));\n    for (let point of points) {\n      this.lineTo(...(point || []));\n    }\n    return this.closePath();\n  },\n  path(path) {\n    SVGPath.apply(this, path);\n    return this;\n  },\n  _windingRule(rule) {\n    if (/even-?odd/.test(rule)) {\n      return '*';\n    }\n    return '';\n  },\n  fill(color, rule) {\n    if (/(even-?odd)|(non-?zero)/.test(color)) {\n      rule = color;\n      color = null;\n    }\n    if (color) {\n      this.fillColor(color);\n    }\n    return this.addContent(`f${this._windingRule(rule)}`);\n  },\n  stroke(color) {\n    if (color) {\n      this.strokeColor(color);\n    }\n    return this.addContent('S');\n  },\n  fillAndStroke(fillColor, strokeColor, rule) {\n    if (strokeColor == null) {\n      strokeColor = fillColor;\n    }\n    const isFillRule = /(even-?odd)|(non-?zero)/;\n    if (isFillRule.test(fillColor)) {\n      rule = fillColor;\n      fillColor = null;\n    }\n    if (isFillRule.test(strokeColor)) {\n      rule = strokeColor;\n      strokeColor = fillColor;\n    }\n    if (fillColor) {\n      this.fillColor(fillColor);\n      this.strokeColor(strokeColor);\n    }\n    return this.addContent(`B${this._windingRule(rule)}`);\n  },\n  clip(rule) {\n    return this.addContent(`W${this._windingRule(rule)} n`);\n  },\n  transform(m11, m12, m21, m22, dx, dy) {\n    // keep track of the current transformation matrix\n    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {\n      // Ignore identity transforms\n      return this;\n    }\n    const m = this._ctm;\n    const [m0, m1, m2, m3, m4, m5] = m;\n    m[0] = m0 * m11 + m2 * m12;\n    m[1] = m1 * m11 + m3 * m12;\n    m[2] = m0 * m21 + m2 * m22;\n    m[3] = m1 * m21 + m3 * m22;\n    m[4] = m0 * dx + m2 * dy + m4;\n    m[5] = m1 * dx + m3 * dy + m5;\n    const values = [m11, m12, m21, m22, dx, dy].map(v => number$1(v)).join(' ');\n    return this.addContent(`${values} cm`);\n  },\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  },\n  rotate(angle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let y;\n    const rad = angle * Math.PI / 180;\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      const x1 = x * cos - y * sin;\n      const y1 = x * sin + y * cos;\n      x -= x1;\n      y -= y1;\n    }\n    return this.transform(cos, sin, -sin, cos, x, y);\n  },\n  scale(xFactor, yFactor) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let y;\n    if (yFactor == null) {\n      yFactor = xFactor;\n    }\n    if (typeof yFactor === 'object') {\n      options = yFactor;\n      yFactor = xFactor;\n    }\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      x -= xFactor * x;\n      y -= yFactor * y;\n    }\n    return this.transform(xFactor, 0, 0, yFactor, x, y);\n  }\n};\n\nconst WIN_ANSI_MAP = {\n  402: 131,\n  8211: 150,\n  8212: 151,\n  8216: 145,\n  8217: 146,\n  8218: 130,\n  8220: 147,\n  8221: 148,\n  8222: 132,\n  8224: 134,\n  8225: 135,\n  8226: 149,\n  8230: 133,\n  8364: 128,\n  8240: 137,\n  8249: 139,\n  8250: 155,\n  710: 136,\n  8482: 153,\n  338: 140,\n  339: 156,\n  732: 152,\n  352: 138,\n  353: 154,\n  376: 159,\n  381: 142,\n  382: 158\n};\nconst characters = `\\\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis\\\n`.split(/\\s+/);\nclass AFMFont {\n  static open(filename) {\n    return new AFMFont(fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(filename, 'utf8'));\n  }\n  constructor(contents) {\n    this.contents = contents;\n    this.attributes = {};\n    this.glyphWidths = {};\n    this.boundingBoxes = {};\n    this.kernPairs = {};\n    this.parse();\n    // todo: remove charWidths since appears to not be used\n    this.charWidths = new Array(256);\n    for (let char = 0; char <= 255; char++) {\n      this.charWidths[char] = this.glyphWidths[characters[char]];\n    }\n    this.bbox = this.attributes['FontBBox'].split(/\\s+/).map(e => +e);\n    this.ascender = +(this.attributes['Ascender'] || 0);\n    this.descender = +(this.attributes['Descender'] || 0);\n    this.xHeight = +(this.attributes['XHeight'] || 0);\n    this.capHeight = +(this.attributes['CapHeight'] || 0);\n    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);\n  }\n  parse() {\n    let section = '';\n    for (let line of this.contents.split('\\n')) {\n      var match;\n      var a;\n      if (match = line.match(/^Start(\\w+)/)) {\n        section = match[1];\n        continue;\n      } else if (match = line.match(/^End(\\w+)/)) {\n        section = '';\n        continue;\n      }\n      switch (section) {\n        case 'FontMetrics':\n          match = line.match(/(^\\w+)\\s+(.*)/);\n          var key = match[1];\n          var value = match[2];\n          if (a = this.attributes[key]) {\n            if (!Array.isArray(a)) {\n              a = this.attributes[key] = [a];\n            }\n            a.push(value);\n          } else {\n            this.attributes[key] = value;\n          }\n          break;\n        case 'CharMetrics':\n          if (!/^CH?\\s/.test(line)) {\n            continue;\n          }\n          var name = line.match(/\\bN\\s+(\\.?\\w+)\\s*;/)[1];\n          this.glyphWidths[name] = +line.match(/\\bWX\\s+(\\d+)\\s*;/)[1];\n          break;\n        case 'KernPairs':\n          match = line.match(/^KPX\\s+(\\.?\\w+)\\s+(\\.?\\w+)\\s+(-?\\d+)/);\n          if (match) {\n            this.kernPairs[match[1] + '\\0' + match[2]] = parseInt(match[3]);\n          }\n          break;\n      }\n    }\n  }\n  encodeText(text) {\n    const res = [];\n    for (let i = 0, len = text.length; i < len; i++) {\n      let char = text.charCodeAt(i);\n      char = WIN_ANSI_MAP[char] || char;\n      res.push(char.toString(16));\n    }\n    return res;\n  }\n  glyphsForString(string) {\n    const glyphs = [];\n    for (let i = 0, len = string.length; i < len; i++) {\n      const charCode = string.charCodeAt(i);\n      glyphs.push(this.characterToGlyph(charCode));\n    }\n    return glyphs;\n  }\n  characterToGlyph(character) {\n    return characters[WIN_ANSI_MAP[character] || character] || '.notdef';\n  }\n  widthOfGlyph(glyph) {\n    return this.glyphWidths[glyph] || 0;\n  }\n  getKernPair(left, right) {\n    return this.kernPairs[left + '\\0' + right] || 0;\n  }\n  advancesForGlyphs(glyphs) {\n    const advances = [];\n    for (let index = 0; index < glyphs.length; index++) {\n      const left = glyphs[index];\n      const right = glyphs[index + 1];\n      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));\n    }\n    return advances;\n  }\n}\n\nclass PDFFont {\n  constructor() {}\n  encode() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  widthOfString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  ref() {\n    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();\n  }\n  finalize() {\n    if (this.embedded || this.dictionary == null) {\n      return;\n    }\n    this.embed();\n    return this.embedded = true;\n  }\n  embed() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  lineHeight(size, includeGap) {\n    if (includeGap == null) {\n      includeGap = false;\n    }\n    const gap = includeGap ? this.lineGap : 0;\n    return (this.ascender + gap - this.descender) / 1000 * size;\n  }\n}\n\n// This insanity is so bundlers can inline the font files\nconst STANDARD_FONTS = {\n  Courier() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier.afm', 'utf8');\n  },\n  'Courier-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Bold.afm', 'utf8');\n  },\n  'Courier-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Oblique.afm', 'utf8');\n  },\n  'Courier-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-BoldOblique.afm', 'utf8');\n  },\n  Helvetica() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica.afm', 'utf8');\n  },\n  'Helvetica-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Bold.afm', 'utf8');\n  },\n  'Helvetica-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Oblique.afm', 'utf8');\n  },\n  'Helvetica-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-BoldOblique.afm', 'utf8');\n  },\n  'Times-Roman'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Roman.afm', 'utf8');\n  },\n  'Times-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Bold.afm', 'utf8');\n  },\n  'Times-Italic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Italic.afm', 'utf8');\n  },\n  'Times-BoldItalic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-BoldItalic.afm', 'utf8');\n  },\n  Symbol() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Symbol.afm', 'utf8');\n  },\n  ZapfDingbats() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/ZapfDingbats.afm', 'utf8');\n  }\n};\nclass StandardFont extends PDFFont {\n  constructor(document, name, id) {\n    super();\n    this.document = document;\n    this.name = name;\n    this.id = id;\n    this.font = new AFMFont(STANDARD_FONTS[this.name]());\n    ({\n      ascender: this.ascender,\n      descender: this.descender,\n      bbox: this.bbox,\n      lineGap: this.lineGap,\n      xHeight: this.xHeight,\n      capHeight: this.capHeight\n    } = this.font);\n  }\n  embed() {\n    this.dictionary.data = {\n      Type: 'Font',\n      BaseFont: this.name,\n      Subtype: 'Type1',\n      Encoding: 'WinAnsiEncoding'\n    };\n    return this.dictionary.end();\n  }\n  encode(text) {\n    const encoded = this.font.encodeText(text);\n    const glyphs = this.font.glyphsForString(`${text}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    const positions = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      positions.push({\n        xAdvance: advances[i],\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n        advanceWidth: this.font.widthOfGlyph(glyph)\n      });\n    }\n    return [encoded, positions];\n  }\n  widthOfString(string, size) {\n    const glyphs = this.font.glyphsForString(`${string}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    let width = 0;\n    for (let advance of advances) {\n      width += advance;\n    }\n    const scale = size / 1000;\n    return width * scale;\n  }\n  static isStandardFont(name) {\n    return name in STANDARD_FONTS;\n  }\n}\n\nconst toHex = function (num) {\n  return `0000${num.toString(16)}`.slice(-4);\n};\nclass EmbeddedFont extends PDFFont {\n  constructor(document, font, id) {\n    super();\n    this.document = document;\n    this.font = font;\n    this.id = id;\n    this.subset = this.font.createSubset();\n    this.unicode = [[0]];\n    this.widths = [this.font.getGlyph(0).advanceWidth];\n    this.name = this.font.postscriptName;\n    this.scale = 1000 / this.font.unitsPerEm;\n    this.ascender = this.font.ascent * this.scale;\n    this.descender = this.font.descent * this.scale;\n    this.xHeight = this.font.xHeight * this.scale;\n    this.capHeight = this.font.capHeight * this.scale;\n    this.lineGap = this.font.lineGap * this.scale;\n    this.bbox = this.font.bbox;\n    if (document.options.fontLayoutCache !== false) {\n      this.layoutCache = Object.create(null);\n    }\n  }\n  layoutRun(text, features) {\n    const run = this.font.layout(text, features);\n\n    // Normalize position values\n    for (let i = 0; i < run.positions.length; i++) {\n      const position = run.positions[i];\n      for (let key in position) {\n        position[key] *= this.scale;\n      }\n      position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;\n    }\n    return run;\n  }\n  layoutCached(text) {\n    if (!this.layoutCache) {\n      return this.layoutRun(text);\n    }\n    let cached;\n    if (cached = this.layoutCache[text]) {\n      return cached;\n    }\n    const run = this.layoutRun(text);\n    this.layoutCache[text] = run;\n    return run;\n  }\n  layout(text, features, onlyWidth) {\n    // Skip the cache if any user defined features are applied\n    if (features) {\n      return this.layoutRun(text, features);\n    }\n    let glyphs = onlyWidth ? null : [];\n    let positions = onlyWidth ? null : [];\n    let advanceWidth = 0;\n\n    // Split the string by words to increase cache efficiency.\n    // For this purpose, spaces and tabs are a good enough delimeter.\n    let last = 0;\n    let index = 0;\n    while (index <= text.length) {\n      var needle;\n      if (index === text.length && last < index || (needle = text.charAt(index), [' ', '\\t'].includes(needle))) {\n        const run = this.layoutCached(text.slice(last, ++index));\n        if (!onlyWidth) {\n          glyphs = glyphs.concat(run.glyphs);\n          positions = positions.concat(run.positions);\n        }\n        advanceWidth += run.advanceWidth;\n        last = index;\n      } else {\n        index++;\n      }\n    }\n    return {\n      glyphs,\n      positions,\n      advanceWidth\n    };\n  }\n  encode(text, features) {\n    const {\n      glyphs,\n      positions\n    } = this.layout(text, features);\n    const res = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const gid = this.subset.includeGlyph(glyph.id);\n      res.push(`0000${gid.toString(16)}`.slice(-4));\n      if (this.widths[gid] == null) {\n        this.widths[gid] = glyph.advanceWidth * this.scale;\n      }\n      if (this.unicode[gid] == null) {\n        this.unicode[gid] = glyph.codePoints;\n      }\n    }\n    return [res, positions];\n  }\n  widthOfString(string, size, features) {\n    const width = this.layout(string, features, true).advanceWidth;\n    const scale = size / 1000;\n    return width * scale;\n  }\n  embed() {\n    const isCFF = this.subset.cff != null;\n    const fontFile = this.document.ref();\n    if (isCFF) {\n      fontFile.data.Subtype = 'CIDFontType0C';\n    }\n    this.subset.encodeStream().on('data', data => fontFile.write(data)).on('end', () => fontFile.end());\n    const familyClass = ((this.font['OS/2'] != null ? this.font['OS/2'].sFamilyClass : undefined) || 0) >> 8;\n    let flags = 0;\n    if (this.font.post.isFixedPitch) {\n      flags |= 1 << 0;\n    }\n    if (1 <= familyClass && familyClass <= 7) {\n      flags |= 1 << 1;\n    }\n    flags |= 1 << 2; // assume the font uses non-latin characters\n    if (familyClass === 10) {\n      flags |= 1 << 3;\n    }\n    if (this.font.head.macStyle.italic) {\n      flags |= 1 << 6;\n    }\n\n    // generate a tag (6 uppercase letters. 17 is the char code offset from '0' to 'A'. 73 will map to 'Z')\n    const tag = [1, 2, 3, 4, 5, 6].map(i => String.fromCharCode((this.id.charCodeAt(i) || 73) + 17)).join('');\n    const name = tag + '+' + this.font.postscriptName;\n    const {\n      bbox\n    } = this.font;\n    const descriptor = this.document.ref({\n      Type: 'FontDescriptor',\n      FontName: name,\n      Flags: flags,\n      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],\n      ItalicAngle: this.font.italicAngle,\n      Ascent: this.ascender,\n      Descent: this.descender,\n      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,\n      XHeight: (this.font.xHeight || 0) * this.scale,\n      StemV: 0\n    }); // not sure how to calculate this\n\n    if (isCFF) {\n      descriptor.data.FontFile3 = fontFile;\n    } else {\n      descriptor.data.FontFile2 = fontFile;\n    }\n    if (this.document.subset && this.document.subset === 1) {\n      const CIDSet = Buffer.from('FFFFFFFFC0', 'hex');\n      const CIDSetRef = this.document.ref();\n      CIDSetRef.write(CIDSet);\n      CIDSetRef.end();\n      descriptor.data.CIDSet = CIDSetRef;\n    }\n    descriptor.end();\n    const descendantFontData = {\n      Type: 'Font',\n      Subtype: 'CIDFontType0',\n      BaseFont: name,\n      CIDSystemInfo: {\n        Registry: new String('Adobe'),\n        Ordering: new String('Identity'),\n        Supplement: 0\n      },\n      FontDescriptor: descriptor,\n      W: [0, this.widths]\n    };\n    if (!isCFF) {\n      descendantFontData.Subtype = 'CIDFontType2';\n      descendantFontData.CIDToGIDMap = 'Identity';\n    }\n    const descendantFont = this.document.ref(descendantFontData);\n    descendantFont.end();\n    this.dictionary.data = {\n      Type: 'Font',\n      Subtype: 'Type0',\n      BaseFont: name,\n      Encoding: 'Identity-H',\n      DescendantFonts: [descendantFont],\n      ToUnicode: this.toUnicodeCmap()\n    };\n    return this.dictionary.end();\n  }\n\n  // Maps the glyph ids encoded in the PDF back to unicode strings\n  // Because of ligature substitutions and the like, there may be one or more\n  // unicode characters represented by each glyph.\n  toUnicodeCmap() {\n    const cmap = this.document.ref();\n    const entries = [];\n    for (let codePoints of this.unicode) {\n      const encoded = [];\n\n      // encode codePoints to utf16\n      for (let value of codePoints) {\n        if (value > 0xffff) {\n          value -= 0x10000;\n          encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));\n          value = 0xdc00 | value & 0x3ff;\n        }\n        encoded.push(toHex(value));\n      }\n      entries.push(`<${encoded.join(' ')}>`);\n    }\n    const chunkSize = 256;\n    const chunks = Math.ceil(entries.length / chunkSize);\n    const ranges = [];\n    for (let i = 0; i < chunks; i++) {\n      const start = i * chunkSize;\n      const end = Math.min((i + 1) * chunkSize, entries.length);\n      ranges.push(`<${toHex(start)}> <${toHex(end - 1)}> [${entries.slice(start, end).join(' ')}]`);\n    }\n    cmap.end(`\\\n/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n${ranges.join('\\n')}\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\\\n`);\n    return cmap;\n  }\n}\n\nclass PDFFontFactory {\n  static open(document, src, family, id) {\n    let font;\n    if (typeof src === 'string') {\n      if (StandardFont.isStandardFont(src)) {\n        return new StandardFont(document, src, id);\n      }\n      src = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n    }\n    if (Buffer.isBuffer(src)) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(src, family);\n    } else if (src instanceof Uint8Array) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(Buffer.from(src), family);\n    } else if (src instanceof ArrayBuffer) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(Buffer.from(new Uint8Array(src)), family);\n    }\n    if (font == null) {\n      throw new Error('Not a supported font format or standard PDF font.');\n    }\n    return new EmbeddedFont(document, font, id);\n  }\n}\n\nvar FontsMixin = {\n  initFonts() {\n    let defaultFont = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica';\n    // Lookup table for embedded fonts\n    this._fontFamilies = {};\n    this._fontCount = 0;\n\n    // Font state\n    this._fontSize = 12;\n    this._font = null;\n    this._registeredFonts = {};\n\n    // Set the default font\n    if (defaultFont) {\n      this.font(defaultFont);\n    }\n  },\n  font(src, family, size) {\n    let cacheKey, font;\n    if (typeof family === 'number') {\n      size = family;\n      family = null;\n    }\n\n    // check registered fonts if src is a string\n    if (typeof src === 'string' && this._registeredFonts[src]) {\n      cacheKey = src;\n      ({\n        src,\n        family\n      } = this._registeredFonts[src]);\n    } else {\n      cacheKey = family || src;\n      if (typeof cacheKey !== 'string') {\n        cacheKey = null;\n      }\n    }\n    if (size != null) {\n      this.fontSize(size);\n    }\n\n    // fast path: check if the font is already in the PDF\n    if (font = this._fontFamilies[cacheKey]) {\n      this._font = font;\n      return this;\n    }\n\n    // load the font\n    const id = `F${++this._fontCount}`;\n    this._font = PDFFontFactory.open(this, src, family, id);\n\n    // check for existing font familes with the same name already in the PDF\n    // useful if the font was passed as a buffer\n    if (font = this._fontFamilies[this._font.name]) {\n      this._font = font;\n      return this;\n    }\n\n    // save the font for reuse later\n    if (cacheKey) {\n      this._fontFamilies[cacheKey] = this._font;\n    }\n    if (this._font.name) {\n      this._fontFamilies[this._font.name] = this._font;\n    }\n    return this;\n  },\n  fontSize(_fontSize) {\n    this._fontSize = _fontSize;\n    return this;\n  },\n  currentLineHeight(includeGap) {\n    if (includeGap == null) {\n      includeGap = false;\n    }\n    return this._font.lineHeight(this._fontSize, includeGap);\n  },\n  registerFont(name, src, family) {\n    this._registeredFonts[name] = {\n      src,\n      family\n    };\n    return this;\n  }\n};\n\nconst SOFT_HYPHEN = '\\u00AD';\nconst HYPHEN = '-';\nclass LineWrapper extends events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter {\n  constructor(document, options) {\n    super();\n    this.document = document;\n    this.indent = options.indent || 0;\n    this.characterSpacing = options.characterSpacing || 0;\n    this.wordSpacing = options.wordSpacing === 0;\n    this.columns = options.columns || 1;\n    this.columnGap = options.columnGap != null ? options.columnGap : 18; // 1/4 inch\n    this.lineWidth = (options.width - this.columnGap * (this.columns - 1)) / this.columns;\n    this.spaceLeft = this.lineWidth;\n    this.startX = this.document.x;\n    this.startY = this.document.y;\n    this.column = 1;\n    this.ellipsis = options.ellipsis;\n    this.continuedX = 0;\n    this.features = options.features;\n\n    // calculate the maximum Y position the text can appear at\n    if (options.height != null) {\n      this.height = options.height;\n      this.maxY = this.startY + options.height;\n    } else {\n      this.maxY = this.document.page.maxY();\n    }\n\n    // handle paragraph indents\n    this.on('firstLine', options => {\n      // if this is the first line of the text segment, and\n      // we're continuing where we left off, indent that much\n      // otherwise use the user specified indent option\n      const indent = this.continuedX || this.indent;\n      this.document.x += indent;\n      this.lineWidth -= indent;\n      return this.once('line', () => {\n        this.document.x -= indent;\n        this.lineWidth += indent;\n        if (options.continued && !this.continuedX) {\n          this.continuedX = this.indent;\n        }\n        if (!options.continued) {\n          return this.continuedX = 0;\n        }\n      });\n    });\n\n    // handle left aligning last lines of paragraphs\n    this.on('lastLine', options => {\n      const {\n        align\n      } = options;\n      if (align === 'justify') {\n        options.align = 'left';\n      }\n      this.lastLine = true;\n      return this.once('line', () => {\n        this.document.y += options.paragraphGap || 0;\n        options.align = align;\n        return this.lastLine = false;\n      });\n    });\n  }\n  wordWidth(word) {\n    return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;\n  }\n  canFit(word, w) {\n    if (word[word.length - 1] != SOFT_HYPHEN) {\n      return w <= this.spaceLeft;\n    }\n    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;\n  }\n  eachWord(text, fn) {\n    // setup a unicode line breaker\n    let bk;\n    const breaker = new linebreak__WEBPACK_IMPORTED_MODULE_6__[\"default\"](text);\n    let last = null;\n    const wordWidths = Object.create(null);\n    while (bk = breaker.nextBreak()) {\n      var shouldContinue;\n      let word = text.slice((last != null ? last.position : undefined) || 0, bk.position);\n      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);\n\n      // if the word is longer than the whole line, chop it up\n      // TODO: break by grapheme clusters, not JS string characters\n      if (w > this.lineWidth + this.continuedX) {\n        // make some fake break objects\n        let lbk = last;\n        const fbk = {};\n        while (word.length) {\n          // fit as much of the word as possible into the space we have\n          var l, mightGrow;\n          if (w > this.spaceLeft) {\n            // start our check at the end of our available space - this method is faster than a loop of each character and it resolves\n            // an issue with long loops when processing massive words, such as a huge number of spaces\n            l = Math.ceil(this.spaceLeft / (w / word.length));\n            w = this.wordWidth(word.slice(0, l));\n            mightGrow = w <= this.spaceLeft && l < word.length;\n          } else {\n            l = word.length;\n          }\n          let mustShrink = w > this.spaceLeft && l > 0;\n          // shrink or grow word as necessary after our near-guess above\n          while (mustShrink || mightGrow) {\n            if (mustShrink) {\n              w = this.wordWidth(word.slice(0, --l));\n              mustShrink = w > this.spaceLeft && l > 0;\n            } else {\n              w = this.wordWidth(word.slice(0, ++l));\n              mustShrink = w > this.spaceLeft && l > 0;\n              mightGrow = w <= this.spaceLeft && l < word.length;\n            }\n          }\n\n          // check for the edge case where a single character cannot fit into a line.\n          if (l === 0 && this.spaceLeft === this.lineWidth) {\n            l = 1;\n          }\n\n          // send a required break unless this is the last piece and a linebreak is not specified\n          fbk.required = bk.required || l < word.length;\n          shouldContinue = fn(word.slice(0, l), w, fbk, lbk);\n          lbk = {\n            required: false\n          };\n\n          // get the remaining piece of the word\n          word = word.slice(l);\n          w = this.wordWidth(word);\n          if (shouldContinue === false) {\n            break;\n          }\n        }\n      } else {\n        // otherwise just emit the break as it was given to us\n        shouldContinue = fn(word, w, bk, last);\n      }\n      if (shouldContinue === false) {\n        break;\n      }\n      last = bk;\n    }\n  }\n  wrap(text, options) {\n    // override options from previous continued fragments\n    if (options.indent != null) {\n      this.indent = options.indent;\n    }\n    if (options.characterSpacing != null) {\n      this.characterSpacing = options.characterSpacing;\n    }\n    if (options.wordSpacing != null) {\n      this.wordSpacing = options.wordSpacing;\n    }\n    if (options.ellipsis != null) {\n      this.ellipsis = options.ellipsis;\n    }\n\n    // make sure we're actually on the page\n    // and that the first line of is never by\n    // itself at the bottom of a page (orphans)\n    const nextY = this.document.y + this.document.currentLineHeight(true);\n    if (this.document.y > this.maxY || nextY > this.maxY) {\n      this.nextSection();\n    }\n    let buffer = '';\n    let textWidth = 0;\n    let wc = 0;\n    let lc = 0;\n    let {\n      y\n    } = this.document; // used to reset Y pos if options.continued (below)\n    const emitLine = () => {\n      options.textWidth = textWidth + this.wordSpacing * (wc - 1);\n      options.wordCount = wc;\n      options.lineWidth = this.lineWidth;\n      ({\n        y\n      } = this.document);\n      this.emit('line', buffer, options, this);\n      return lc++;\n    };\n    this.emit('sectionStart', options, this);\n    this.eachWord(text, (word, w, bk, last) => {\n      if (last == null || last.required) {\n        this.emit('firstLine', options, this);\n        this.spaceLeft = this.lineWidth;\n      }\n      if (this.canFit(word, w)) {\n        buffer += word;\n        textWidth += w;\n        wc++;\n      }\n      if (bk.required || !this.canFit(word, w)) {\n        // if the user specified a max height and an ellipsis, and is about to pass the\n        // max height and max columns after the next line, append the ellipsis\n        const lh = this.document.currentLineHeight(true);\n        if (this.height != null && this.ellipsis && this.document.y + lh * 2 > this.maxY && this.column >= this.columns) {\n          if (this.ellipsis === true) {\n            this.ellipsis = '…';\n          } // map default ellipsis character\n          buffer = buffer.replace(/\\s+$/, '');\n          textWidth = this.wordWidth(buffer + this.ellipsis);\n\n          // remove characters from the buffer until the ellipsis fits\n          // to avoid infinite loop need to stop while-loop if buffer is empty string\n          while (buffer && textWidth > this.lineWidth) {\n            buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\n            textWidth = this.wordWidth(buffer + this.ellipsis);\n          }\n          // need to add ellipsis only if there is enough space for it\n          if (textWidth <= this.lineWidth) {\n            buffer = buffer + this.ellipsis;\n          }\n          textWidth = this.wordWidth(buffer);\n        }\n        if (bk.required) {\n          if (w > this.spaceLeft) {\n            emitLine();\n            buffer = word;\n            textWidth = w;\n            wc = 1;\n          }\n          this.emit('lastLine', options, this);\n        }\n\n        // Previous entry is a soft hyphen - add visible hyphen.\n        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {\n          buffer = buffer.slice(0, -1) + HYPHEN;\n          this.spaceLeft -= this.wordWidth(HYPHEN);\n        }\n        emitLine();\n\n        // if we've reached the edge of the page,\n        // continue on a new page or column\n        if (this.document.y + lh > this.maxY) {\n          const shouldContinue = this.nextSection();\n\n          // stop if we reached the maximum height\n          if (!shouldContinue) {\n            wc = 0;\n            buffer = '';\n            return false;\n          }\n        }\n\n        // reset the space left and buffer\n        if (bk.required) {\n          this.spaceLeft = this.lineWidth;\n          buffer = '';\n          textWidth = 0;\n          return wc = 0;\n        } else {\n          // reset the space left and buffer\n          this.spaceLeft = this.lineWidth - w;\n          buffer = word;\n          textWidth = w;\n          return wc = 1;\n        }\n      } else {\n        return this.spaceLeft -= w;\n      }\n    });\n    if (wc > 0) {\n      this.emit('lastLine', options, this);\n      emitLine();\n    }\n    this.emit('sectionEnd', options, this);\n\n    // if the wrap is set to be continued, save the X position\n    // to start the first line of the next segment at, and reset\n    // the y position\n    if (options.continued === true) {\n      if (lc > 1) {\n        this.continuedX = 0;\n      }\n      this.continuedX += options.textWidth || 0;\n      return this.document.y = y;\n    } else {\n      return this.document.x = this.startX;\n    }\n  }\n  nextSection(options) {\n    this.emit('sectionEnd', options, this);\n    if (++this.column > this.columns) {\n      // if a max height was specified by the user, we're done.\n      // otherwise, the default is to make a new page at the bottom.\n      if (this.height != null) {\n        return false;\n      }\n      this.document.continueOnNewPage();\n      this.column = 1;\n      this.startY = this.document.page.margins.top;\n      this.maxY = this.document.page.maxY();\n      this.document.x = this.startX;\n      if (this.document._fillColor) {\n        this.document.fillColor(...this.document._fillColor);\n      }\n      this.emit('pageBreak', options, this);\n    } else {\n      this.document.x += this.lineWidth + this.columnGap;\n      this.document.y = this.startY;\n      this.emit('columnBreak', options, this);\n    }\n    this.emit('sectionStart', options, this);\n    return true;\n  }\n}\n\nconst {\n  number: number$2\n} = PDFObject;\nvar TextMixin = {\n  initText() {\n    this._line = this._line.bind(this);\n    // Current coordinates\n    this.x = 0;\n    this.y = 0;\n    return this._lineGap = 0;\n  },\n  lineGap(_lineGap) {\n    this._lineGap = _lineGap;\n    return this;\n  },\n  moveDown(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y += this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  moveUp(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y -= this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  _text(text, x, y, options, lineCallback) {\n    options = this._initOptions(x, y, options);\n\n    // Convert text to a string\n    text = text == null ? '' : `${text}`;\n\n    // if the wordSpacing option is specified, remove multiple consecutive spaces\n    if (options.wordSpacing) {\n      text = text.replace(/\\s{2,}/g, ' ');\n    }\n    const addStructure = () => {\n      if (options.structParent) {\n        options.structParent.add(this.struct(options.structType || 'P', [this.markStructureContent(options.structType || 'P')]));\n      }\n    };\n\n    // word wrapping\n    if (options.width) {\n      let wrapper = this._wrapper;\n      if (!wrapper) {\n        wrapper = new LineWrapper(this, options);\n        wrapper.on('line', lineCallback);\n        wrapper.on('firstLine', addStructure);\n      }\n      this._wrapper = options.continued ? wrapper : null;\n      this._textOptions = options.continued ? options : null;\n      wrapper.wrap(text, options);\n\n      // render paragraphs as single lines\n    } else {\n      for (let line of text.split('\\n')) {\n        addStructure();\n        lineCallback(line, options);\n      }\n    }\n    return this;\n  },\n  text(text, x, y, options) {\n    return this._text(text, x, y, options, this._line);\n  },\n  widthOfString(string) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);\n  },\n  heightOfString(text, options) {\n    const {\n      x,\n      y\n    } = this;\n    options = this._initOptions(options);\n    options.height = Infinity; // don't break pages\n\n    const lineGap = options.lineGap || this._lineGap || 0;\n    this._text(text, this.x, this.y, options, () => {\n      return this.y += this.currentLineHeight(true) + lineGap;\n    });\n    const height = this.y - y;\n    this.x = x;\n    this.y = y;\n    return height;\n  },\n  list(list, x, y, options, wrapper) {\n    options = this._initOptions(x, y, options);\n    const listType = options.listType || 'bullet';\n    const unit = Math.round(this._font.ascender / 1000 * this._fontSize);\n    const midLine = unit / 2;\n    const r = options.bulletRadius || unit / 3;\n    const indent = options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);\n    const itemIndent = options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);\n    let level = 1;\n    const items = [];\n    const levels = [];\n    const numbers = [];\n    var flatten = function (list) {\n      let n = 1;\n      for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n          level++;\n          flatten(item);\n          level--;\n        } else {\n          items.push(item);\n          levels.push(level);\n          if (listType !== 'bullet') {\n            numbers.push(n++);\n          }\n        }\n      }\n    };\n    flatten(list);\n    const label = function (n) {\n      switch (listType) {\n        case 'numbered':\n          return `${n}.`;\n        case 'lettered':\n          var letter = String.fromCharCode((n - 1) % 26 + 65);\n          var times = Math.floor((n - 1) / 26 + 1);\n          var text = Array(times + 1).join(letter);\n          return `${text}.`;\n      }\n    };\n    const drawListItem = function (listItem, i) {\n      wrapper = new LineWrapper(this, options);\n      wrapper.on('line', this._line);\n      level = 1;\n      wrapper.once('firstLine', () => {\n        let item, itemType, labelType, bodyType;\n        if (options.structParent) {\n          if (options.structTypes) {\n            [itemType, labelType, bodyType] = options.structTypes;\n          } else {\n            [itemType, labelType, bodyType] = ['LI', 'Lbl', 'LBody'];\n          }\n        }\n        if (itemType) {\n          item = this.struct(itemType);\n          options.structParent.add(item);\n        } else if (options.structParent) {\n          item = options.structParent;\n        }\n        let l;\n        if ((l = levels[i++]) !== level) {\n          const diff = itemIndent * (l - level);\n          this.x += diff;\n          wrapper.lineWidth -= diff;\n          level = l;\n        }\n        if (item && (labelType || bodyType)) {\n          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));\n        }\n        switch (listType) {\n          case 'bullet':\n            this.circle(this.x - indent + r, this.y + midLine, r);\n            this.fill();\n            break;\n          case 'numbered':\n          case 'lettered':\n            var text = label(numbers[i - 1]);\n            this._fragment(text, this.x - indent, this.y, options);\n            break;\n        }\n        if (item && labelType && bodyType) {\n          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));\n        }\n        if (item && item !== options.structParent) {\n          item.end();\n        }\n      });\n      wrapper.on('sectionStart', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x += pos;\n        return wrapper.lineWidth -= pos;\n      });\n      wrapper.on('sectionEnd', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x -= pos;\n        return wrapper.lineWidth += pos;\n      });\n      wrapper.wrap(listItem, options);\n    };\n    for (let i = 0; i < items.length; i++) {\n      drawListItem.call(this, items[i], i);\n    }\n    return this;\n  },\n  _initOptions() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let y = arguments.length > 1 ? arguments[1] : undefined;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n\n    // clone options object\n    const result = Object.assign({}, options);\n\n    // extend options with previous values for continued text\n    if (this._textOptions) {\n      for (let key in this._textOptions) {\n        const val = this._textOptions[key];\n        if (key !== 'continued') {\n          if (result[key] === undefined) {\n            result[key] = val;\n          }\n        }\n      }\n    }\n\n    // Update the current position\n    if (x != null) {\n      this.x = x;\n    }\n    if (y != null) {\n      this.y = y;\n    }\n\n    // wrap to margins if no x or y position passed\n    if (result.lineBreak !== false) {\n      if (result.width == null) {\n        result.width = this.page.width - this.x - this.page.margins.right;\n      }\n      result.width = Math.max(result.width, 0);\n    }\n    if (!result.columns) {\n      result.columns = 0;\n    }\n    if (result.columnGap == null) {\n      result.columnGap = 18;\n    } // 1/4 inch\n\n    return result;\n  },\n  _line(text) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let wrapper = arguments.length > 2 ? arguments[2] : undefined;\n    this._fragment(text, this.x, this.y, options);\n    const lineGap = options.lineGap || this._lineGap || 0;\n    if (!wrapper) {\n      return this.x += this.widthOfString(text);\n    } else {\n      return this.y += this.currentLineHeight(true) + lineGap;\n    }\n  },\n  _fragment(text, x, y, options) {\n    let dy, encoded, i, positions, textWidth, words;\n    text = `${text}`.replace(/\\n/g, '');\n    if (text.length === 0) {\n      return;\n    }\n\n    // handle options\n    const align = options.align || 'left';\n    let wordSpacing = options.wordSpacing || 0;\n    const characterSpacing = options.characterSpacing || 0;\n\n    // text alignments\n    if (options.width) {\n      switch (align) {\n        case 'right':\n          textWidth = this.widthOfString(text.replace(/\\s+$/, ''), options);\n          x += options.lineWidth - textWidth;\n          break;\n        case 'center':\n          x += options.lineWidth / 2 - options.textWidth / 2;\n          break;\n        case 'justify':\n          // calculate the word spacing value\n          words = text.trim().split(/\\s+/);\n          textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n          var spaceWidth = this.widthOfString(' ') + characterSpacing;\n          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          break;\n      }\n    }\n\n    // text baseline alignments based on http://wiki.apache.org/xmlgraphics-fop/LineLayout/AlignmentHandling\n    if (typeof options.baseline === 'number') {\n      dy = -options.baseline;\n    } else {\n      switch (options.baseline) {\n        case 'svg-middle':\n          dy = 0.5 * this._font.xHeight;\n          break;\n        case 'middle':\n        case 'svg-central':\n          dy = 0.5 * (this._font.descender + this._font.ascender);\n          break;\n        case 'bottom':\n        case 'ideographic':\n          dy = this._font.descender;\n          break;\n        case 'alphabetic':\n          dy = 0;\n          break;\n        case 'mathematical':\n          dy = 0.5 * this._font.ascender;\n          break;\n        case 'hanging':\n          dy = 0.8 * this._font.ascender;\n          break;\n        case 'top':\n          dy = this._font.ascender;\n          break;\n        default:\n          dy = this._font.ascender;\n      }\n      dy = dy / 1000 * this._fontSize;\n    }\n\n    // calculate the actual rendered width of the string after word and character spacing\n    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);\n\n    // create link annotations if the link option is given\n    if (options.link != null) {\n      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n\n    // create underline\n    if (options.underline) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() - lineWidth;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n\n    // create strikethrough line\n    if (options.strike) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() / 2;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n    this.save();\n\n    // oblique (angle in degrees or boolean)\n    if (options.oblique) {\n      let skew;\n      if (typeof options.oblique === 'number') {\n        skew = -Math.tan(options.oblique * Math.PI / 180);\n      } else {\n        skew = -0.25;\n      }\n      this.transform(1, 0, 0, 1, x, y);\n      this.transform(1, 0, skew, 1, -skew * dy, 0);\n      this.transform(1, 0, 0, 1, -x, -y);\n    }\n\n    // flip coordinate system\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    y = this.page.height - y - dy;\n\n    // add current font to page if necessary\n    if (this.page.fonts[this._font.id] == null) {\n      this.page.fonts[this._font.id] = this._font.ref();\n    }\n\n    // begin the text object\n    this.addContent('BT');\n\n    // text position\n    this.addContent(`1 0 0 1 ${number$2(x)} ${number$2(y)} Tm`);\n\n    // font and font size\n    this.addContent(`/${this._font.id} ${number$2(this._fontSize)} Tf`);\n\n    // rendering mode\n    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;\n    if (mode) {\n      this.addContent(`${mode} Tr`);\n    }\n\n    // Character spacing\n    if (characterSpacing) {\n      this.addContent(`${number$2(characterSpacing)} Tc`);\n    }\n\n    // Add the actual text\n    // If we have a word spacing value, we need to encode each word separately\n    // since the normal Tw operator only works on character code 32, which isn't\n    // used for embedded fonts.\n    if (wordSpacing) {\n      words = text.trim().split(/\\s+/);\n      wordSpacing += this.widthOfString(' ') + characterSpacing;\n      wordSpacing *= 1000 / this._fontSize;\n      encoded = [];\n      positions = [];\n      for (let word of words) {\n        const [encodedWord, positionsWord] = this._font.encode(word, options.features);\n        encoded = encoded.concat(encodedWord);\n        positions = positions.concat(positionsWord);\n\n        // add the word spacing to the end of the word\n        // clone object because of cache\n        const space = {};\n        const object = positions[positions.length - 1];\n        for (let key in object) {\n          const val = object[key];\n          space[key] = val;\n        }\n        space.xAdvance += wordSpacing;\n        positions[positions.length - 1] = space;\n      }\n    } else {\n      [encoded, positions] = this._font.encode(text, options.features);\n    }\n    const scale = this._fontSize / 1000;\n    const commands = [];\n    let last = 0;\n    let hadOffset = false;\n\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = cur => {\n      if (last < cur) {\n        const hex = encoded.slice(last, cur).join('');\n        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n        commands.push(`<${hex}> ${number$2(-advance)}`);\n      }\n      return last = cur;\n    };\n\n    // Flushes the current TJ commands to the output stream\n    const flush = i => {\n      addSegment(i);\n      if (commands.length > 0) {\n        this.addContent(`[${commands.join(' ')}] TJ`);\n        return commands.length = 0;\n      }\n    };\n    for (i = 0; i < positions.length; i++) {\n      // If we have an x or y offset, we have to break out of the current TJ command\n      // so we can move the text position.\n      const pos = positions[i];\n      if (pos.xOffset || pos.yOffset) {\n        // Flush the current buffer\n        flush(i);\n\n        // Move the text position and flush just the current character\n        this.addContent(`1 0 0 1 ${number$2(x + pos.xOffset * scale)} ${number$2(y + pos.yOffset * scale)} Tm`);\n        flush(i + 1);\n        hadOffset = true;\n      } else {\n        // If the last character had an offset, reset the text position\n        if (hadOffset) {\n          this.addContent(`1 0 0 1 ${number$2(x)} ${number$2(y)} Tm`);\n          hadOffset = false;\n        }\n\n        // Group segments that don't have any advance adjustments\n        if (pos.xAdvance - pos.advanceWidth !== 0) {\n          addSegment(i + 1);\n        }\n      }\n      x += pos.xAdvance * scale;\n    }\n\n    // Flush any remaining commands\n    flush(i);\n\n    // end the text object\n    this.addContent('ET');\n\n    // restore flipped coordinate system\n    return this.restore();\n  }\n};\n\nconst MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\nconst COLOR_SPACE_MAP = {\n  1: 'DeviceGray',\n  3: 'DeviceRGB',\n  4: 'DeviceCMYK'\n};\nclass JPEG {\n  constructor(data, label) {\n    let marker;\n    this.data = data;\n    this.label = label;\n    if (this.data.readUInt16BE(0) !== 0xffd8) {\n      throw 'SOI not found in JPEG';\n    }\n\n    // Parse the EXIF orientation\n    this.orientation = jpeg_exif__WEBPACK_IMPORTED_MODULE_7__.fromBuffer(this.data).Orientation || 1;\n    let pos = 2;\n    while (pos < this.data.length) {\n      marker = this.data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += this.data.readUInt16BE(pos);\n    }\n    if (!MARKERS.includes(marker)) {\n      throw 'Invalid JPEG.';\n    }\n    pos += 2;\n    this.bits = this.data[pos++];\n    this.height = this.data.readUInt16BE(pos);\n    pos += 2;\n    this.width = this.data.readUInt16BE(pos);\n    pos += 2;\n    const channels = this.data[pos++];\n    this.colorSpace = COLOR_SPACE_MAP[channels];\n    this.obj = null;\n  }\n  embed(document) {\n    if (this.obj) {\n      return;\n    }\n    this.obj = document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: this.bits,\n      Width: this.width,\n      Height: this.height,\n      ColorSpace: this.colorSpace,\n      Filter: 'DCTDecode'\n    });\n\n    // add extra decode params for CMYK images. By swapping the\n    // min and max values from the default, we invert the colors. See\n    // section 4.8.4 of the spec.\n    if (this.colorSpace === 'DeviceCMYK') {\n      this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\n    }\n    this.obj.end(this.data);\n\n    // free memory\n    return this.data = null;\n  }\n}\n\nclass PNGImage {\n  constructor(data, label) {\n    this.label = label;\n    this.image = new (png_js__WEBPACK_IMPORTED_MODULE_8___default())(data);\n    this.width = this.image.width;\n    this.height = this.image.height;\n    this.imgData = this.image.imgData;\n    this.obj = null;\n  }\n  embed(document) {\n    let dataDecoded = false;\n    this.document = document;\n    if (this.obj) {\n      return;\n    }\n    const hasAlphaChannel = this.image.hasAlphaChannel;\n    const isInterlaced = this.image.interlaceMethod === 1;\n    this.obj = this.document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,\n      Width: this.width,\n      Height: this.height,\n      Filter: 'FlateDecode'\n    });\n    if (!hasAlphaChannel) {\n      const params = this.document.ref({\n        Predictor: isInterlaced ? 1 : 15,\n        Colors: this.image.colors,\n        BitsPerComponent: this.image.bits,\n        Columns: this.width\n      });\n      this.obj.data['DecodeParms'] = params;\n      params.end();\n    }\n    if (this.image.palette.length === 0) {\n      this.obj.data['ColorSpace'] = this.image.colorSpace;\n    } else {\n      // embed the color palette in the PDF as an object stream\n      const palette = this.document.ref();\n      palette.end(Buffer.from(this.image.palette));\n\n      // build the color space array for the image\n      this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', this.image.palette.length / 3 - 1, palette];\n    }\n\n    // For PNG color types 0, 2 and 3, the transparency data is stored in\n    // a dedicated PNG chunk.\n    if (this.image.transparency.grayscale != null) {\n      // Use Color Key Masking (spec section 4.8.5)\n      // An array with N elements, where N is two times the number of color components.\n      const val = this.image.transparency.grayscale;\n      this.obj.data['Mask'] = [val, val];\n    } else if (this.image.transparency.rgb) {\n      // Use Color Key Masking (spec section 4.8.5)\n      // An array with N elements, where N is two times the number of color components.\n      const {\n        rgb\n      } = this.image.transparency;\n      const mask = [];\n      for (let x of rgb) {\n        mask.push(x, x);\n      }\n      this.obj.data['Mask'] = mask;\n    } else if (this.image.transparency.indexed) {\n      // Create a transparency SMask for the image based on the data\n      // in the PLTE and tRNS sections. See below for details on SMasks.\n      dataDecoded = true;\n      return this.loadIndexedAlphaChannel();\n    } else if (hasAlphaChannel) {\n      // For PNG color types 4 and 6, the transparency data is stored as a alpha\n      // channel mixed in with the main image data. Separate this data out into an\n      // SMask object and store it separately in the PDF.\n      dataDecoded = true;\n      return this.splitAlphaChannel();\n    }\n    if (isInterlaced && !dataDecoded) {\n      return this.decodeData();\n    }\n    this.finalize();\n  }\n  finalize() {\n    if (this.alphaChannel) {\n      const sMask = this.document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        Height: this.height,\n        Width: this.width,\n        BitsPerComponent: 8,\n        Filter: 'FlateDecode',\n        ColorSpace: 'DeviceGray',\n        Decode: [0, 1]\n      });\n      sMask.end(this.alphaChannel);\n      this.obj.data['SMask'] = sMask;\n    }\n\n    // add the actual image data\n    this.obj.end(this.imgData);\n\n    // free memory\n    this.image = null;\n    return this.imgData = null;\n  }\n  splitAlphaChannel() {\n    return this.image.decodePixels(pixels => {\n      let a, p;\n      const colorCount = this.image.colors;\n      const pixelCount = this.width * this.height;\n      const imgData = Buffer.alloc(pixelCount * colorCount);\n      const alphaChannel = Buffer.alloc(pixelCount);\n      let i = p = a = 0;\n      const len = pixels.length;\n      // For 16bit images copy only most significant byte (MSB) - PNG data is always stored in network byte order (MSB first)\n      const skipByteCount = this.image.bits === 16 ? 1 : 0;\n      while (i < len) {\n        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {\n          imgData[p++] = pixels[i++];\n          i += skipByteCount;\n        }\n        alphaChannel[a++] = pixels[i++];\n        i += skipByteCount;\n      }\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(imgData);\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  loadIndexedAlphaChannel() {\n    const transparency = this.image.transparency.indexed;\n    return this.image.decodePixels(pixels => {\n      const alphaChannel = Buffer.alloc(this.width * this.height);\n      let i = 0;\n      for (let j = 0, end = pixels.length; j < end; j++) {\n        alphaChannel[i++] = transparency[pixels[j]];\n      }\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  decodeData() {\n    this.image.decodePixels(pixels => {\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(pixels);\n      this.finalize();\n    });\n  }\n}\n\n/*\r\nPDFImage - embeds images in PDF documents\r\nBy Devon Govett\r\n*/\nclass PDFImage {\n  static open(src, label) {\n    let data;\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      let match;\n      if (match = /^data:.+?;base64,(.*)$/.exec(src)) {\n        data = Buffer.from(match[1], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          return;\n        }\n      }\n    }\n    if (data[0] === 0xff && data[1] === 0xd8) {\n      return new JPEG(data, label);\n    } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {\n      return new PNGImage(data, label);\n    } else {\n      throw new Error('Unknown image format.');\n    }\n  }\n}\n\nvar ImagesMixin = {\n  initImages() {\n    this._imageRegistry = {};\n    return this._imageCount = 0;\n  },\n  image(src, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let bh, bp, bw, image, ip, left, left1, rotateAngle, originX, originY;\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n\n    // Ignore orientation based on document options or image options\n    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;\n    x = (left = x != null ? x : options.x) != null ? left : this.x;\n    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      if (src.width && src.height) {\n        image = src;\n      } else {\n        image = this.openImage(src);\n      }\n    }\n    if (!image.obj) {\n      image.embed(this);\n    }\n    if (this.page.xobjects[image.label] == null) {\n      this.page.xobjects[image.label] = image.obj;\n    }\n    let {\n      width,\n      height\n    } = image;\n\n    // If EXIF orientation calls for it, swap width and height\n    if (!ignoreOrientation && image.orientation > 4) {\n      [width, height] = [height, width];\n    }\n    let w = options.width || width;\n    let h = options.height || height;\n    if (options.width && !options.height) {\n      const wp = w / width;\n      w = width * wp;\n      h = height * wp;\n    } else if (options.height && !options.width) {\n      const hp = h / height;\n      w = width * hp;\n      h = height * hp;\n    } else if (options.scale) {\n      w = width * options.scale;\n      h = height * options.scale;\n    } else if (options.fit) {\n      [bw, bh] = options.fit;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        w = bw;\n        h = bw / ip;\n      } else {\n        h = bh;\n        w = bh * ip;\n      }\n    } else if (options.cover) {\n      [bw, bh] = options.cover;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        h = bh;\n        w = bh * ip;\n      } else {\n        w = bw;\n        h = bw / ip;\n      }\n    }\n    if (options.fit || options.cover) {\n      if (options.align === 'center') {\n        x = x + bw / 2 - w / 2;\n      } else if (options.align === 'right') {\n        x = x + bw - w;\n      }\n      if (options.valign === 'center') {\n        y = y + bh / 2 - h / 2;\n      } else if (options.valign === 'bottom') {\n        y = y + bh - h;\n      }\n    }\n    if (!ignoreOrientation) {\n      switch (image.orientation) {\n        // No orientation (need to flip image, though, because of the default transform matrix on the document)\n        default:\n        case 1:\n          h = -h;\n          y -= h;\n          rotateAngle = 0;\n          break;\n        // Flip Horizontal\n        case 2:\n          w = -w;\n          h = -h;\n          x -= w;\n          y -= h;\n          rotateAngle = 0;\n          break;\n        // Rotate 180 degrees\n        case 3:\n          originX = x;\n          originY = y;\n          h = -h;\n          x -= w;\n          rotateAngle = 180;\n          break;\n        // Flip vertical\n        case 4:\n          // Do nothing, image will be flipped\n\n          break;\n        // Flip horizontally and rotate 270 degrees CW\n        case 5:\n          originX = x;\n          originY = y;\n          [w, h] = [h, w];\n          y -= h;\n          rotateAngle = 90;\n          break;\n        // Rotate 90 degrees CW\n        case 6:\n          originX = x;\n          originY = y;\n          [w, h] = [h, w];\n          h = -h;\n          rotateAngle = 90;\n          break;\n        // Flip horizontally and rotate 90 degrees CW\n        case 7:\n          originX = x;\n          originY = y;\n          [w, h] = [h, w];\n          h = -h;\n          w = -w;\n          x -= w;\n          rotateAngle = 90;\n          break;\n        // Rotate 270 degrees CW\n        case 8:\n          originX = x;\n          originY = y;\n          [w, h] = [h, w];\n          h = -h;\n          x -= w;\n          y -= h;\n          rotateAngle = -90;\n          break;\n      }\n    } else {\n      h = -h;\n      y -= h;\n      rotateAngle = 0;\n    }\n\n    // create link annotations if the link option is given\n    if (options.link != null) {\n      this.link(x, y, w, h, options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, w, h, options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n\n    // Set the current y position to below the image if it is in the document flow\n    if (this.y === y) {\n      this.y += h;\n    }\n    this.save();\n    if (rotateAngle) {\n      this.rotate(rotateAngle, {\n        origin: [originX, originY]\n      });\n    }\n    this.transform(w, 0, 0, h, x, y);\n    this.addContent(`/${image.label} Do`);\n    this.restore();\n    return this;\n  },\n  openImage(src) {\n    let image;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      image = PDFImage.open(src, `I${++this._imageCount}`);\n      if (typeof src === 'string') {\n        this._imageRegistry[src] = image;\n      }\n    }\n    return image;\n  }\n};\n\nvar AnnotationsMixin = {\n  annotate(x, y, w, h, options) {\n    options.Type = 'Annot';\n    options.Rect = this._convertRect(x, y, w, h);\n    options.Border = [0, 0, 0];\n    if (options.Subtype === 'Link' && typeof options.F === 'undefined') {\n      options.F = 1 << 2; // Print Annotation Flag\n    }\n    if (options.Subtype !== 'Link') {\n      if (options.C == null) {\n        options.C = this._normalizeColor(options.color || [0, 0, 0]);\n      }\n    } // convert colors\n    delete options.color;\n    if (typeof options.Dest === 'string') {\n      options.Dest = new String(options.Dest);\n    }\n\n    // Capitalize keys\n    for (let key in options) {\n      const val = options[key];\n      options[key[0].toUpperCase() + key.slice(1)] = val;\n    }\n    const ref = this.ref(options);\n    this.page.annotations.push(ref);\n    ref.end();\n    return this;\n  },\n  note(x, y, w, h, contents) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Text';\n    options.Contents = new String(contents);\n    options.Name = 'Comment';\n    if (options.color == null) {\n      options.color = [243, 223, 92];\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  goTo(x, y, w, h, name) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    options.A = this.ref({\n      S: 'GoTo',\n      D: new String(name)\n    });\n    options.A.end();\n    return this.annotate(x, y, w, h, options);\n  },\n  link(x, y, w, h, url) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    if (typeof url === 'number') {\n      // Link to a page in the document (the page must already exist)\n      const pages = this._root.data.Pages.data;\n      if (url >= 0 && url < pages.Kids.length) {\n        options.A = this.ref({\n          S: 'GoTo',\n          D: [pages.Kids[url], 'XYZ', null, null, null]\n        });\n        options.A.end();\n      } else {\n        throw new Error(`The document has no page ${url}`);\n      }\n    } else {\n      // Link to an external url\n      options.A = this.ref({\n        S: 'URI',\n        URI: new String(url)\n      });\n      options.A.end();\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _markup(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const [x1, y1, x2, y2] = this._convertRect(x, y, w, h);\n    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  highlight(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Highlight';\n    if (options.color == null) {\n      options.color = [241, 238, 148];\n    }\n    return this._markup(x, y, w, h, options);\n  },\n  underline(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Underline';\n    return this._markup(x, y, w, h, options);\n  },\n  strike(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'StrikeOut';\n    return this._markup(x, y, w, h, options);\n  },\n  lineAnnotation(x1, y1, x2, y2) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Line';\n    options.Contents = new String();\n    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];\n    return this.annotate(x1, y1, x2, y2, options);\n  },\n  rectAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Square';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  ellipseAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Circle';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  textAnnotation(x, y, w, h, text) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'FreeText';\n    options.Contents = new String(text);\n    options.DA = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  fileAnnotation(x, y, w, h) {\n    let file = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    // create hidden file\n    const filespec = this.file(file.src, Object.assign({\n      hidden: true\n    }, file));\n    options.Subtype = 'FileAttachment';\n    options.FS = filespec;\n\n    // add description from filespec unless description (Contents) has already been set\n    if (options.Contents) {\n      options.Contents = new String(options.Contents);\n    } else if (filespec.data.Desc) {\n      options.Contents = filespec.data.Desc;\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _convertRect(x1, y1, w, h) {\n    // flip y1 and y2\n    let y2 = y1;\n    y1 += h;\n\n    // make x2\n    let x2 = x1 + w;\n\n    // apply current transformation matrix to points\n    const [m0, m1, m2, m3, m4, m5] = this._ctm;\n    x1 = m0 * x1 + m2 * y1 + m4;\n    y1 = m1 * x1 + m3 * y1 + m5;\n    x2 = m0 * x2 + m2 * y2 + m4;\n    y2 = m1 * x2 + m3 * y2 + m5;\n    return [x1, y1, x2, y2];\n  }\n};\n\nclass PDFOutline {\n  constructor(document, parent, title, dest) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      expanded: false\n    };\n    this.document = document;\n    this.options = options;\n    this.outlineData = {};\n    if (dest !== null) {\n      this.outlineData['Dest'] = [dest.dictionary, 'Fit'];\n    }\n    if (parent !== null) {\n      this.outlineData['Parent'] = parent;\n    }\n    if (title !== null) {\n      this.outlineData['Title'] = new String(title);\n    }\n    this.dictionary = this.document.ref(this.outlineData);\n    this.children = [];\n  }\n  addItem(title) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      expanded: false\n    };\n    const result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);\n    this.children.push(result);\n    return result;\n  }\n  endOutline() {\n    if (this.children.length > 0) {\n      if (this.options.expanded) {\n        this.outlineData.Count = this.children.length;\n      }\n      const first = this.children[0],\n        last = this.children[this.children.length - 1];\n      this.outlineData.First = first.dictionary;\n      this.outlineData.Last = last.dictionary;\n      for (let i = 0, len = this.children.length; i < len; i++) {\n        const child = this.children[i];\n        if (i > 0) {\n          child.outlineData.Prev = this.children[i - 1].dictionary;\n        }\n        if (i < this.children.length - 1) {\n          child.outlineData.Next = this.children[i + 1].dictionary;\n        }\n        child.endOutline();\n      }\n    }\n    return this.dictionary.end();\n  }\n}\n\nvar OutlineMixin = {\n  initOutline() {\n    return this.outline = new PDFOutline(this, null, null, null);\n  },\n  endOutline() {\n    this.outline.endOutline();\n    if (this.outline.children.length > 0) {\n      this._root.data.Outlines = this.outline.dictionary;\n      return this._root.data.PageMode = 'UseOutlines';\n    }\n  }\n};\n\n/*\r\nPDFStructureContent - a reference to a marked structure content\r\nBy Ben Schmidt\r\n*/\n\nclass PDFStructureContent {\n  constructor(pageRef, mcid) {\n    this.refs = [{\n      pageRef,\n      mcid\n    }];\n  }\n  push(structContent) {\n    structContent.refs.forEach(ref => this.refs.push(ref));\n  }\n}\n\n/*\r\nPDFStructureElement - represents an element in the PDF logical structure tree\r\nBy Ben Schmidt\r\n*/\nclass PDFStructureElement {\n  constructor(document, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.document = document;\n    this._attached = false;\n    this._ended = false;\n    this._flushed = false;\n    this.dictionary = document.ref({\n      // Type: \"StructElem\",\n      S: type\n    });\n    const data = this.dictionary.data;\n    if (Array.isArray(options) || this._isValidChild(options)) {\n      children = options;\n      options = {};\n    }\n    if (typeof options.title !== 'undefined') {\n      data.T = new String(options.title);\n    }\n    if (typeof options.lang !== 'undefined') {\n      data.Lang = new String(options.lang);\n    }\n    if (typeof options.alt !== 'undefined') {\n      data.Alt = new String(options.alt);\n    }\n    if (typeof options.expanded !== 'undefined') {\n      data.E = new String(options.expanded);\n    }\n    if (typeof options.actual !== 'undefined') {\n      data.ActualText = new String(options.actual);\n    }\n    this._children = [];\n    if (children) {\n      if (!Array.isArray(children)) {\n        children = [children];\n      }\n      children.forEach(child => this.add(child));\n      this.end();\n    }\n  }\n  add(child) {\n    if (this._ended) {\n      throw new Error(`Cannot add child to already-ended structure element`);\n    }\n    if (!this._isValidChild(child)) {\n      throw new Error(`Invalid structure element child`);\n    }\n    if (child instanceof PDFStructureElement) {\n      child.setParent(this.dictionary);\n      if (this._attached) {\n        child.setAttached();\n      }\n    }\n    if (child instanceof PDFStructureContent) {\n      this._addContentToParentTree(child);\n    }\n    if (typeof child === 'function' && this._attached) {\n      // _contentForClosure() adds the content to the parent tree\n      child = this._contentForClosure(child);\n    }\n    this._children.push(child);\n    return this;\n  }\n  _addContentToParentTree(content) {\n    content.refs.forEach(_ref => {\n      let {\n        pageRef,\n        mcid\n      } = _ref;\n      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);\n      pageStructParents[mcid] = this.dictionary;\n    });\n  }\n  setParent(parentRef) {\n    if (this.dictionary.data.P) {\n      throw new Error(`Structure element added to more than one parent`);\n    }\n    this.dictionary.data.P = parentRef;\n    this._flush();\n  }\n  setAttached() {\n    if (this._attached) {\n      return;\n    }\n    this._children.forEach((child, index) => {\n      if (child instanceof PDFStructureElement) {\n        child.setAttached();\n      }\n      if (typeof child === 'function') {\n        this._children[index] = this._contentForClosure(child);\n      }\n    });\n    this._attached = true;\n    this._flush();\n  }\n  end() {\n    if (this._ended) {\n      return;\n    }\n    this._children.filter(child => child instanceof PDFStructureElement).forEach(child => child.end());\n    this._ended = true;\n    this._flush();\n  }\n  _isValidChild(child) {\n    return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === 'function';\n  }\n  _contentForClosure(closure) {\n    const content = this.document.markStructureContent(this.dictionary.data.S);\n    closure();\n    this.document.endMarkedContent();\n    this._addContentToParentTree(content);\n    return content;\n  }\n  _isFlushable() {\n    if (!this.dictionary.data.P || !this._ended) {\n      return false;\n    }\n    return this._children.every(child => {\n      if (typeof child === 'function') {\n        return false;\n      }\n      if (child instanceof PDFStructureElement) {\n        return child._isFlushable();\n      }\n      return true;\n    });\n  }\n  _flush() {\n    if (this._flushed || !this._isFlushable()) {\n      return;\n    }\n    this.dictionary.data.K = [];\n    this._children.forEach(child => this._flushChild(child));\n    this.dictionary.end();\n\n    // free memory used by children; the dictionary itself may still be\n    // referenced by a parent structure element or root, but we can\n    // at least trim the tree here\n    this._children = [];\n    this.dictionary.data.K = null;\n    this._flushed = true;\n  }\n  _flushChild(child) {\n    if (child instanceof PDFStructureElement) {\n      this.dictionary.data.K.push(child.dictionary);\n    }\n    if (child instanceof PDFStructureContent) {\n      child.refs.forEach(_ref2 => {\n        let {\n          pageRef,\n          mcid\n        } = _ref2;\n        if (!this.dictionary.data.Pg) {\n          this.dictionary.data.Pg = pageRef;\n        }\n        if (this.dictionary.data.Pg === pageRef) {\n          this.dictionary.data.K.push(mcid);\n        } else {\n          this.dictionary.data.K.push({\n            Type: \"MCR\",\n            Pg: pageRef,\n            MCID: mcid\n          });\n        }\n      });\n    }\n  }\n}\n\n/*\r\nPDFNumberTree - represents a number tree object\r\n*/\nclass PDFNumberTree extends PDFTree {\n  _compareKeys(a, b) {\n    return parseInt(a) - parseInt(b);\n  }\n  _keysName() {\n    return \"Nums\";\n  }\n  _dataForKey(k) {\n    return parseInt(k);\n  }\n}\n\n/*\r\nMarkings mixin - support marked content sequences in content streams\r\nBy Ben Schmidt\r\n*/\nvar MarkingsMixin = {\n  initMarkings(options) {\n    this.structChildren = [];\n    if (options.tagged) {\n      this.getMarkInfoDictionary().data.Marked = true;\n      this.getStructTreeRoot();\n    }\n  },\n  markContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (tag === 'Artifact' || options && options.mcid) {\n      let toClose = 0;\n      this.page.markings.forEach(marking => {\n        if (toClose || marking.structContent || marking.tag === 'Artifact') {\n          toClose++;\n        }\n      });\n      while (toClose--) {\n        this.endMarkedContent();\n      }\n    }\n    if (!options) {\n      this.page.markings.push({\n        tag\n      });\n      this.addContent(`/${tag} BMC`);\n      return this;\n    }\n    this.page.markings.push({\n      tag,\n      options\n    });\n    const dictionary = {};\n    if (typeof options.mcid !== 'undefined') {\n      dictionary.MCID = options.mcid;\n    }\n    if (tag === 'Artifact') {\n      if (typeof options.type === 'string') {\n        dictionary.Type = options.type;\n      }\n      if (Array.isArray(options.bbox)) {\n        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];\n      }\n      if (Array.isArray(options.attached) && options.attached.every(val => typeof val === 'string')) {\n        dictionary.Attached = options.attached;\n      }\n    }\n    if (tag === 'Span') {\n      if (options.lang) {\n        dictionary.Lang = new String(options.lang);\n      }\n      if (options.alt) {\n        dictionary.Alt = new String(options.alt);\n      }\n      if (options.expanded) {\n        dictionary.E = new String(options.expanded);\n      }\n      if (options.actual) {\n        dictionary.ActualText = new String(options.actual);\n      }\n    }\n    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);\n    return this;\n  },\n  markStructureContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);\n    const mcid = pageStructParents.length;\n    pageStructParents.push(null);\n    this.markContent(tag, {\n      ...options,\n      mcid\n    });\n    const structContent = new PDFStructureContent(this.page.dictionary, mcid);\n    this.page.markings.slice(-1)[0].structContent = structContent;\n    return structContent;\n  },\n  endMarkedContent() {\n    this.page.markings.pop();\n    this.addContent('EMC');\n    return this;\n  },\n  struct(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return new PDFStructureElement(this, type, options, children);\n  },\n  addStructure(structElem) {\n    const structTreeRoot = this.getStructTreeRoot();\n    structElem.setParent(structTreeRoot);\n    structElem.setAttached();\n    this.structChildren.push(structElem);\n    if (!structTreeRoot.data.K) {\n      structTreeRoot.data.K = [];\n    }\n    structTreeRoot.data.K.push(structElem.dictionary);\n    return this;\n  },\n  initPageMarkings(pageMarkings) {\n    pageMarkings.forEach(marking => {\n      if (marking.structContent) {\n        const structContent = marking.structContent;\n        const newStructContent = this.markStructureContent(marking.tag, marking.options);\n        structContent.push(newStructContent);\n        this.page.markings.slice(-1)[0].structContent = structContent;\n      } else {\n        this.markContent(marking.tag, marking.options);\n      }\n    });\n  },\n  endPageMarkings(page) {\n    const pageMarkings = page.markings;\n    pageMarkings.forEach(() => page.write('EMC'));\n    page.markings = [];\n    return pageMarkings;\n  },\n  getMarkInfoDictionary() {\n    if (!this._root.data.MarkInfo) {\n      this._root.data.MarkInfo = this.ref({});\n    }\n    return this._root.data.MarkInfo;\n  },\n  getStructTreeRoot() {\n    if (!this._root.data.StructTreeRoot) {\n      this._root.data.StructTreeRoot = this.ref({\n        Type: 'StructTreeRoot',\n        ParentTree: new PDFNumberTree(),\n        ParentTreeNextKey: 0\n      });\n    }\n    return this._root.data.StructTreeRoot;\n  },\n  getStructParentTree() {\n    return this.getStructTreeRoot().data.ParentTree;\n  },\n  createStructParentTreeNextKey() {\n    // initialise the MarkInfo dictionary\n    this.getMarkInfoDictionary();\n    const structTreeRoot = this.getStructTreeRoot();\n    const key = structTreeRoot.data.ParentTreeNextKey++;\n    structTreeRoot.data.ParentTree.add(key, []);\n    return key;\n  },\n  endMarkings() {\n    const structTreeRoot = this._root.data.StructTreeRoot;\n    if (structTreeRoot) {\n      structTreeRoot.end();\n      this.structChildren.forEach(structElem => structElem.end());\n    }\n    if (this._root.data.MarkInfo) {\n      this._root.data.MarkInfo.end();\n    }\n  }\n};\n\nconst FIELD_FLAGS = {\n  readOnly: 1,\n  required: 2,\n  noExport: 4,\n  multiline: 0x1000,\n  password: 0x2000,\n  toggleToOffButton: 0x4000,\n  radioButton: 0x8000,\n  pushButton: 0x10000,\n  combo: 0x20000,\n  edit: 0x40000,\n  sort: 0x80000,\n  multiSelect: 0x200000,\n  noSpell: 0x400000\n};\nconst FIELD_JUSTIFY = {\n  left: 0,\n  center: 1,\n  right: 2\n};\nconst VALUE_MAP = {\n  value: 'V',\n  defaultValue: 'DV'\n};\nconst FORMAT_SPECIAL = {\n  zip: '0',\n  zipPlus4: '1',\n  zip4: '1',\n  phone: '2',\n  ssn: '3'\n};\nconst FORMAT_DEFAULT = {\n  number: {\n    nDec: 0,\n    sepComma: false,\n    negStyle: 'MinusBlack',\n    currency: '',\n    currencyPrepend: true\n  },\n  percent: {\n    nDec: 0,\n    sepComma: false\n  }\n};\nvar AcroFormMixin = {\n  /**\r\n   * Must call if adding AcroForms to a document. Must also call font() before\r\n   * this method to set the default font.\r\n   */\n  initForm() {\n    if (!this._font) {\n      throw new Error('Must set a font before calling initForm method');\n    }\n    this._acroform = {\n      fonts: {},\n      defaultFont: this._font.name\n    };\n    this._acroform.fonts[this._font.id] = this._font.ref();\n    let data = {\n      Fields: [],\n      NeedAppearances: true,\n      DA: new String(`/${this._font.id} 0 Tf 0 g`),\n      DR: {\n        Font: {}\n      }\n    };\n    data.DR.Font[this._font.id] = this._font.ref();\n    const AcroForm = this.ref(data);\n    this._root.data.AcroForm = AcroForm;\n    return this;\n  },\n  /**\r\n   * Called automatically by document.js\r\n   */\n  endAcroForm() {\n    if (this._root.data.AcroForm) {\n      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {\n        throw new Error('No fonts specified for PDF form');\n      }\n      let fontDict = this._root.data.AcroForm.data.DR.Font;\n      Object.keys(this._acroform.fonts).forEach(name => {\n        fontDict[name] = this._acroform.fonts[name];\n      });\n      this._root.data.AcroForm.data.Fields.forEach(fieldRef => {\n        this._endChild(fieldRef);\n      });\n      this._root.data.AcroForm.end();\n    }\n    return this;\n  },\n  _endChild(ref) {\n    if (Array.isArray(ref.data.Kids)) {\n      ref.data.Kids.forEach(childRef => {\n        this._endChild(childRef);\n      });\n      ref.end();\n    }\n    return this;\n  },\n  /**\r\n   * Creates and adds a form field to the document. Form fields are intermediate\r\n   * nodes in a PDF form that are used to specify form name heirarchy and form\r\n   * value defaults.\r\n   * @param {string} name - field name (T attribute in field dictionary)\r\n   * @param {object} options  - other attributes to include in field dictionary\r\n   */\n  formField(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fieldDict = this._fieldDict(name, null, options);\n    let fieldRef = this.ref(fieldDict);\n    this._addToParent(fieldRef);\n    return fieldRef;\n  },\n  /**\r\n   * Creates and adds a Form Annotation to the document. Form annotations are\r\n   * called Widget annotations internally within a PDF file.\r\n   * @param {string} name - form field name (T attribute of widget annotation\r\n   * dictionary)\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} w\r\n   * @param {number} h\r\n   * @param {object} options\r\n   */\n  formAnnotation(name, type, x, y, w, h) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    let fieldDict = this._fieldDict(name, type, options);\n    fieldDict.Subtype = 'Widget';\n    if (fieldDict.F === undefined) {\n      fieldDict.F = 4; // print the annotation\n    }\n\n    // Add Field annot to page, and get it's ref\n    this.annotate(x, y, w, h, fieldDict);\n    let annotRef = this.page.annotations[this.page.annotations.length - 1];\n    return this._addToParent(annotRef);\n  },\n  formText(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'text', x, y, w, h, options);\n  },\n  formPushButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'pushButton', x, y, w, h, options);\n  },\n  formCombo(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'combo', x, y, w, h, options);\n  },\n  formList(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'list', x, y, w, h, options);\n  },\n  formRadioButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'radioButton', x, y, w, h, options);\n  },\n  formCheckbox(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'checkbox', x, y, w, h, options);\n  },\n  _addToParent(fieldRef) {\n    let parent = fieldRef.data.Parent;\n    if (parent) {\n      if (!parent.data.Kids) {\n        parent.data.Kids = [];\n      }\n      parent.data.Kids.push(fieldRef);\n    } else {\n      this._root.data.AcroForm.data.Fields.push(fieldRef);\n    }\n    return this;\n  },\n  _fieldDict(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!this._acroform) {\n      throw new Error('Call document.initForm() method before adding form elements to document');\n    }\n    let opts = Object.assign({}, options);\n    if (type !== null) {\n      opts = this._resolveType(type, options);\n    }\n    opts = this._resolveFlags(opts);\n    opts = this._resolveJustify(opts);\n    opts = this._resolveFont(opts);\n    opts = this._resolveStrings(opts);\n    opts = this._resolveColors(opts);\n    opts = this._resolveFormat(opts);\n    opts.T = new String(name);\n    if (opts.parent) {\n      opts.Parent = opts.parent;\n      delete opts.parent;\n    }\n    return opts;\n  },\n  _resolveType(type, opts) {\n    if (type === 'text') {\n      opts.FT = 'Tx';\n    } else if (type === 'pushButton') {\n      opts.FT = 'Btn';\n      opts.pushButton = true;\n    } else if (type === 'radioButton') {\n      opts.FT = 'Btn';\n      opts.radioButton = true;\n    } else if (type === 'checkbox') {\n      opts.FT = 'Btn';\n    } else if (type === 'combo') {\n      opts.FT = 'Ch';\n      opts.combo = true;\n    } else if (type === 'list') {\n      opts.FT = 'Ch';\n    } else {\n      throw new Error(`Invalid form annotation type '${type}'`);\n    }\n    return opts;\n  },\n  _resolveFormat(opts) {\n    const f = opts.format;\n    if (f && f.type) {\n      let fnKeystroke;\n      let fnFormat;\n      let params = '';\n      if (FORMAT_SPECIAL[f.type] !== undefined) {\n        fnKeystroke = `AFSpecial_Keystroke`;\n        fnFormat = `AFSpecial_Format`;\n        params = FORMAT_SPECIAL[f.type];\n      } else {\n        let format = f.type.charAt(0).toUpperCase() + f.type.slice(1);\n        fnKeystroke = `AF${format}_Keystroke`;\n        fnFormat = `AF${format}_Format`;\n        if (f.type === 'date') {\n          fnKeystroke += 'Ex';\n          params = String(f.param);\n        } else if (f.type === 'time') {\n          params = String(f.param);\n        } else if (f.type === 'number') {\n          let p = Object.assign({}, FORMAT_DEFAULT.number, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1', '\"' + p.negStyle + '\"', 'null', '\"' + p.currency + '\"', String(p.currencyPrepend)].join(','));\n        } else if (f.type === 'percent') {\n          let p = Object.assign({}, FORMAT_DEFAULT.percent, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1'].join(','));\n        }\n      }\n      opts.AA = opts.AA ? opts.AA : {};\n      opts.AA.K = {\n        S: 'JavaScript',\n        JS: new String(`${fnKeystroke}(${params});`)\n      };\n      opts.AA.F = {\n        S: 'JavaScript',\n        JS: new String(`${fnFormat}(${params});`)\n      };\n    }\n    delete opts.format;\n    return opts;\n  },\n  _resolveColors(opts) {\n    let color = this._normalizeColor(opts.backgroundColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BG = color;\n    }\n    color = this._normalizeColor(opts.borderColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BC = color;\n    }\n    delete opts.backgroundColor;\n    delete opts.borderColor;\n    return opts;\n  },\n  _resolveFlags(options) {\n    let result = 0;\n    Object.keys(options).forEach(key => {\n      if (FIELD_FLAGS[key]) {\n        if (options[key]) {\n          result |= FIELD_FLAGS[key];\n        }\n        delete options[key];\n      }\n    });\n    if (result !== 0) {\n      options.Ff = options.Ff ? options.Ff : 0;\n      options.Ff |= result;\n    }\n    return options;\n  },\n  _resolveJustify(options) {\n    let result = 0;\n    if (options.align !== undefined) {\n      if (typeof FIELD_JUSTIFY[options.align] === 'number') {\n        result = FIELD_JUSTIFY[options.align];\n      }\n      delete options.align;\n    }\n    if (result !== 0) {\n      options.Q = result; // default\n    }\n    return options;\n  },\n  _resolveFont(options) {\n    // add current font to document-level AcroForm dict if necessary\n    if (this._acroform.fonts[this._font.id] == null) {\n      this._acroform.fonts[this._font.id] = this._font.ref();\n    }\n\n    // add current font to field's resource dict (RD) if not the default acroform font\n    if (this._acroform.defaultFont !== this._font.name) {\n      options.DR = {\n        Font: {}\n      };\n\n      // Get the fontSize option. If not set use auto sizing\n      const fontSize = options.fontSize || 0;\n      options.DR.Font[this._font.id] = this._font.ref();\n      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);\n    }\n    return options;\n  },\n  _resolveStrings(options) {\n    let select = [];\n    function appendChoices(a) {\n      if (Array.isArray(a)) {\n        for (let idx = 0; idx < a.length; idx++) {\n          if (typeof a[idx] === 'string') {\n            select.push(new String(a[idx]));\n          } else {\n            select.push(a[idx]);\n          }\n        }\n      }\n    }\n    appendChoices(options.Opt);\n    if (options.select) {\n      appendChoices(options.select);\n      delete options.select;\n    }\n    if (select.length) {\n      options.Opt = select;\n    }\n    Object.keys(VALUE_MAP).forEach(key => {\n      if (options[key] !== undefined) {\n        options[VALUE_MAP[key]] = options[key];\n        delete options[key];\n      }\n    });\n    ['V', 'DV'].forEach(key => {\n      if (typeof options[key] === 'string') {\n        options[key] = new String(options[key]);\n      }\n    });\n    if (options.MK && options.MK.CA) {\n      options.MK.CA = new String(options.MK.CA);\n    }\n    if (options.label) {\n      options.MK = options.MK ? options.MK : {};\n      options.MK.CA = new String(options.label);\n      delete options.label;\n    }\n    return options;\n  }\n};\n\nvar AttachmentsMixin = {\n  /**\r\n   * Embed contents of `src` in PDF\r\n   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file\r\n   * @param {object} options\r\n   *  * options.name: filename to be shown in PDF, will use `src` if none set\r\n   *  * options.type: filetype to be shown in PDF\r\n   *  * options.description: description to be shown in PDF\r\n   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations\r\n   *  * options.creationDate: override creation date\r\n   *  * options.modifiedDate: override modified date\r\n   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.\r\n   * @returns filespec reference\r\n   */\n  file(src) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.name = options.name || src;\n    options.relationship = options.relationship || 'Unspecified';\n    const refBody = {\n      Type: 'EmbeddedFile',\n      Params: {}\n    };\n    let data;\n    if (!src) {\n      throw new Error('No src specified');\n    }\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      let match;\n      if (match = /^data:(.*?);base64,(.*)$/.exec(src)) {\n        if (match[1]) {\n          refBody.Subtype = match[1].replace('/', '#2F');\n        }\n        data = Buffer.from(match[2], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          throw new Error(`Could not read contents of file at filepath ${src}`);\n        }\n\n        // update CreationDate and ModDate\n        const {\n          birthtime,\n          ctime\n        } = fs__WEBPACK_IMPORTED_MODULE_3___default().statSync(src);\n        refBody.Params.CreationDate = birthtime;\n        refBody.Params.ModDate = ctime;\n      }\n    }\n\n    // override creation date and modified date\n    if (options.creationDate instanceof Date) {\n      refBody.Params.CreationDate = options.creationDate;\n    }\n    if (options.modifiedDate instanceof Date) {\n      refBody.Params.ModDate = options.modifiedDate;\n    }\n    // add optional subtype\n    if (options.type) {\n      refBody.Subtype = options.type.replace('/', '#2F');\n    }\n\n    // add checksum and size information\n    const checksum = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(new Uint8Array(data)));\n    refBody.Params.CheckSum = new String(checksum);\n    refBody.Params.Size = data.byteLength;\n\n    // save some space when embedding the same file again\n    // if a file with the same name and metadata exists, reuse its reference\n    let ref;\n    if (!this._fileRegistry) this._fileRegistry = {};\n    let file = this._fileRegistry[options.name];\n    if (file && isEqual(refBody, file)) {\n      ref = file.ref;\n    } else {\n      ref = this.ref(refBody);\n      ref.end(data);\n      this._fileRegistry[options.name] = {\n        ...refBody,\n        ref\n      };\n    }\n    // add filespec for embedded file\n    const fileSpecBody = {\n      Type: 'Filespec',\n      AFRelationship: options.relationship,\n      F: new String(options.name),\n      EF: {\n        F: ref\n      },\n      UF: new String(options.name)\n    };\n    if (options.description) {\n      fileSpecBody.Desc = new String(options.description);\n    }\n    const filespec = this.ref(fileSpecBody);\n    filespec.end();\n    if (!options.hidden) {\n      this.addNamedEmbeddedFile(options.name, filespec);\n    }\n\n    // Add file to the catalogue to be PDF/A3 compliant\n    if (this._root.data.AF) {\n      this._root.data.AF.push(filespec);\n    } else {\n      this._root.data.AF = [filespec];\n    }\n    return filespec;\n  }\n};\n\n/** check two embedded file metadata objects for equality */\nfunction isEqual(a, b) {\n  return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate.getTime() === b.Params.CreationDate.getTime() && (a.Params.ModDate === undefined && b.Params.ModDate === undefined || a.Params.ModDate.getTime() === b.Params.ModDate.getTime());\n}\n\nvar PDFA = {\n  initPDFA(pSubset) {\n    if (pSubset.charAt(pSubset.length - 3) === '-') {\n      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));\n    } else {\n      // Default to Basic conformance when user doesn't specify\n      this.subset_conformance = 'B';\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));\n    }\n  },\n  endSubset() {\n    this._addPdfaMetadata();\n    this._addColorOutputIntent();\n  },\n  _addColorOutputIntent() {\n    const iccProfile = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);\n    const colorProfileRef = this.ref({\n      Length: iccProfile.length,\n      N: 3\n    });\n    colorProfileRef.write(iccProfile);\n    colorProfileRef.end();\n    const intentRef = this.ref({\n      Type: 'OutputIntent',\n      S: 'GTS_PDFA1',\n      Info: new String('sRGB IEC61966-2.1'),\n      OutputConditionIdentifier: new String('sRGB IEC61966-2.1'),\n      DestOutputProfile: colorProfileRef\n    });\n    intentRef.end();\n    this._root.data.OutputIntents = [intentRef];\n  },\n  _getPdfaid() {\n    return `\n        <rdf:Description xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\" rdf:about=\"\">\n            <pdfaid:part>${this.subset}</pdfaid:part>\n            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>\n        </rdf:Description>\n        `;\n  },\n  _addPdfaMetadata() {\n    this.appendXML(this._getPdfaid());\n  }\n};\n\nvar PDFUA = {\n  initPDFUA() {\n    this.subset = 1;\n  },\n  endSubset() {\n    this._addPdfuaMetadata();\n  },\n  _addPdfuaMetadata() {\n    this.appendXML(this._getPdfuaid());\n  },\n  _getPdfuaid() {\n    return `\n        <rdf:Description xmlns:pdfuaid=\"http://www.aiim.org/pdfua/ns/id/\" rdf:about=\"\">\n            <pdfuaid:part>${this.subset}</pdfuaid:part>\n        </rdf:Description>\n        `;\n  }\n};\n\nvar SubsetMixin = {\n  _importSubset(subset) {\n    Object.assign(this, subset);\n  },\n  initSubset(options) {\n    switch (options.subset) {\n      case 'PDF/A-1':\n      case 'PDF/A-1a':\n      case 'PDF/A-1b':\n      case 'PDF/A-2':\n      case 'PDF/A-2a':\n      case 'PDF/A-2b':\n      case 'PDF/A-3':\n      case 'PDF/A-3a':\n      case 'PDF/A-3b':\n        this._importSubset(PDFA);\n        this.initPDFA(options.subset);\n        break;\n      case 'PDF/UA':\n        this._importSubset(PDFUA);\n        this.initPDFUA();\n        break;\n    }\n  }\n};\n\nclass PDFMetadata {\n  constructor() {\n    this._metadata = `\n        <?xpacket begin=\"\\ufeff\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n            <x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n                <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n        `;\n  }\n  _closeTags() {\n    this._metadata = this._metadata.concat(`\n                </rdf:RDF>\n            </x:xmpmeta>\n        <?xpacket end=\"w\"?>\n        `);\n  }\n  append(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._metadata = this._metadata.concat(xml);\n    if (newline) this._metadata = this._metadata.concat('\\n');\n  }\n  getXML() {\n    return this._metadata;\n  }\n  getLength() {\n    return this._metadata.length;\n  }\n  end() {\n    this._closeTags();\n    this._metadata = this._metadata.trim();\n  }\n}\n\nvar MetadataMixin = {\n  initMetadata() {\n    this.metadata = new PDFMetadata();\n  },\n  appendXML(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.metadata.append(xml, newline);\n  },\n  _addInfo() {\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n            <xmp:CreateDate>${this.info.CreationDate.toISOString().split('.')[0] + \"Z\"}</xmp:CreateDate>\n            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>\n        </rdf:Description>\n        `);\n    if (this.info.Title || this.info.Author || this.info.Subject) {\n      this.appendXML(`\n            <rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n            `);\n      if (this.info.Title) {\n        this.appendXML(`\n                <dc:title>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Title}</rdf:li>\n                    </rdf:Alt>\n                </dc:title>\n                `);\n      }\n      if (this.info.Author) {\n        this.appendXML(`\n                <dc:creator>\n                    <rdf:Seq>\n                        <rdf:li>${this.info.Author}</rdf:li>\n                    </rdf:Seq>\n                </dc:creator>\n                `);\n      }\n      if (this.info.Subject) {\n        this.appendXML(`\n                <dc:description>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Subject}</rdf:li>\n                    </rdf:Alt>\n                </dc:description>\n                `);\n      }\n      this.appendXML(`\n            </rdf:Description>\n            `);\n    }\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);\n    if (this.info.Keywords) {\n      this.appendXML(`\n            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);\n    }\n    this.appendXML(`\n        </rdf:Description>\n        `);\n  },\n  endMetadata() {\n    this._addInfo();\n    this.metadata.end();\n\n    /*\r\n    Metadata was introduced in PDF 1.4, so adding it to 1.3 \r\n    will likely only take up more space.\r\n    */\n    if (this.version != 1.3) {\n      this.metadataRef = this.ref({\n        length: this.metadata.getLength(),\n        Type: 'Metadata',\n        Subtype: 'XML'\n      });\n      this.metadataRef.compress = false;\n      this.metadataRef.write(Buffer.from(this.metadata.getXML(), 'utf-8'));\n      this.metadataRef.end();\n      this._root.data.Metadata = this.metadataRef;\n    }\n  }\n};\n\n/*\r\nPDFDocument - represents an entire PDF document\r\nBy Devon Govett\r\n*/\nclass PDFDocument extends (stream__WEBPACK_IMPORTED_MODULE_0___default().Readable) {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.options = options;\n\n    // PDF version\n    switch (options.pdfVersion) {\n      case '1.4':\n        this.version = 1.4;\n        break;\n      case '1.5':\n        this.version = 1.5;\n        break;\n      case '1.6':\n        this.version = 1.6;\n        break;\n      case '1.7':\n      case '1.7ext3':\n        this.version = 1.7;\n        break;\n      default:\n        this.version = 1.3;\n        break;\n    }\n\n    // Whether streams should be compressed\n    this.compress = this.options.compress != null ? this.options.compress : true;\n    this._pageBuffer = [];\n    this._pageBufferStart = 0;\n\n    // The PDF object store\n    this._offsets = [];\n    this._waiting = 0;\n    this._ended = false;\n    this._offset = 0;\n    const Pages = this.ref({\n      Type: 'Pages',\n      Count: 0,\n      Kids: []\n    });\n    const Names = this.ref({\n      Dests: new PDFNameTree()\n    });\n    this._root = this.ref({\n      Type: 'Catalog',\n      Pages,\n      Names\n    });\n    if (this.options.lang) {\n      this._root.data.Lang = new String(this.options.lang);\n    }\n\n    // The current page\n    this.page = null;\n\n    // Initialize mixins\n    this.initMetadata();\n    this.initColor();\n    this.initVector();\n    this.initFonts(options.font);\n    this.initText();\n    this.initImages();\n    this.initOutline();\n    this.initMarkings(options);\n    this.initSubset(options);\n\n    // Initialize the metadata\n    this.info = {\n      Producer: 'PDFKit',\n      Creator: 'PDFKit',\n      CreationDate: new Date()\n    };\n    if (this.options.info) {\n      for (let key in this.options.info) {\n        const val = this.options.info[key];\n        this.info[key] = val;\n      }\n    }\n    if (this.options.displayTitle) {\n      this._root.data.ViewerPreferences = this.ref({\n        DisplayDocTitle: true\n      });\n    }\n\n    // Generate file ID\n    this._id = PDFSecurity.generateFileID(this.info);\n\n    // Initialize security settings\n    this._security = PDFSecurity.create(this, options);\n\n    // Write the header\n    // PDF version\n    this._write(`%PDF-${this.version}`);\n\n    // 4 binary chars, as recommended by the spec\n    this._write('%\\xFF\\xFF\\xFF\\xFF');\n\n    // Add the first page\n    if (this.options.autoFirstPage !== false) {\n      this.addPage();\n    }\n  }\n  addPage(options) {\n    if (options == null) {\n      ({\n        options\n      } = this);\n    }\n\n    // end the current page if needed\n    if (!this.options.bufferPages) {\n      this.flushPages();\n    }\n\n    // create a page object\n    this.page = new PDFPage(this, options);\n    this._pageBuffer.push(this.page);\n\n    // add the page to the object store\n    const pages = this._root.data.Pages.data;\n    pages.Kids.push(this.page.dictionary);\n    pages.Count++;\n\n    // reset x and y coordinates\n    this.x = this.page.margins.left;\n    this.y = this.page.margins.top;\n\n    // flip PDF coordinate system so that the origin is in\n    // the top left rather than the bottom left\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    this.emit('pageAdded');\n    return this;\n  }\n  continueOnNewPage(options) {\n    const pageMarkings = this.endPageMarkings(this.page);\n    this.addPage(options);\n    this.initPageMarkings(pageMarkings);\n    return this;\n  }\n  bufferedPageRange() {\n    return {\n      start: this._pageBufferStart,\n      count: this._pageBuffer.length\n    };\n  }\n  switchToPage(n) {\n    let page;\n    if (!(page = this._pageBuffer[n - this._pageBufferStart])) {\n      throw new Error(`switchToPage(${n}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);\n    }\n    return this.page = page;\n  }\n  flushPages() {\n    // this local variable exists so we're future-proof against\n    // reentrant calls to flushPages.\n    const pages = this._pageBuffer;\n    this._pageBuffer = [];\n    this._pageBufferStart += pages.length;\n    for (let page of pages) {\n      this.endPageMarkings(page);\n      page.end();\n    }\n  }\n  addNamedDestination(name) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (args.length === 0) {\n      args = ['XYZ', null, null, null];\n    }\n    if (args[0] === 'XYZ' && args[2] !== null) {\n      args[2] = this.page.height - args[2];\n    }\n    args.unshift(this.page.dictionary);\n    this._root.data.Names.data.Dests.add(name, args);\n  }\n  addNamedEmbeddedFile(name, ref) {\n    if (!this._root.data.Names.data.EmbeddedFiles) {\n      // disabling /Limits for this tree fixes attachments not showing in Adobe Reader\n      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({\n        limits: false\n      });\n    }\n\n    // add filespec to EmbeddedFiles\n    this._root.data.Names.data.EmbeddedFiles.add(name, ref);\n  }\n  addNamedJavaScript(name, js) {\n    if (!this._root.data.Names.data.JavaScript) {\n      this._root.data.Names.data.JavaScript = new PDFNameTree();\n    }\n    let data = {\n      JS: new String(js),\n      S: 'JavaScript'\n    };\n    this._root.data.Names.data.JavaScript.add(name, data);\n  }\n  ref(data) {\n    const ref = new PDFReference(this, this._offsets.length + 1, data);\n    this._offsets.push(null); // placeholder for this object's offset once it is finalized\n    this._waiting++;\n    return ref;\n  }\n  _read() {}\n  // do nothing, but this method is required by node\n\n  _write(data) {\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data + '\\n', 'binary');\n    }\n    this.push(data);\n    return this._offset += data.length;\n  }\n  addContent(data) {\n    this.page.write(data);\n    return this;\n  }\n  _refEnd(ref) {\n    this._offsets[ref.id - 1] = ref.offset;\n    if (--this._waiting === 0 && this._ended) {\n      this._finalize();\n      return this._ended = false;\n    }\n  }\n  end() {\n    this.flushPages();\n    this._info = this.ref();\n    for (let key in this.info) {\n      let val = this.info[key];\n      if (typeof val === 'string') {\n        val = new String(val);\n      }\n      let entry = this.ref(val);\n      entry.end();\n      this._info.data[key] = entry;\n    }\n    this._info.end();\n    for (let name in this._fontFamilies) {\n      const font = this._fontFamilies[name];\n      font.finalize();\n    }\n    this.endOutline();\n    this.endMarkings();\n    if (this.subset) {\n      this.endSubset();\n    }\n    this.endMetadata();\n    this._root.end();\n    this._root.data.Pages.end();\n    this._root.data.Names.end();\n    this.endAcroForm();\n    if (this._root.data.ViewerPreferences) {\n      this._root.data.ViewerPreferences.end();\n    }\n    if (this._security) {\n      this._security.end();\n    }\n    if (this._waiting === 0) {\n      return this._finalize();\n    } else {\n      return this._ended = true;\n    }\n  }\n  _finalize() {\n    // generate xref\n    const xRefOffset = this._offset;\n    this._write('xref');\n    this._write(`0 ${this._offsets.length + 1}`);\n    this._write('0000000000 65535 f ');\n    for (let offset of this._offsets) {\n      offset = `0000000000${offset}`.slice(-10);\n      this._write(offset + ' 00000 n ');\n    }\n\n    // trailer\n    const trailer = {\n      Size: this._offsets.length + 1,\n      Root: this._root,\n      Info: this._info,\n      ID: [this._id, this._id]\n    };\n    if (this._security) {\n      trailer.Encrypt = this._security.dictionary;\n    }\n    this._write('trailer');\n    this._write(PDFObject.convert(trailer));\n    this._write('startxref');\n    this._write(`${xRefOffset}`);\n    this._write('%%EOF');\n\n    // end the stream\n    return this.push(null);\n  }\n  toString() {\n    return '[object PDFDocument]';\n  }\n}\nconst mixin = methods => {\n  Object.assign(PDFDocument.prototype, methods);\n};\nmixin(MetadataMixin);\nmixin(ColorMixin);\nmixin(VectorMixin);\nmixin(FontsMixin);\nmixin(TextMixin);\nmixin(ImagesMixin);\nmixin(AnnotationsMixin);\nmixin(OutlineMixin);\nmixin(MarkingsMixin);\nmixin(AcroFormMixin);\nmixin(AttachmentsMixin);\nmixin(SubsetMixin);\nPDFDocument.LineWrapper = LineWrapper;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PDFDocument);\n//# sourceMappingURL=pdfkit.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRma2l0L2pzL3BkZmtpdC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ0o7QUFDUztBQUNiO0FBQ1U7QUFDUTtBQUNGO0FBQ1A7QUFDSjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxRUFBcUU7QUFDakc7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0Esc0JBQXNCLDBDQUEwQyxFQUFFLG9DQUFvQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87O0FBRXhCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPOztBQUV4QjtBQUNBLE1BQU07QUFDTixpQkFBaUIsdUJBQXVCO0FBQ3hDLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTix3QkFBd0IsZ0NBQWdDOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkIsTUFBTSxXQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLEVBQUUsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVMsRUFBRSxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxFQUFFLFVBQVU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsYUFBYTs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCLEdBQUcsU0FBUyxFQUFFLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxFQUFFLEdBQUc7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixPQUFPLEVBQUUsR0FBRztBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVksR0FBRyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckMsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsR0FBRztBQUNqQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsR0FBRztBQUNqQyxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0IsSUFBSSx3QkFBd0I7QUFDekY7QUFDQTtBQUNBLCtCQUErQixPQUFPLElBQUksOEJBQThCO0FBQ3hFLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEJBQThCLGFBQWEsRUFBRSxhQUFhO0FBQzFELEdBQUc7QUFDSDtBQUNBLDhCQUE4QixhQUFhLEVBQUUsYUFBYTtBQUMxRCxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDbEksR0FBRztBQUNIO0FBQ0EsOEJBQThCLGVBQWUsRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDNUYsR0FBRztBQUNIO0FBQ0EsOEJBQThCLGFBQWEsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDeEYsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQsR0FBRztBQUNIO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0EsTUFBTTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxLQUFLOztBQUV2QztBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSyxFQUFFLCtCQUErQjtBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFdBQVcsRUFBQztBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlbmthdGVzaHdhcmEtY25jLW5leHRqcy8uL25vZGVfbW9kdWxlcy9wZGZraXQvanMvcGRma2l0LmVzLmpzPzk1NmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgQ3J5cHRvSlMgZnJvbSAnY3J5cHRvLWpzJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgZm9udGtpdCBmcm9tICdmb250a2l0JztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgTGluZUJyZWFrZXIgZnJvbSAnbGluZWJyZWFrJztcbmltcG9ydCBleGlmIGZyb20gJ2pwZWctZXhpZic7XG5pbXBvcnQgUE5HIGZyb20gJ3BuZy1qcyc7XG5cbi8qXHJcblBERkFic3RyYWN0UmVmZXJlbmNlIC0gYWJzdHJhY3QgY2xhc3MgZm9yIFBERiByZWZlcmVuY2VcclxuKi9cblxuY2xhc3MgUERGQWJzdHJhY3RSZWZlcmVuY2Uge1xuICB0b1N0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG59XG5cbi8qXHJcblBERlRyZWUgLSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBuYW1lIGFuZCBudW1iZXIgdHJlZSBvYmplY3RzXHJcbiovXG5jbGFzcyBQREZUcmVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMuX2l0ZW1zID0ge307XG4gICAgLy8gZGlzYWJsZSAvTGltaXRzIG91dHB1dCBmb3IgdGhpcyB0cmVlXG4gICAgdGhpcy5saW1pdHMgPSB0eXBlb2Ygb3B0aW9ucy5saW1pdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMubGltaXRzIDogdHJ1ZTtcbiAgfVxuICBhZGQoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XSA9IHZhbDtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2tleV07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc29ydGVkIGJ5IGtleVxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcykuc29ydCgoYSwgYikgPT4gdGhpcy5fY29tcGFyZUtleXMoYSwgYikpO1xuICAgIGNvbnN0IG91dCA9IFsnPDwnXTtcbiAgICBpZiAodGhpcy5saW1pdHMgJiYgc29ydGVkS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBmaXJzdCA9IHNvcnRlZEtleXNbMF0sXG4gICAgICAgIGxhc3QgPSBzb3J0ZWRLZXlzW3NvcnRlZEtleXMubGVuZ3RoIC0gMV07XG4gICAgICBvdXQucHVzaChgICAvTGltaXRzICR7UERGT2JqZWN0LmNvbnZlcnQoW3RoaXMuX2RhdGFGb3JLZXkoZmlyc3QpLCB0aGlzLl9kYXRhRm9yS2V5KGxhc3QpXSl9YCk7XG4gICAgfVxuICAgIG91dC5wdXNoKGAgIC8ke3RoaXMuX2tleXNOYW1lKCl9IFtgKTtcbiAgICBmb3IgKGxldCBrZXkgb2Ygc29ydGVkS2V5cykge1xuICAgICAgb3V0LnB1c2goYCAgICAke1BERk9iamVjdC5jb252ZXJ0KHRoaXMuX2RhdGFGb3JLZXkoa2V5KSl9ICR7UERGT2JqZWN0LmNvbnZlcnQodGhpcy5faXRlbXNba2V5XSl9YCk7XG4gICAgfVxuICAgIG91dC5wdXNoKCddJyk7XG4gICAgb3V0LnB1c2goJz4+Jyk7XG4gICAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbiAgfVxuICBfY29tcGFyZUtleXMoIC8qYSwgYiovXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgX2tleXNOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgX2RhdGFGb3JLZXkoIC8qayovXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbn1cblxuLypcclxuUERGT2JqZWN0IC0gY29udmVydHMgSmF2YVNjcmlwdCB0eXBlcyBpbnRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgUERGIHR5cGVzLlxyXG5CeSBEZXZvbiBHb3ZldHRcclxuKi9cbmNvbnN0IHBhZCA9IChzdHIsIGxlbmd0aCkgPT4gKEFycmF5KGxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHN0cikuc2xpY2UoLWxlbmd0aCk7XG5jb25zdCBlc2NhcGFibGVSZSA9IC9bXFxuXFxyXFx0XFxiXFxmKClcXFxcXS9nO1xuY29uc3QgZXNjYXBhYmxlID0ge1xuICAnXFxuJzogJ1xcXFxuJyxcbiAgJ1xccic6ICdcXFxccicsXG4gICdcXHQnOiAnXFxcXHQnLFxuICAnXFxiJzogJ1xcXFxiJyxcbiAgJ1xcZic6ICdcXFxcZicsXG4gICdcXFxcJzogJ1xcXFxcXFxcJyxcbiAgJygnOiAnXFxcXCgnLFxuICAnKSc6ICdcXFxcKSdcbn07XG5cbi8vIENvbnZlcnQgbGl0dGxlIGVuZGlhbiBVVEYtMTYgdG8gYmlnIGVuZGlhblxuY29uc3Qgc3dhcEJ5dGVzID0gZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgY29uc3QgbCA9IGJ1ZmYubGVuZ3RoO1xuICBpZiAobCAmIDB4MDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBsZW5ndGggbXVzdCBiZSBldmVuJyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGVuZCA9IGwgLSAxOyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGEgPSBidWZmW2ldO1xuICAgICAgYnVmZltpXSA9IGJ1ZmZbaSArIDFdO1xuICAgICAgYnVmZltpICsgMV0gPSBhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmZjtcbn07XG5jbGFzcyBQREZPYmplY3Qge1xuICBzdGF0aWMgY29udmVydChvYmplY3QpIHtcbiAgICBsZXQgZW5jcnlwdEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIC8vIFN0cmluZyBsaXRlcmFscyBhcmUgY29udmVydGVkIHRvIHRoZSBQREYgbmFtZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYC8ke29iamVjdH1gO1xuXG4gICAgICAvLyBTdHJpbmcgb2JqZWN0cyBhcmUgY29udmVydGVkIHRvIFBERiBzdHJpbmdzIChVVEYtMTYpXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIGxldCBzdHJpbmcgPSBvYmplY3Q7XG4gICAgICAvLyBEZXRlY3QgaWYgdGhpcyBpcyBhIHVuaWNvZGUgc3RyaW5nXG4gICAgICBsZXQgaXNVbmljb2RlID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMCwgZW5kID0gc3RyaW5nLmxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA+IDB4N2YpIHtcbiAgICAgICAgICBpc1VuaWNvZGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNvLCBlbmNvZGUgaXQgYXMgYmlnIGVuZGlhbiBVVEYtMTZcbiAgICAgIGxldCBzdHJpbmdCdWZmZXI7XG4gICAgICBpZiAoaXNVbmljb2RlKSB7XG4gICAgICAgIHN0cmluZ0J1ZmZlciA9IHN3YXBCeXRlcyhCdWZmZXIuZnJvbShgXFx1ZmVmZiR7c3RyaW5nfWAsICd1dGYxNmxlJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nQnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLnZhbHVlT2YoKSwgJ2FzY2lpJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuY3J5cHQgdGhlIHN0cmluZyB3aGVuIG5lY2Vzc2FyeVxuICAgICAgaWYgKGVuY3J5cHRGbikge1xuICAgICAgICBzdHJpbmcgPSBlbmNyeXB0Rm4oc3RyaW5nQnVmZmVyKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmdCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlUmUsIGMgPT4gZXNjYXBhYmxlW2NdKTtcbiAgICAgIHJldHVybiBgKCR7c3RyaW5nfSlgO1xuXG4gICAgICAvLyBCdWZmZXJzIGFyZSBjb252ZXJ0ZWQgdG8gUERGIGhleCBzdHJpbmdzXG4gICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIGA8JHtvYmplY3QudG9TdHJpbmcoJ2hleCcpfT5gO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUERGQWJzdHJhY3RSZWZlcmVuY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgUERGVHJlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgbGV0IHN0cmluZyA9IGBEOiR7cGFkKG9iamVjdC5nZXRVVENGdWxsWWVhcigpLCA0KX1gICsgcGFkKG9iamVjdC5nZXRVVENNb250aCgpICsgMSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0RhdGUoKSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0hvdXJzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENNaW51dGVzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENTZWNvbmRzKCksIDIpICsgJ1onO1xuXG4gICAgICAvLyBFbmNyeXB0IHRoZSBzdHJpbmcgd2hlbiBuZWNlc3NhcnlcbiAgICAgIGlmIChlbmNyeXB0Rm4pIHtcbiAgICAgICAgc3RyaW5nID0gZW5jcnlwdEZuKEJ1ZmZlci5mcm9tKHN0cmluZywgJ2FzY2lpJykpLnRvU3RyaW5nKCdiaW5hcnknKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShlc2NhcGFibGVSZSwgYyA9PiBlc2NhcGFibGVbY10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAoJHtzdHJpbmd9KWA7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb2JqZWN0Lm1hcChlID0+IFBERk9iamVjdC5jb252ZXJ0KGUsIGVuY3J5cHRGbikpLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBgWyR7aXRlbXN9XWA7XG4gICAgfSBlbHNlIGlmICh7fS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBjb25zdCBvdXQgPSBbJzw8J107XG4gICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICBvdXQucHVzaChgLyR7a2V5fSAke1BERk9iamVjdC5jb252ZXJ0KHZhbCwgZW5jcnlwdEZuKX1gKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKCc+PicpO1xuICAgICAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gUERGT2JqZWN0Lm51bWJlcihvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7b2JqZWN0fWA7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBudW1iZXIobikge1xuICAgIGlmIChuID4gLTFlMjEgJiYgbiA8IDFlMjEpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG4gKiAxZTYpIC8gMWU2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIG51bWJlcjogJHtufWApO1xuICB9XG59XG5cbi8qXHJcblBERlJlZmVyZW5jZSAtIHJlcHJlc2VudHMgYSByZWZlcmVuY2UgdG8gYW5vdGhlciBvYmplY3QgaW4gdGhlIFBERiBvYmplY3QgaGVpcmFyY2h5XHJcbkJ5IERldm9uIEdvdmV0dFxyXG4qL1xuY2xhc3MgUERGUmVmZXJlbmNlIGV4dGVuZHMgUERGQWJzdHJhY3RSZWZlcmVuY2Uge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgaWQpIHtcbiAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5nZW4gPSAwO1xuICAgIHRoaXMuY29tcHJlc3MgPSB0aGlzLmRvY3VtZW50LmNvbXByZXNzICYmICF0aGlzLmRhdGEuRmlsdGVyO1xuICAgIHRoaXMudW5jb21wcmVzc2VkTGVuZ3RoID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB9XG4gIHdyaXRlKGNodW5rKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rICsgJ1xcbicsICdiaW5hcnknKTtcbiAgICB9XG4gICAgdGhpcy51bmNvbXByZXNzZWRMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgIGlmICh0aGlzLmRhdGEuTGVuZ3RoID09IG51bGwpIHtcbiAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB0aGlzLmRhdGEuTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgICBpZiAodGhpcy5jb21wcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5GaWx0ZXIgPSAnRmxhdGVEZWNvZGUnO1xuICAgIH1cbiAgfVxuICBlbmQoY2h1bmspIHtcbiAgICBpZiAoY2h1bmspIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5hbGl6ZSgpO1xuICB9XG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5kb2N1bWVudC5fb2Zmc2V0O1xuICAgIGNvbnN0IGVuY3J5cHRGbiA9IHRoaXMuZG9jdW1lbnQuX3NlY3VyaXR5ID8gdGhpcy5kb2N1bWVudC5fc2VjdXJpdHkuZ2V0RW5jcnlwdEZuKHRoaXMuaWQsIHRoaXMuZ2VuKSA6IG51bGw7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVyKTtcbiAgICAgIGlmICh0aGlzLmNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gemxpYi5kZWZsYXRlU3luYyh0aGlzLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAoZW5jcnlwdEZuKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZW5jcnlwdEZuKHRoaXMuYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKGAke3RoaXMuaWR9ICR7dGhpcy5nZW59IG9iamApO1xuICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKFBERk9iamVjdC5jb252ZXJ0KHRoaXMuZGF0YSwgZW5jcnlwdEZuKSk7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ3N0cmVhbScpO1xuICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUodGhpcy5idWZmZXIpO1xuICAgICAgdGhpcy5idWZmZXIgPSBbXTsgLy8gZnJlZSB1cCBtZW1vcnlcbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKCdcXG5lbmRzdHJlYW0nKTtcbiAgICB9XG4gICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ2VuZG9iaicpO1xuICAgIHRoaXMuZG9jdW1lbnQuX3JlZkVuZCh0aGlzKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5pZH0gJHt0aGlzLmdlbn0gUmA7XG4gIH1cbn1cblxuLypcclxuUERGUGFnZSAtIHJlcHJlc2VudHMgYSBzaW5nbGUgcGFnZSBpbiB0aGUgUERGIGRvY3VtZW50XHJcbkJ5IERldm9uIEdvdmV0dFxyXG4qL1xuXG5jb25zdCBERUZBVUxUX01BUkdJTlMgPSB7XG4gIHRvcDogNzIsXG4gIGxlZnQ6IDcyLFxuICBib3R0b206IDcyLFxuICByaWdodDogNzJcbn07XG5jb25zdCBTSVpFUyA9IHtcbiAgJzRBMCc6IFs0NzY3Ljg3LCA2NzQwLjc5XSxcbiAgJzJBMCc6IFszMzcwLjM5LCA0NzY3Ljg3XSxcbiAgQTA6IFsyMzgzLjk0LCAzMzcwLjM5XSxcbiAgQTE6IFsxNjgzLjc4LCAyMzgzLjk0XSxcbiAgQTI6IFsxMTkwLjU1LCAxNjgzLjc4XSxcbiAgQTM6IFs4NDEuODksIDExOTAuNTVdLFxuICBBNDogWzU5NS4yOCwgODQxLjg5XSxcbiAgQTU6IFs0MTkuNTMsIDU5NS4yOF0sXG4gIEE2OiBbMjk3LjY0LCA0MTkuNTNdLFxuICBBNzogWzIwOS43NiwgMjk3LjY0XSxcbiAgQTg6IFsxNDcuNCwgMjA5Ljc2XSxcbiAgQTk6IFsxMDQuODgsIDE0Ny40XSxcbiAgQTEwOiBbNzMuNywgMTA0Ljg4XSxcbiAgQjA6IFsyODM0LjY1LCA0MDA4LjE5XSxcbiAgQjE6IFsyMDA0LjA5LCAyODM0LjY1XSxcbiAgQjI6IFsxNDE3LjMyLCAyMDA0LjA5XSxcbiAgQjM6IFsxMDAwLjYzLCAxNDE3LjMyXSxcbiAgQjQ6IFs3MDguNjYsIDEwMDAuNjNdLFxuICBCNTogWzQ5OC45LCA3MDguNjZdLFxuICBCNjogWzM1NC4zMywgNDk4LjldLFxuICBCNzogWzI0OS40NSwgMzU0LjMzXSxcbiAgQjg6IFsxNzUuNzUsIDI0OS40NV0sXG4gIEI5OiBbMTI0LjcyLCAxNzUuNzVdLFxuICBCMTA6IFs4Ny44NywgMTI0LjcyXSxcbiAgQzA6IFsyNTk5LjM3LCAzNjc2LjU0XSxcbiAgQzE6IFsxODM2Ljg1LCAyNTk5LjM3XSxcbiAgQzI6IFsxMjk4LjI3LCAxODM2Ljg1XSxcbiAgQzM6IFs5MTguNDMsIDEyOTguMjddLFxuICBDNDogWzY0OS4xMywgOTE4LjQzXSxcbiAgQzU6IFs0NTkuMjEsIDY0OS4xM10sXG4gIEM2OiBbMzIzLjE1LCA0NTkuMjFdLFxuICBDNzogWzIyOS42MSwgMzIzLjE1XSxcbiAgQzg6IFsxNjEuNTcsIDIyOS42MV0sXG4gIEM5OiBbMTEzLjM5LCAxNjEuNTddLFxuICBDMTA6IFs3OS4zNywgMTEzLjM5XSxcbiAgUkEwOiBbMjQzNy44LCAzNDU4LjI3XSxcbiAgUkExOiBbMTcyOS4xMywgMjQzNy44XSxcbiAgUkEyOiBbMTIxOC45LCAxNzI5LjEzXSxcbiAgUkEzOiBbODY0LjU3LCAxMjE4LjldLFxuICBSQTQ6IFs2MDkuNDUsIDg2NC41N10sXG4gIFNSQTA6IFsyNTUxLjE4LCAzNjI4LjM1XSxcbiAgU1JBMTogWzE4MTQuMTcsIDI1NTEuMThdLFxuICBTUkEyOiBbMTI3NS41OSwgMTgxNC4xN10sXG4gIFNSQTM6IFs5MDcuMDksIDEyNzUuNTldLFxuICBTUkE0OiBbNjM3LjgsIDkwNy4wOV0sXG4gIEVYRUNVVElWRTogWzUyMS44NiwgNzU2LjBdLFxuICBGT0xJTzogWzYxMi4wLCA5MzYuMF0sXG4gIExFR0FMOiBbNjEyLjAsIDEwMDguMF0sXG4gIExFVFRFUjogWzYxMi4wLCA3OTIuMF0sXG4gIFRBQkxPSUQ6IFs3OTIuMCwgMTIyNC4wXVxufTtcbmNsYXNzIFBERlBhZ2Uge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8ICdsZXR0ZXInO1xuICAgIHRoaXMubGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQgfHwgJ3BvcnRyYWl0JztcblxuICAgIC8vIHByb2Nlc3MgbWFyZ2luc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXJnaW4gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm1hcmdpbnMgPSB7XG4gICAgICAgIHRvcDogb3B0aW9ucy5tYXJnaW4sXG4gICAgICAgIGxlZnQ6IG9wdGlvbnMubWFyZ2luLFxuICAgICAgICBib3R0b206IG9wdGlvbnMubWFyZ2luLFxuICAgICAgICByaWdodDogb3B0aW9ucy5tYXJnaW5cbiAgICAgIH07XG5cbiAgICAgIC8vIGRlZmF1bHQgdG8gMSBpbmNoIG1hcmdpbnNcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJnaW5zID0gb3B0aW9ucy5tYXJnaW5zIHx8IERFRkFVTFRfTUFSR0lOUztcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcGFnZSBkaW1lbnNpb25zXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IEFycmF5LmlzQXJyYXkodGhpcy5zaXplKSA/IHRoaXMuc2l6ZSA6IFNJWkVTW3RoaXMuc2l6ZS50b1VwcGVyQ2FzZSgpXTtcbiAgICB0aGlzLndpZHRoID0gZGltZW5zaW9uc1t0aGlzLmxheW91dCA9PT0gJ3BvcnRyYWl0JyA/IDAgOiAxXTtcbiAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnNbdGhpcy5sYXlvdXQgPT09ICdwb3J0cmFpdCcgPyAxIDogMF07XG4gICAgdGhpcy5jb250ZW50ID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIEZvbnQsIFhPYmplY3QsIGFuZCBFeHRHU3RhdGUgZGljdGlvbmFyaWVzXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ11cbiAgICB9KTtcblxuICAgIC8vIFRoZSBwYWdlIGRpY3Rpb25hcnlcbiAgICB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBUeXBlOiAnUGFnZScsXG4gICAgICBQYXJlbnQ6IHRoaXMuZG9jdW1lbnQuX3Jvb3QuZGF0YS5QYWdlcyxcbiAgICAgIE1lZGlhQm94OiBbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLFxuICAgICAgQ29udGVudHM6IHRoaXMuY29udGVudCxcbiAgICAgIFJlc291cmNlczogdGhpcy5yZXNvdXJjZXNcbiAgICB9KTtcbiAgICB0aGlzLm1hcmtpbmdzID0gW107XG4gIH1cblxuICAvLyBMYXppbHkgY3JlYXRlIHRoZXNlIG9iamVjdHNcbiAgZ2V0IGZvbnRzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLkZvbnQgIT0gbnVsbCA/IGRhdGEuRm9udCA6IGRhdGEuRm9udCA9IHt9O1xuICB9XG4gIGdldCB4b2JqZWN0cygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5YT2JqZWN0ICE9IG51bGwgPyBkYXRhLlhPYmplY3QgOiBkYXRhLlhPYmplY3QgPSB7fTtcbiAgfVxuICBnZXQgZXh0X2dzdGF0ZXMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzb3VyY2VzLmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuRXh0R1N0YXRlICE9IG51bGwgPyBkYXRhLkV4dEdTdGF0ZSA6IGRhdGEuRXh0R1N0YXRlID0ge307XG4gIH1cbiAgZ2V0IHBhdHRlcm5zKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLlBhdHRlcm4gIT0gbnVsbCA/IGRhdGEuUGF0dGVybiA6IGRhdGEuUGF0dGVybiA9IHt9O1xuICB9XG4gIGdldCBjb2xvclNwYWNlcygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5Db2xvclNwYWNlIHx8IChkYXRhLkNvbG9yU3BhY2UgPSB7fSk7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25zKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRpY3Rpb25hcnkuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5Bbm5vdHMgIT0gbnVsbCA/IGRhdGEuQW5ub3RzIDogZGF0YS5Bbm5vdHMgPSBbXTtcbiAgfVxuICBnZXQgc3RydWN0UGFyZW50VHJlZUtleSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kaWN0aW9uYXJ5LmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuU3RydWN0UGFyZW50cyAhPSBudWxsID8gZGF0YS5TdHJ1Y3RQYXJlbnRzIDogZGF0YS5TdHJ1Y3RQYXJlbnRzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVTdHJ1Y3RQYXJlbnRUcmVlTmV4dEtleSgpO1xuICB9XG4gIG1heFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLmJvdHRvbTtcbiAgfVxuICB3cml0ZShjaHVuaykge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQud3JpdGUoY2h1bmspO1xuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gICAgdGhpcy5yZXNvdXJjZXMuZW5kKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5lbmQoKTtcbiAgfVxufVxuXG4vKlxyXG5QREZOYW1lVHJlZSAtIHJlcHJlc2VudHMgYSBuYW1lIHRyZWUgb2JqZWN0XHJcbiovXG5jbGFzcyBQREZOYW1lVHJlZSBleHRlbmRzIFBERlRyZWUge1xuICBfY29tcGFyZUtleXMoYSwgYikge1xuICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG4gIH1cbiAgX2tleXNOYW1lKCkge1xuICAgIHJldHVybiBcIk5hbWVzXCI7XG4gIH1cbiAgX2RhdGFGb3JLZXkoaykge1xuICAgIHJldHVybiBuZXcgU3RyaW5nKGspO1xuICB9XG59XG5cbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBpbiBhIHJhbmdlIGdyb3VwLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtudW1iZXJbXX0gcmFuZ2VHcm91cFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5mdW5jdGlvbiBpblJhbmdlKHZhbHVlLCByYW5nZUdyb3VwKSB7XG4gIGlmICh2YWx1ZSA8IHJhbmdlR3JvdXBbMF0pIHJldHVybiBmYWxzZTtcbiAgbGV0IHN0YXJ0UmFuZ2UgPSAwO1xuICBsZXQgZW5kUmFuZ2UgPSByYW5nZUdyb3VwLmxlbmd0aCAvIDI7XG4gIHdoaWxlIChzdGFydFJhbmdlIDw9IGVuZFJhbmdlKSB7XG4gICAgY29uc3QgbWlkZGxlUmFuZ2UgPSBNYXRoLmZsb29yKChzdGFydFJhbmdlICsgZW5kUmFuZ2UpIC8gMik7XG5cbiAgICAvLyBhY3R1YWwgYXJyYXkgaW5kZXhcbiAgICBjb25zdCBhcnJheUluZGV4ID0gbWlkZGxlUmFuZ2UgKiAyO1xuXG4gICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgaW4gcmFuZ2UgcG9pbnRlZCBieSBhY3R1YWwgaW5kZXhcbiAgICBpZiAodmFsdWUgPj0gcmFuZ2VHcm91cFthcnJheUluZGV4XSAmJiB2YWx1ZSA8PSByYW5nZUdyb3VwW2FycmF5SW5kZXggKyAxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IHJhbmdlR3JvdXBbYXJyYXlJbmRleCArIDFdKSB7XG4gICAgICAvLyBTZWFyY2ggUmlnaHQgU2lkZSBPZiBBcnJheVxuICAgICAgc3RhcnRSYW5nZSA9IG1pZGRsZVJhbmdlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VhcmNoIExlZnQgU2lkZSBPZiBBcnJheVxuICAgICAgZW5kUmFuZ2UgPSBtaWRkbGVSYW5nZSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlLXN0YXJ0XG4vKipcclxuICogQS4xIFVuYXNzaWduZWQgY29kZSBwb2ludHMgaW4gVW5pY29kZSAzLjJcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQS4xXHJcbiAqL1xuY29uc3QgdW5hc3NpZ25lZF9jb2RlX3BvaW50cyA9IFsweDAyMjEsIDB4MDIyMSwgMHgwMjM0LCAweDAyNGYsIDB4MDJhZSwgMHgwMmFmLCAweDAyZWYsIDB4MDJmZiwgMHgwMzUwLCAweDAzNWYsIDB4MDM3MCwgMHgwMzczLCAweDAzNzYsIDB4MDM3OSwgMHgwMzdiLCAweDAzN2QsIDB4MDM3ZiwgMHgwMzgzLCAweDAzOGIsIDB4MDM4YiwgMHgwMzhkLCAweDAzOGQsIDB4MDNhMiwgMHgwM2EyLCAweDAzY2YsIDB4MDNjZiwgMHgwM2Y3LCAweDAzZmYsIDB4MDQ4NywgMHgwNDg3LCAweDA0Y2YsIDB4MDRjZiwgMHgwNGY2LCAweDA0ZjcsIDB4MDRmYSwgMHgwNGZmLCAweDA1MTAsIDB4MDUzMCwgMHgwNTU3LCAweDA1NTgsIDB4MDU2MCwgMHgwNTYwLCAweDA1ODgsIDB4MDU4OCwgMHgwNThiLCAweDA1OTAsIDB4MDVhMiwgMHgwNWEyLCAweDA1YmEsIDB4MDViYSwgMHgwNWM1LCAweDA1Y2YsIDB4MDVlYiwgMHgwNWVmLCAweDA1ZjUsIDB4MDYwYiwgMHgwNjBkLCAweDA2MWEsIDB4MDYxYywgMHgwNjFlLCAweDA2MjAsIDB4MDYyMCwgMHgwNjNiLCAweDA2M2YsIDB4MDY1NiwgMHgwNjVmLCAweDA2ZWUsIDB4MDZlZiwgMHgwNmZmLCAweDA2ZmYsIDB4MDcwZSwgMHgwNzBlLCAweDA3MmQsIDB4MDcyZiwgMHgwNzRiLCAweDA3N2YsIDB4MDdiMiwgMHgwOTAwLCAweDA5MDQsIDB4MDkwNCwgMHgwOTNhLCAweDA5M2IsIDB4MDk0ZSwgMHgwOTRmLCAweDA5NTUsIDB4MDk1NywgMHgwOTcxLCAweDA5ODAsIDB4MDk4NCwgMHgwOTg0LCAweDA5OGQsIDB4MDk4ZSwgMHgwOTkxLCAweDA5OTIsIDB4MDlhOSwgMHgwOWE5LCAweDA5YjEsIDB4MDliMSwgMHgwOWIzLCAweDA5YjUsIDB4MDliYSwgMHgwOWJiLCAweDA5YmQsIDB4MDliZCwgMHgwOWM1LCAweDA5YzYsIDB4MDljOSwgMHgwOWNhLCAweDA5Y2UsIDB4MDlkNiwgMHgwOWQ4LCAweDA5ZGIsIDB4MDlkZSwgMHgwOWRlLCAweDA5ZTQsIDB4MDllNSwgMHgwOWZiLCAweDBhMDEsIDB4MGEwMywgMHgwYTA0LCAweDBhMGIsIDB4MGEwZSwgMHgwYTExLCAweDBhMTIsIDB4MGEyOSwgMHgwYTI5LCAweDBhMzEsIDB4MGEzMSwgMHgwYTM0LCAweDBhMzQsIDB4MGEzNywgMHgwYTM3LCAweDBhM2EsIDB4MGEzYiwgMHgwYTNkLCAweDBhM2QsIDB4MGE0MywgMHgwYTQ2LCAweDBhNDksIDB4MGE0YSwgMHgwYTRlLCAweDBhNTgsIDB4MGE1ZCwgMHgwYTVkLCAweDBhNWYsIDB4MGE2NSwgMHgwYTc1LCAweDBhODAsIDB4MGE4NCwgMHgwYTg0LCAweDBhOGMsIDB4MGE4YywgMHgwYThlLCAweDBhOGUsIDB4MGE5MiwgMHgwYTkyLCAweDBhYTksIDB4MGFhOSwgMHgwYWIxLCAweDBhYjEsIDB4MGFiNCwgMHgwYWI0LCAweDBhYmEsIDB4MGFiYiwgMHgwYWM2LCAweDBhYzYsIDB4MGFjYSwgMHgwYWNhLCAweDBhY2UsIDB4MGFjZiwgMHgwYWQxLCAweDBhZGYsIDB4MGFlMSwgMHgwYWU1LCAweDBhZjAsIDB4MGIwMCwgMHgwYjA0LCAweDBiMDQsIDB4MGIwZCwgMHgwYjBlLCAweDBiMTEsIDB4MGIxMiwgMHgwYjI5LCAweDBiMjksIDB4MGIzMSwgMHgwYjMxLCAweDBiMzQsIDB4MGIzNSwgMHgwYjNhLCAweDBiM2IsIDB4MGI0NCwgMHgwYjQ2LCAweDBiNDksIDB4MGI0YSwgMHgwYjRlLCAweDBiNTUsIDB4MGI1OCwgMHgwYjViLCAweDBiNWUsIDB4MGI1ZSwgMHgwYjYyLCAweDBiNjUsIDB4MGI3MSwgMHgwYjgxLCAweDBiODQsIDB4MGI4NCwgMHgwYjhiLCAweDBiOGQsIDB4MGI5MSwgMHgwYjkxLCAweDBiOTYsIDB4MGI5OCwgMHgwYjliLCAweDBiOWIsIDB4MGI5ZCwgMHgwYjlkLCAweDBiYTAsIDB4MGJhMiwgMHgwYmE1LCAweDBiYTcsIDB4MGJhYiwgMHgwYmFkLCAweDBiYjYsIDB4MGJiNiwgMHgwYmJhLCAweDBiYmQsIDB4MGJjMywgMHgwYmM1LCAweDBiYzksIDB4MGJjOSwgMHgwYmNlLCAweDBiZDYsIDB4MGJkOCwgMHgwYmU2LCAweDBiZjMsIDB4MGMwMCwgMHgwYzA0LCAweDBjMDQsIDB4MGMwZCwgMHgwYzBkLCAweDBjMTEsIDB4MGMxMSwgMHgwYzI5LCAweDBjMjksIDB4MGMzNCwgMHgwYzM0LCAweDBjM2EsIDB4MGMzZCwgMHgwYzQ1LCAweDBjNDUsIDB4MGM0OSwgMHgwYzQ5LCAweDBjNGUsIDB4MGM1NCwgMHgwYzU3LCAweDBjNWYsIDB4MGM2MiwgMHgwYzY1LCAweDBjNzAsIDB4MGM4MSwgMHgwYzg0LCAweDBjODQsIDB4MGM4ZCwgMHgwYzhkLCAweDBjOTEsIDB4MGM5MSwgMHgwY2E5LCAweDBjYTksIDB4MGNiNCwgMHgwY2I0LCAweDBjYmEsIDB4MGNiZCwgMHgwY2M1LCAweDBjYzUsIDB4MGNjOSwgMHgwY2M5LCAweDBjY2UsIDB4MGNkNCwgMHgwY2Q3LCAweDBjZGQsIDB4MGNkZiwgMHgwY2RmLCAweDBjZTIsIDB4MGNlNSwgMHgwY2YwLCAweDBkMDEsIDB4MGQwNCwgMHgwZDA0LCAweDBkMGQsIDB4MGQwZCwgMHgwZDExLCAweDBkMTEsIDB4MGQyOSwgMHgwZDI5LCAweDBkM2EsIDB4MGQzZCwgMHgwZDQ0LCAweDBkNDUsIDB4MGQ0OSwgMHgwZDQ5LCAweDBkNGUsIDB4MGQ1NiwgMHgwZDU4LCAweDBkNWYsIDB4MGQ2MiwgMHgwZDY1LCAweDBkNzAsIDB4MGQ4MSwgMHgwZDg0LCAweDBkODQsIDB4MGQ5NywgMHgwZDk5LCAweDBkYjIsIDB4MGRiMiwgMHgwZGJjLCAweDBkYmMsIDB4MGRiZSwgMHgwZGJmLCAweDBkYzcsIDB4MGRjOSwgMHgwZGNiLCAweDBkY2UsIDB4MGRkNSwgMHgwZGQ1LCAweDBkZDcsIDB4MGRkNywgMHgwZGUwLCAweDBkZjEsIDB4MGRmNSwgMHgwZTAwLCAweDBlM2IsIDB4MGUzZSwgMHgwZTVjLCAweDBlODAsIDB4MGU4MywgMHgwZTgzLCAweDBlODUsIDB4MGU4NiwgMHgwZTg5LCAweDBlODksIDB4MGU4YiwgMHgwZThjLCAweDBlOGUsIDB4MGU5MywgMHgwZTk4LCAweDBlOTgsIDB4MGVhMCwgMHgwZWEwLCAweDBlYTQsIDB4MGVhNCwgMHgwZWE2LCAweDBlYTYsIDB4MGVhOCwgMHgwZWE5LCAweDBlYWMsIDB4MGVhYywgMHgwZWJhLCAweDBlYmEsIDB4MGViZSwgMHgwZWJmLCAweDBlYzUsIDB4MGVjNSwgMHgwZWM3LCAweDBlYzcsIDB4MGVjZSwgMHgwZWNmLCAweDBlZGEsIDB4MGVkYiwgMHgwZWRlLCAweDBlZmYsIDB4MGY0OCwgMHgwZjQ4LCAweDBmNmIsIDB4MGY3MCwgMHgwZjhjLCAweDBmOGYsIDB4MGY5OCwgMHgwZjk4LCAweDBmYmQsIDB4MGZiZCwgMHgwZmNkLCAweDBmY2UsIDB4MGZkMCwgMHgwZmZmLCAweDEwMjIsIDB4MTAyMiwgMHgxMDI4LCAweDEwMjgsIDB4MTAyYiwgMHgxMDJiLCAweDEwMzMsIDB4MTAzNSwgMHgxMDNhLCAweDEwM2YsIDB4MTA1YSwgMHgxMDlmLCAweDEwYzYsIDB4MTBjZiwgMHgxMGY5LCAweDEwZmEsIDB4MTBmYywgMHgxMGZmLCAweDExNWEsIDB4MTE1ZSwgMHgxMWEzLCAweDExYTcsIDB4MTFmYSwgMHgxMWZmLCAweDEyMDcsIDB4MTIwNywgMHgxMjQ3LCAweDEyNDcsIDB4MTI0OSwgMHgxMjQ5LCAweDEyNGUsIDB4MTI0ZiwgMHgxMjU3LCAweDEyNTcsIDB4MTI1OSwgMHgxMjU5LCAweDEyNWUsIDB4MTI1ZiwgMHgxMjg3LCAweDEyODcsIDB4MTI4OSwgMHgxMjg5LCAweDEyOGUsIDB4MTI4ZiwgMHgxMmFmLCAweDEyYWYsIDB4MTJiMSwgMHgxMmIxLCAweDEyYjYsIDB4MTJiNywgMHgxMmJmLCAweDEyYmYsIDB4MTJjMSwgMHgxMmMxLCAweDEyYzYsIDB4MTJjNywgMHgxMmNmLCAweDEyY2YsIDB4MTJkNywgMHgxMmQ3LCAweDEyZWYsIDB4MTJlZiwgMHgxMzBmLCAweDEzMGYsIDB4MTMxMSwgMHgxMzExLCAweDEzMTYsIDB4MTMxNywgMHgxMzFmLCAweDEzMWYsIDB4MTM0NywgMHgxMzQ3LCAweDEzNWIsIDB4MTM2MCwgMHgxMzdkLCAweDEzOWYsIDB4MTNmNSwgMHgxNDAwLCAweDE2NzcsIDB4MTY3ZiwgMHgxNjlkLCAweDE2OWYsIDB4MTZmMSwgMHgxNmZmLCAweDE3MGQsIDB4MTcwZCwgMHgxNzE1LCAweDE3MWYsIDB4MTczNywgMHgxNzNmLCAweDE3NTQsIDB4MTc1ZiwgMHgxNzZkLCAweDE3NmQsIDB4MTc3MSwgMHgxNzcxLCAweDE3NzQsIDB4MTc3ZiwgMHgxN2RkLCAweDE3ZGYsIDB4MTdlYSwgMHgxN2ZmLCAweDE4MGYsIDB4MTgwZiwgMHgxODFhLCAweDE4MWYsIDB4MTg3OCwgMHgxODdmLCAweDE4YWEsIDB4MWRmZiwgMHgxZTljLCAweDFlOWYsIDB4MWVmYSwgMHgxZWZmLCAweDFmMTYsIDB4MWYxNywgMHgxZjFlLCAweDFmMWYsIDB4MWY0NiwgMHgxZjQ3LCAweDFmNGUsIDB4MWY0ZiwgMHgxZjU4LCAweDFmNTgsIDB4MWY1YSwgMHgxZjVhLCAweDFmNWMsIDB4MWY1YywgMHgxZjVlLCAweDFmNWUsIDB4MWY3ZSwgMHgxZjdmLCAweDFmYjUsIDB4MWZiNSwgMHgxZmM1LCAweDFmYzUsIDB4MWZkNCwgMHgxZmQ1LCAweDFmZGMsIDB4MWZkYywgMHgxZmYwLCAweDFmZjEsIDB4MWZmNSwgMHgxZmY1LCAweDFmZmYsIDB4MWZmZiwgMHgyMDUzLCAweDIwNTYsIDB4MjA1OCwgMHgyMDVlLCAweDIwNjQsIDB4MjA2OSwgMHgyMDcyLCAweDIwNzMsIDB4MjA4ZiwgMHgyMDlmLCAweDIwYjIsIDB4MjBjZiwgMHgyMGViLCAweDIwZmYsIDB4MjEzYiwgMHgyMTNjLCAweDIxNGMsIDB4MjE1MiwgMHgyMTg0LCAweDIxOGYsIDB4MjNjZiwgMHgyM2ZmLCAweDI0MjcsIDB4MjQzZiwgMHgyNDRiLCAweDI0NWYsIDB4MjRmZiwgMHgyNGZmLCAweDI2MTQsIDB4MjYxNSwgMHgyNjE4LCAweDI2MTgsIDB4MjY3ZSwgMHgyNjdmLCAweDI2OGEsIDB4MjcwMCwgMHgyNzA1LCAweDI3MDUsIDB4MjcwYSwgMHgyNzBiLCAweDI3MjgsIDB4MjcyOCwgMHgyNzRjLCAweDI3NGMsIDB4Mjc0ZSwgMHgyNzRlLCAweDI3NTMsIDB4Mjc1NSwgMHgyNzU3LCAweDI3NTcsIDB4Mjc1ZiwgMHgyNzYwLCAweDI3OTUsIDB4Mjc5NywgMHgyN2IwLCAweDI3YjAsIDB4MjdiZiwgMHgyN2NmLCAweDI3ZWMsIDB4MjdlZiwgMHgyYjAwLCAweDJlN2YsIDB4MmU5YSwgMHgyZTlhLCAweDJlZjQsIDB4MmVmZiwgMHgyZmQ2LCAweDJmZWYsIDB4MmZmYywgMHgyZmZmLCAweDMwNDAsIDB4MzA0MCwgMHgzMDk3LCAweDMwOTgsIDB4MzEwMCwgMHgzMTA0LCAweDMxMmQsIDB4MzEzMCwgMHgzMThmLCAweDMxOGYsIDB4MzFiOCwgMHgzMWVmLCAweDMyMWQsIDB4MzIxZiwgMHgzMjQ0LCAweDMyNTAsIDB4MzI3YywgMHgzMjdlLCAweDMyY2MsIDB4MzJjZiwgMHgzMmZmLCAweDMyZmYsIDB4MzM3NywgMHgzMzdhLCAweDMzZGUsIDB4MzNkZiwgMHgzM2ZmLCAweDMzZmYsIDB4NGRiNiwgMHg0ZGZmLCAweDlmYTYsIDB4OWZmZiwgMHhhNDhkLCAweGE0OGYsIDB4YTRjNywgMHhhYmZmLCAweGQ3YTQsIDB4ZDdmZiwgMHhmYTJlLCAweGZhMmYsIDB4ZmE2YiwgMHhmYWZmLCAweGZiMDcsIDB4ZmIxMiwgMHhmYjE4LCAweGZiMWMsIDB4ZmIzNywgMHhmYjM3LCAweGZiM2QsIDB4ZmIzZCwgMHhmYjNmLCAweGZiM2YsIDB4ZmI0MiwgMHhmYjQyLCAweGZiNDUsIDB4ZmI0NSwgMHhmYmIyLCAweGZiZDIsIDB4ZmQ0MCwgMHhmZDRmLCAweGZkOTAsIDB4ZmQ5MSwgMHhmZGM4LCAweGZkY2YsIDB4ZmRmZCwgMHhmZGZmLCAweGZlMTAsIDB4ZmUxZiwgMHhmZTI0LCAweGZlMmYsIDB4ZmU0NywgMHhmZTQ4LCAweGZlNTMsIDB4ZmU1MywgMHhmZTY3LCAweGZlNjcsIDB4ZmU2YywgMHhmZTZmLCAweGZlNzUsIDB4ZmU3NSwgMHhmZWZkLCAweGZlZmUsIDB4ZmYwMCwgMHhmZjAwLCAweGZmYmYsIDB4ZmZjMSwgMHhmZmM4LCAweGZmYzksIDB4ZmZkMCwgMHhmZmQxLCAweGZmZDgsIDB4ZmZkOSwgMHhmZmRkLCAweGZmZGYsIDB4ZmZlNywgMHhmZmU3LCAweGZmZWYsIDB4ZmZmOCwgMHgxMDAwMCwgMHgxMDJmZiwgMHgxMDMxZiwgMHgxMDMxZiwgMHgxMDMyNCwgMHgxMDMyZiwgMHgxMDM0YiwgMHgxMDNmZiwgMHgxMDQyNiwgMHgxMDQyNywgMHgxMDQ0ZSwgMHgxY2ZmZiwgMHgxZDBmNiwgMHgxZDBmZiwgMHgxZDEyNywgMHgxZDEyOSwgMHgxZDFkZSwgMHgxZDNmZiwgMHgxZDQ1NSwgMHgxZDQ1NSwgMHgxZDQ5ZCwgMHgxZDQ5ZCwgMHgxZDRhMCwgMHgxZDRhMSwgMHgxZDRhMywgMHgxZDRhNCwgMHgxZDRhNywgMHgxZDRhOCwgMHgxZDRhZCwgMHgxZDRhZCwgMHgxZDRiYSwgMHgxZDRiYSwgMHgxZDRiYywgMHgxZDRiYywgMHgxZDRjMSwgMHgxZDRjMSwgMHgxZDRjNCwgMHgxZDRjNCwgMHgxZDUwNiwgMHgxZDUwNiwgMHgxZDUwYiwgMHgxZDUwYywgMHgxZDUxNSwgMHgxZDUxNSwgMHgxZDUxZCwgMHgxZDUxZCwgMHgxZDUzYSwgMHgxZDUzYSwgMHgxZDUzZiwgMHgxZDUzZiwgMHgxZDU0NSwgMHgxZDU0NSwgMHgxZDU0NywgMHgxZDU0OSwgMHgxZDU1MSwgMHgxZDU1MSwgMHgxZDZhNCwgMHgxZDZhNywgMHgxZDdjYSwgMHgxZDdjZCwgMHgxZDgwMCwgMHgxZmZmZCwgMHgyYTZkNywgMHgyZjdmZiwgMHgyZmExZSwgMHgyZmZmZCwgMHgzMDAwMCwgMHgzZmZmZCwgMHg0MDAwMCwgMHg0ZmZmZCwgMHg1MDAwMCwgMHg1ZmZmZCwgMHg2MDAwMCwgMHg2ZmZmZCwgMHg3MDAwMCwgMHg3ZmZmZCwgMHg4MDAwMCwgMHg4ZmZmZCwgMHg5MDAwMCwgMHg5ZmZmZCwgMHhhMDAwMCwgMHhhZmZmZCwgMHhiMDAwMCwgMHhiZmZmZCwgMHhjMDAwMCwgMHhjZmZmZCwgMHhkMDAwMCwgMHhkZmZmZCwgMHhlMDAwMCwgMHhlMDAwMCwgMHhlMDAwMiwgMHhlMDAxZiwgMHhlMDA4MCwgMHhlZmZmZF07XG4vLyBwcmV0dGllci1pZ25vcmUtZW5kXG5cbmNvbnN0IGlzVW5hc3NpZ25lZENvZGVQb2ludCA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3RlciwgdW5hc3NpZ25lZF9jb2RlX3BvaW50cyk7XG5cbi8vIHByZXR0aWVyLWlnbm9yZS1zdGFydFxuLyoqXHJcbiAqIEIuMSBDb21tb25seSBtYXBwZWQgdG8gbm90aGluZ1xyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1CLjFcclxuICovXG5jb25zdCBjb21tb25seV9tYXBwZWRfdG9fbm90aGluZyA9IFsweDAwYWQsIDB4MDBhZCwgMHgwMzRmLCAweDAzNGYsIDB4MTgwNiwgMHgxODA2LCAweDE4MGIsIDB4MTgwYiwgMHgxODBjLCAweDE4MGMsIDB4MTgwZCwgMHgxODBkLCAweDIwMGIsIDB4MjAwYiwgMHgyMDBjLCAweDIwMGMsIDB4MjAwZCwgMHgyMDBkLCAweDIwNjAsIDB4MjA2MCwgMHhmZTAwLCAweGZlMDAsIDB4ZmUwMSwgMHhmZTAxLCAweGZlMDIsIDB4ZmUwMiwgMHhmZTAzLCAweGZlMDMsIDB4ZmUwNCwgMHhmZTA0LCAweGZlMDUsIDB4ZmUwNSwgMHhmZTA2LCAweGZlMDYsIDB4ZmUwNywgMHhmZTA3LCAweGZlMDgsIDB4ZmUwOCwgMHhmZTA5LCAweGZlMDksIDB4ZmUwYSwgMHhmZTBhLCAweGZlMGIsIDB4ZmUwYiwgMHhmZTBjLCAweGZlMGMsIDB4ZmUwZCwgMHhmZTBkLCAweGZlMGUsIDB4ZmUwZSwgMHhmZTBmLCAweGZlMGYsIDB4ZmVmZiwgMHhmZWZmXTtcbi8vIHByZXR0aWVyLWlnbm9yZS1lbmRcblxuY29uc3QgaXNDb21tb25seU1hcHBlZFRvTm90aGluZyA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3RlciwgY29tbW9ubHlfbWFwcGVkX3RvX25vdGhpbmcpO1xuXG4vLyBwcmV0dGllci1pZ25vcmUtc3RhcnRcbi8qKlxyXG4gKiBDLjEuMiBOb24tQVNDSUkgc3BhY2UgY2hhcmFjdGVyc1xyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjEuMlxyXG4gKi9cbmNvbnN0IG5vbl9BU0NJSV9zcGFjZV9jaGFyYWN0ZXJzID0gWzB4MDBhMCwgMHgwMGEwIC8qIE5PLUJSRUFLIFNQQUNFICovLCAweDE2ODAsIDB4MTY4MCAvKiBPR0hBTSBTUEFDRSBNQVJLICovLCAweDIwMDAsIDB4MjAwMCAvKiBFTiBRVUFEICovLCAweDIwMDEsIDB4MjAwMSAvKiBFTSBRVUFEICovLCAweDIwMDIsIDB4MjAwMiAvKiBFTiBTUEFDRSAqLywgMHgyMDAzLCAweDIwMDMgLyogRU0gU1BBQ0UgKi8sIDB4MjAwNCwgMHgyMDA0IC8qIFRIUkVFLVBFUi1FTSBTUEFDRSAqLywgMHgyMDA1LCAweDIwMDUgLyogRk9VUi1QRVItRU0gU1BBQ0UgKi8sIDB4MjAwNiwgMHgyMDA2IC8qIFNJWC1QRVItRU0gU1BBQ0UgKi8sIDB4MjAwNywgMHgyMDA3IC8qIEZJR1VSRSBTUEFDRSAqLywgMHgyMDA4LCAweDIwMDggLyogUFVOQ1RVQVRJT04gU1BBQ0UgKi8sIDB4MjAwOSwgMHgyMDA5IC8qIFRISU4gU1BBQ0UgKi8sIDB4MjAwYSwgMHgyMDBhIC8qIEhBSVIgU1BBQ0UgKi8sIDB4MjAwYiwgMHgyMDBiIC8qIFpFUk8gV0lEVEggU1BBQ0UgKi8sIDB4MjAyZiwgMHgyMDJmIC8qIE5BUlJPVyBOTy1CUkVBSyBTUEFDRSAqLywgMHgyMDVmLCAweDIwNWYgLyogTUVESVVNIE1BVEhFTUFUSUNBTCBTUEFDRSAqLywgMHgzMDAwLCAweDMwMDAgLyogSURFT0dSQVBISUMgU1BBQ0UgKi9dO1xuLy8gcHJldHRpZXItaWdub3JlLWVuZFxuXG5jb25zdCBpc05vbkFTQ0lJU3BhY2VDaGFyYWN0ZXIgPSBjaGFyYWN0ZXIgPT4gaW5SYW5nZShjaGFyYWN0ZXIsIG5vbl9BU0NJSV9zcGFjZV9jaGFyYWN0ZXJzKTtcblxuLy8gcHJldHRpZXItaWdub3JlLXN0YXJ0XG5jb25zdCBub25fQVNDSUlfY29udHJvbHNfY2hhcmFjdGVycyA9IFtcbi8qKlxyXG4gKiBDLjIuMiBOb24tQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuMi4yXHJcbiAqL1xuMHgwMDgwLCAweDAwOWYgLyogW0NPTlRST0wgQ0hBUkFDVEVSU10gKi8sIDB4MDZkZCwgMHgwNmRkIC8qIEFSQUJJQyBFTkQgT0YgQVlBSCAqLywgMHgwNzBmLCAweDA3MGYgLyogU1lSSUFDIEFCQlJFVklBVElPTiBNQVJLICovLCAweDE4MGUsIDB4MTgwZSAvKiBNT05HT0xJQU4gVk9XRUwgU0VQQVJBVE9SICovLCAweDIwMGMsIDB4MjAwYyAvKiBaRVJPIFdJRFRIIE5PTi1KT0lORVIgKi8sIDB4MjAwZCwgMHgyMDBkIC8qIFpFUk8gV0lEVEggSk9JTkVSICovLCAweDIwMjgsIDB4MjAyOCAvKiBMSU5FIFNFUEFSQVRPUiAqLywgMHgyMDI5LCAweDIwMjkgLyogUEFSQUdSQVBIIFNFUEFSQVRPUiAqLywgMHgyMDYwLCAweDIwNjAgLyogV09SRCBKT0lORVIgKi8sIDB4MjA2MSwgMHgyMDYxIC8qIEZVTkNUSU9OIEFQUExJQ0FUSU9OICovLCAweDIwNjIsIDB4MjA2MiAvKiBJTlZJU0lCTEUgVElNRVMgKi8sIDB4MjA2MywgMHgyMDYzIC8qIElOVklTSUJMRSBTRVBBUkFUT1IgKi8sIDB4MjA2YSwgMHgyMDZmIC8qIFtDT05UUk9MIENIQVJBQ1RFUlNdICovLCAweGZlZmYsIDB4ZmVmZiAvKiBaRVJPIFdJRFRIIE5PLUJSRUFLIFNQQUNFICovLCAweGZmZjksIDB4ZmZmYyAvKiBbQ09OVFJPTCBDSEFSQUNURVJTXSAqLywgMHgxZDE3MywgMHgxZDE3YSAvKiBbTVVTSUNBTCBDT05UUk9MIENIQVJBQ1RFUlNdICovXTtcbmNvbnN0IG5vbl9jaGFyYWN0ZXJfY29kZXBvaW50cyA9IFtcbi8qKlxyXG4gKiBDLjQgTm9uLWNoYXJhY3RlciBjb2RlIHBvaW50c1xyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjRcclxuICovXG4weGZkZDAsIDB4ZmRlZiAvKiBbTk9OQ0hBUkFDVEVSIENPREUgUE9JTlRTXSAqLywgMHhmZmZlLCAweGZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4MWZmZmUsIDB4MWZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4MmZmZmUsIDB4MmZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4M2ZmZmUsIDB4M2ZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4NGZmZmUsIDB4NGZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4NWZmZmUsIDB4NWZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4NmZmZmUsIDB4NmZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4N2ZmZmUsIDB4N2ZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4OGZmZmUsIDB4OGZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4OWZmZmUsIDB4OWZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4YWZmZmUsIDB4YWZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4YmZmZmUsIDB4YmZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4Y2ZmZmUsIDB4Y2ZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4ZGZmZmUsIDB4ZGZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4ZWZmZmUsIDB4ZWZmZmYgLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi8sIDB4MTBmZmZlLCAweDEwZmZmZiAvKiBbTk9OQ0hBUkFDVEVSIENPREUgUE9JTlRTXSAqL107XG5cbi8qKlxyXG4gKiAyLjMuICBQcm9oaWJpdGVkIE91dHB1dFxyXG4gKi9cbmNvbnN0IHByb2hpYml0ZWRfY2hhcmFjdGVycyA9IFtcbi8qKlxyXG4gKiBDLjIuMSBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy4yLjFcclxuICovXG4wLCAweDAwMWYgLyogW0NPTlRST0wgQ0hBUkFDVEVSU10gKi8sIDB4MDA3ZiwgMHgwMDdmIC8qIERFTEVURSAqLyxcbi8qKlxyXG4gKiBDLjggQ2hhbmdlIGRpc3BsYXkgcHJvcGVydGllcyBvciBhcmUgZGVwcmVjYXRlZFxyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjhcclxuICovXG4weDAzNDAsIDB4MDM0MCAvKiBDT01CSU5JTkcgR1JBVkUgVE9ORSBNQVJLICovLCAweDAzNDEsIDB4MDM0MSAvKiBDT01CSU5JTkcgQUNVVEUgVE9ORSBNQVJLICovLCAweDIwMGUsIDB4MjAwZSAvKiBMRUZULVRPLVJJR0hUIE1BUksgKi8sIDB4MjAwZiwgMHgyMDBmIC8qIFJJR0hULVRPLUxFRlQgTUFSSyAqLywgMHgyMDJhLCAweDIwMmEgLyogTEVGVC1UTy1SSUdIVCBFTUJFRERJTkcgKi8sIDB4MjAyYiwgMHgyMDJiIC8qIFJJR0hULVRPLUxFRlQgRU1CRURESU5HICovLCAweDIwMmMsIDB4MjAyYyAvKiBQT1AgRElSRUNUSU9OQUwgRk9STUFUVElORyAqLywgMHgyMDJkLCAweDIwMmQgLyogTEVGVC1UTy1SSUdIVCBPVkVSUklERSAqLywgMHgyMDJlLCAweDIwMmUgLyogUklHSFQtVE8tTEVGVCBPVkVSUklERSAqLywgMHgyMDZhLCAweDIwNmEgLyogSU5ISUJJVCBTWU1NRVRSSUMgU1dBUFBJTkcgKi8sIDB4MjA2YiwgMHgyMDZiIC8qIEFDVElWQVRFIFNZTU1FVFJJQyBTV0FQUElORyAqLywgMHgyMDZjLCAweDIwNmMgLyogSU5ISUJJVCBBUkFCSUMgRk9STSBTSEFQSU5HICovLCAweDIwNmQsIDB4MjA2ZCAvKiBBQ1RJVkFURSBBUkFCSUMgRk9STSBTSEFQSU5HICovLCAweDIwNmUsIDB4MjA2ZSAvKiBOQVRJT05BTCBESUdJVCBTSEFQRVMgKi8sIDB4MjA2ZiwgMHgyMDZmIC8qIE5PTUlOQUwgRElHSVQgU0hBUEVTICovLFxuLyoqXHJcbiAqIEMuNyBJbmFwcHJvcHJpYXRlIGZvciBjYW5vbmljYWwgcmVwcmVzZW50YXRpb25cclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy43XHJcbiAqL1xuMHgyZmYwLCAweDJmZmIgLyogW0lERU9HUkFQSElDIERFU0NSSVBUSU9OIENIQVJBQ1RFUlNdICovLFxuLyoqXHJcbiAqIEMuNSBTdXJyb2dhdGUgY29kZXNcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy41XHJcbiAqL1xuMHhkODAwLCAweGRmZmYsXG4vKipcclxuICogQy4zIFByaXZhdGUgdXNlXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuM1xyXG4gKi9cbjB4ZTAwMCwgMHhmOGZmIC8qIFtQUklWQVRFIFVTRSwgUExBTkUgMF0gKi8sXG4vKipcclxuICogQy42IEluYXBwcm9wcmlhdGUgZm9yIHBsYWluIHRleHRcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy42XHJcbiAqL1xuMHhmZmY5LCAweGZmZjkgLyogSU5URVJMSU5FQVIgQU5OT1RBVElPTiBBTkNIT1IgKi8sIDB4ZmZmYSwgMHhmZmZhIC8qIElOVEVSTElORUFSIEFOTk9UQVRJT04gU0VQQVJBVE9SICovLCAweGZmZmIsIDB4ZmZmYiAvKiBJTlRFUkxJTkVBUiBBTk5PVEFUSU9OIFRFUk1JTkFUT1IgKi8sIDB4ZmZmYywgMHhmZmZjIC8qIE9CSkVDVCBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi8sIDB4ZmZmZCwgMHhmZmZkIC8qIFJFUExBQ0VNRU5UIENIQVJBQ1RFUiAqLyxcbi8qKlxyXG4gKiBDLjkgVGFnZ2luZyBjaGFyYWN0ZXJzXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuOVxyXG4gKi9cbjB4ZTAwMDEsIDB4ZTAwMDEgLyogTEFOR1VBR0UgVEFHICovLCAweGUwMDIwLCAweGUwMDdmIC8qIFtUQUdHSU5HIENIQVJBQ1RFUlNdICovLFxuLyoqXHJcbiAqIEMuMyBQcml2YXRlIHVzZVxyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjNcclxuICovXG5cbjB4ZjAwMDAsIDB4ZmZmZmQgLyogW1BSSVZBVEUgVVNFLCBQTEFORSAxNV0gKi8sIDB4MTAwMDAwLCAweDEwZmZmZCAvKiBbUFJJVkFURSBVU0UsIFBMQU5FIDE2XSAqL107XG4vLyBwcmV0dGllci1pZ25vcmUtZW5kXG5cbmNvbnN0IGlzUHJvaGliaXRlZENoYXJhY3RlciA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3Rlciwgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBwcm9oaWJpdGVkX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfY29udHJvbHNfY2hhcmFjdGVycykgfHwgaW5SYW5nZShjaGFyYWN0ZXIsIG5vbl9jaGFyYWN0ZXJfY29kZXBvaW50cyk7XG5cbi8vIHByZXR0aWVyLWlnbm9yZS1zdGFydFxuLyoqXHJcbiAqIEQuMSBDaGFyYWN0ZXJzIHdpdGggYmlkaXJlY3Rpb25hbCBwcm9wZXJ0eSBcIlJcIiBvciBcIkFMXCJcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtRC4xXHJcbiAqL1xuY29uc3QgYmlkaXJlY3Rpb25hbF9yX2FsID0gWzB4MDViZSwgMHgwNWJlLCAweDA1YzAsIDB4MDVjMCwgMHgwNWMzLCAweDA1YzMsIDB4MDVkMCwgMHgwNWVhLCAweDA1ZjAsIDB4MDVmNCwgMHgwNjFiLCAweDA2MWIsIDB4MDYxZiwgMHgwNjFmLCAweDA2MjEsIDB4MDYzYSwgMHgwNjQwLCAweDA2NGEsIDB4MDY2ZCwgMHgwNjZmLCAweDA2NzEsIDB4MDZkNSwgMHgwNmRkLCAweDA2ZGQsIDB4MDZlNSwgMHgwNmU2LCAweDA2ZmEsIDB4MDZmZSwgMHgwNzAwLCAweDA3MGQsIDB4MDcxMCwgMHgwNzEwLCAweDA3MTIsIDB4MDcyYywgMHgwNzgwLCAweDA3YTUsIDB4MDdiMSwgMHgwN2IxLCAweDIwMGYsIDB4MjAwZiwgMHhmYjFkLCAweGZiMWQsIDB4ZmIxZiwgMHhmYjI4LCAweGZiMmEsIDB4ZmIzNiwgMHhmYjM4LCAweGZiM2MsIDB4ZmIzZSwgMHhmYjNlLCAweGZiNDAsIDB4ZmI0MSwgMHhmYjQzLCAweGZiNDQsIDB4ZmI0NiwgMHhmYmIxLCAweGZiZDMsIDB4ZmQzZCwgMHhmZDUwLCAweGZkOGYsIDB4ZmQ5MiwgMHhmZGM3LCAweGZkZjAsIDB4ZmRmYywgMHhmZTcwLCAweGZlNzQsIDB4ZmU3NiwgMHhmZWZjXTtcbi8vIHByZXR0aWVyLWlnbm9yZS1lbmRcblxuY29uc3QgaXNCaWRpcmVjdGlvbmFsUkFMID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCBiaWRpcmVjdGlvbmFsX3JfYWwpO1xuXG4vLyBwcmV0dGllci1pZ25vcmUtc3RhcnRcbi8qKlxyXG4gKiBELjIgQ2hhcmFjdGVycyB3aXRoIGJpZGlyZWN0aW9uYWwgcHJvcGVydHkgXCJMXCJcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtRC4yXHJcbiAqL1xuY29uc3QgYmlkaXJlY3Rpb25hbF9sID0gWzB4MDA0MSwgMHgwMDVhLCAweDAwNjEsIDB4MDA3YSwgMHgwMGFhLCAweDAwYWEsIDB4MDBiNSwgMHgwMGI1LCAweDAwYmEsIDB4MDBiYSwgMHgwMGMwLCAweDAwZDYsIDB4MDBkOCwgMHgwMGY2LCAweDAwZjgsIDB4MDIyMCwgMHgwMjIyLCAweDAyMzMsIDB4MDI1MCwgMHgwMmFkLCAweDAyYjAsIDB4MDJiOCwgMHgwMmJiLCAweDAyYzEsIDB4MDJkMCwgMHgwMmQxLCAweDAyZTAsIDB4MDJlNCwgMHgwMmVlLCAweDAyZWUsIDB4MDM3YSwgMHgwMzdhLCAweDAzODYsIDB4MDM4NiwgMHgwMzg4LCAweDAzOGEsIDB4MDM4YywgMHgwMzhjLCAweDAzOGUsIDB4MDNhMSwgMHgwM2EzLCAweDAzY2UsIDB4MDNkMCwgMHgwM2Y1LCAweDA0MDAsIDB4MDQ4MiwgMHgwNDhhLCAweDA0Y2UsIDB4MDRkMCwgMHgwNGY1LCAweDA0ZjgsIDB4MDRmOSwgMHgwNTAwLCAweDA1MGYsIDB4MDUzMSwgMHgwNTU2LCAweDA1NTksIDB4MDU1ZiwgMHgwNTYxLCAweDA1ODcsIDB4MDU4OSwgMHgwNTg5LCAweDA5MDMsIDB4MDkwMywgMHgwOTA1LCAweDA5MzksIDB4MDkzZCwgMHgwOTQwLCAweDA5NDksIDB4MDk0YywgMHgwOTUwLCAweDA5NTAsIDB4MDk1OCwgMHgwOTYxLCAweDA5NjQsIDB4MDk3MCwgMHgwOTgyLCAweDA5ODMsIDB4MDk4NSwgMHgwOThjLCAweDA5OGYsIDB4MDk5MCwgMHgwOTkzLCAweDA5YTgsIDB4MDlhYSwgMHgwOWIwLCAweDA5YjIsIDB4MDliMiwgMHgwOWI2LCAweDA5YjksIDB4MDliZSwgMHgwOWMwLCAweDA5YzcsIDB4MDljOCwgMHgwOWNiLCAweDA5Y2MsIDB4MDlkNywgMHgwOWQ3LCAweDA5ZGMsIDB4MDlkZCwgMHgwOWRmLCAweDA5ZTEsIDB4MDllNiwgMHgwOWYxLCAweDA5ZjQsIDB4MDlmYSwgMHgwYTA1LCAweDBhMGEsIDB4MGEwZiwgMHgwYTEwLCAweDBhMTMsIDB4MGEyOCwgMHgwYTJhLCAweDBhMzAsIDB4MGEzMiwgMHgwYTMzLCAweDBhMzUsIDB4MGEzNiwgMHgwYTM4LCAweDBhMzksIDB4MGEzZSwgMHgwYTQwLCAweDBhNTksIDB4MGE1YywgMHgwYTVlLCAweDBhNWUsIDB4MGE2NiwgMHgwYTZmLCAweDBhNzIsIDB4MGE3NCwgMHgwYTgzLCAweDBhODMsIDB4MGE4NSwgMHgwYThiLCAweDBhOGQsIDB4MGE4ZCwgMHgwYThmLCAweDBhOTEsIDB4MGE5MywgMHgwYWE4LCAweDBhYWEsIDB4MGFiMCwgMHgwYWIyLCAweDBhYjMsIDB4MGFiNSwgMHgwYWI5LCAweDBhYmQsIDB4MGFjMCwgMHgwYWM5LCAweDBhYzksIDB4MGFjYiwgMHgwYWNjLCAweDBhZDAsIDB4MGFkMCwgMHgwYWUwLCAweDBhZTAsIDB4MGFlNiwgMHgwYWVmLCAweDBiMDIsIDB4MGIwMywgMHgwYjA1LCAweDBiMGMsIDB4MGIwZiwgMHgwYjEwLCAweDBiMTMsIDB4MGIyOCwgMHgwYjJhLCAweDBiMzAsIDB4MGIzMiwgMHgwYjMzLCAweDBiMzYsIDB4MGIzOSwgMHgwYjNkLCAweDBiM2UsIDB4MGI0MCwgMHgwYjQwLCAweDBiNDcsIDB4MGI0OCwgMHgwYjRiLCAweDBiNGMsIDB4MGI1NywgMHgwYjU3LCAweDBiNWMsIDB4MGI1ZCwgMHgwYjVmLCAweDBiNjEsIDB4MGI2NiwgMHgwYjcwLCAweDBiODMsIDB4MGI4MywgMHgwYjg1LCAweDBiOGEsIDB4MGI4ZSwgMHgwYjkwLCAweDBiOTIsIDB4MGI5NSwgMHgwYjk5LCAweDBiOWEsIDB4MGI5YywgMHgwYjljLCAweDBiOWUsIDB4MGI5ZiwgMHgwYmEzLCAweDBiYTQsIDB4MGJhOCwgMHgwYmFhLCAweDBiYWUsIDB4MGJiNSwgMHgwYmI3LCAweDBiYjksIDB4MGJiZSwgMHgwYmJmLCAweDBiYzEsIDB4MGJjMiwgMHgwYmM2LCAweDBiYzgsIDB4MGJjYSwgMHgwYmNjLCAweDBiZDcsIDB4MGJkNywgMHgwYmU3LCAweDBiZjIsIDB4MGMwMSwgMHgwYzAzLCAweDBjMDUsIDB4MGMwYywgMHgwYzBlLCAweDBjMTAsIDB4MGMxMiwgMHgwYzI4LCAweDBjMmEsIDB4MGMzMywgMHgwYzM1LCAweDBjMzksIDB4MGM0MSwgMHgwYzQ0LCAweDBjNjAsIDB4MGM2MSwgMHgwYzY2LCAweDBjNmYsIDB4MGM4MiwgMHgwYzgzLCAweDBjODUsIDB4MGM4YywgMHgwYzhlLCAweDBjOTAsIDB4MGM5MiwgMHgwY2E4LCAweDBjYWEsIDB4MGNiMywgMHgwY2I1LCAweDBjYjksIDB4MGNiZSwgMHgwY2JlLCAweDBjYzAsIDB4MGNjNCwgMHgwY2M3LCAweDBjYzgsIDB4MGNjYSwgMHgwY2NiLCAweDBjZDUsIDB4MGNkNiwgMHgwY2RlLCAweDBjZGUsIDB4MGNlMCwgMHgwY2UxLCAweDBjZTYsIDB4MGNlZiwgMHgwZDAyLCAweDBkMDMsIDB4MGQwNSwgMHgwZDBjLCAweDBkMGUsIDB4MGQxMCwgMHgwZDEyLCAweDBkMjgsIDB4MGQyYSwgMHgwZDM5LCAweDBkM2UsIDB4MGQ0MCwgMHgwZDQ2LCAweDBkNDgsIDB4MGQ0YSwgMHgwZDRjLCAweDBkNTcsIDB4MGQ1NywgMHgwZDYwLCAweDBkNjEsIDB4MGQ2NiwgMHgwZDZmLCAweDBkODIsIDB4MGQ4MywgMHgwZDg1LCAweDBkOTYsIDB4MGQ5YSwgMHgwZGIxLCAweDBkYjMsIDB4MGRiYiwgMHgwZGJkLCAweDBkYmQsIDB4MGRjMCwgMHgwZGM2LCAweDBkY2YsIDB4MGRkMSwgMHgwZGQ4LCAweDBkZGYsIDB4MGRmMiwgMHgwZGY0LCAweDBlMDEsIDB4MGUzMCwgMHgwZTMyLCAweDBlMzMsIDB4MGU0MCwgMHgwZTQ2LCAweDBlNGYsIDB4MGU1YiwgMHgwZTgxLCAweDBlODIsIDB4MGU4NCwgMHgwZTg0LCAweDBlODcsIDB4MGU4OCwgMHgwZThhLCAweDBlOGEsIDB4MGU4ZCwgMHgwZThkLCAweDBlOTQsIDB4MGU5NywgMHgwZTk5LCAweDBlOWYsIDB4MGVhMSwgMHgwZWEzLCAweDBlYTUsIDB4MGVhNSwgMHgwZWE3LCAweDBlYTcsIDB4MGVhYSwgMHgwZWFiLCAweDBlYWQsIDB4MGViMCwgMHgwZWIyLCAweDBlYjMsIDB4MGViZCwgMHgwZWJkLCAweDBlYzAsIDB4MGVjNCwgMHgwZWM2LCAweDBlYzYsIDB4MGVkMCwgMHgwZWQ5LCAweDBlZGMsIDB4MGVkZCwgMHgwZjAwLCAweDBmMTcsIDB4MGYxYSwgMHgwZjM0LCAweDBmMzYsIDB4MGYzNiwgMHgwZjM4LCAweDBmMzgsIDB4MGYzZSwgMHgwZjQ3LCAweDBmNDksIDB4MGY2YSwgMHgwZjdmLCAweDBmN2YsIDB4MGY4NSwgMHgwZjg1LCAweDBmODgsIDB4MGY4YiwgMHgwZmJlLCAweDBmYzUsIDB4MGZjNywgMHgwZmNjLCAweDBmY2YsIDB4MGZjZiwgMHgxMDAwLCAweDEwMjEsIDB4MTAyMywgMHgxMDI3LCAweDEwMjksIDB4MTAyYSwgMHgxMDJjLCAweDEwMmMsIDB4MTAzMSwgMHgxMDMxLCAweDEwMzgsIDB4MTAzOCwgMHgxMDQwLCAweDEwNTcsIDB4MTBhMCwgMHgxMGM1LCAweDEwZDAsIDB4MTBmOCwgMHgxMGZiLCAweDEwZmIsIDB4MTEwMCwgMHgxMTU5LCAweDExNWYsIDB4MTFhMiwgMHgxMWE4LCAweDExZjksIDB4MTIwMCwgMHgxMjA2LCAweDEyMDgsIDB4MTI0NiwgMHgxMjQ4LCAweDEyNDgsIDB4MTI0YSwgMHgxMjRkLCAweDEyNTAsIDB4MTI1NiwgMHgxMjU4LCAweDEyNTgsIDB4MTI1YSwgMHgxMjVkLCAweDEyNjAsIDB4MTI4NiwgMHgxMjg4LCAweDEyODgsIDB4MTI4YSwgMHgxMjhkLCAweDEyOTAsIDB4MTJhZSwgMHgxMmIwLCAweDEyYjAsIDB4MTJiMiwgMHgxMmI1LCAweDEyYjgsIDB4MTJiZSwgMHgxMmMwLCAweDEyYzAsIDB4MTJjMiwgMHgxMmM1LCAweDEyYzgsIDB4MTJjZSwgMHgxMmQwLCAweDEyZDYsIDB4MTJkOCwgMHgxMmVlLCAweDEyZjAsIDB4MTMwZSwgMHgxMzEwLCAweDEzMTAsIDB4MTMxMiwgMHgxMzE1LCAweDEzMTgsIDB4MTMxZSwgMHgxMzIwLCAweDEzNDYsIDB4MTM0OCwgMHgxMzVhLCAweDEzNjEsIDB4MTM3YywgMHgxM2EwLCAweDEzZjQsIDB4MTQwMSwgMHgxNjc2LCAweDE2ODEsIDB4MTY5YSwgMHgxNmEwLCAweDE2ZjAsIDB4MTcwMCwgMHgxNzBjLCAweDE3MGUsIDB4MTcxMSwgMHgxNzIwLCAweDE3MzEsIDB4MTczNSwgMHgxNzM2LCAweDE3NDAsIDB4MTc1MSwgMHgxNzYwLCAweDE3NmMsIDB4MTc2ZSwgMHgxNzcwLCAweDE3ODAsIDB4MTdiNiwgMHgxN2JlLCAweDE3YzUsIDB4MTdjNywgMHgxN2M4LCAweDE3ZDQsIDB4MTdkYSwgMHgxN2RjLCAweDE3ZGMsIDB4MTdlMCwgMHgxN2U5LCAweDE4MTAsIDB4MTgxOSwgMHgxODIwLCAweDE4NzcsIDB4MTg4MCwgMHgxOGE4LCAweDFlMDAsIDB4MWU5YiwgMHgxZWEwLCAweDFlZjksIDB4MWYwMCwgMHgxZjE1LCAweDFmMTgsIDB4MWYxZCwgMHgxZjIwLCAweDFmNDUsIDB4MWY0OCwgMHgxZjRkLCAweDFmNTAsIDB4MWY1NywgMHgxZjU5LCAweDFmNTksIDB4MWY1YiwgMHgxZjViLCAweDFmNWQsIDB4MWY1ZCwgMHgxZjVmLCAweDFmN2QsIDB4MWY4MCwgMHgxZmI0LCAweDFmYjYsIDB4MWZiYywgMHgxZmJlLCAweDFmYmUsIDB4MWZjMiwgMHgxZmM0LCAweDFmYzYsIDB4MWZjYywgMHgxZmQwLCAweDFmZDMsIDB4MWZkNiwgMHgxZmRiLCAweDFmZTAsIDB4MWZlYywgMHgxZmYyLCAweDFmZjQsIDB4MWZmNiwgMHgxZmZjLCAweDIwMGUsIDB4MjAwZSwgMHgyMDcxLCAweDIwNzEsIDB4MjA3ZiwgMHgyMDdmLCAweDIxMDIsIDB4MjEwMiwgMHgyMTA3LCAweDIxMDcsIDB4MjEwYSwgMHgyMTEzLCAweDIxMTUsIDB4MjExNSwgMHgyMTE5LCAweDIxMWQsIDB4MjEyNCwgMHgyMTI0LCAweDIxMjYsIDB4MjEyNiwgMHgyMTI4LCAweDIxMjgsIDB4MjEyYSwgMHgyMTJkLCAweDIxMmYsIDB4MjEzMSwgMHgyMTMzLCAweDIxMzksIDB4MjEzZCwgMHgyMTNmLCAweDIxNDUsIDB4MjE0OSwgMHgyMTYwLCAweDIxODMsIDB4MjMzNiwgMHgyMzdhLCAweDIzOTUsIDB4MjM5NSwgMHgyNDljLCAweDI0ZTksIDB4MzAwNSwgMHgzMDA3LCAweDMwMjEsIDB4MzAyOSwgMHgzMDMxLCAweDMwMzUsIDB4MzAzOCwgMHgzMDNjLCAweDMwNDEsIDB4MzA5NiwgMHgzMDlkLCAweDMwOWYsIDB4MzBhMSwgMHgzMGZhLCAweDMwZmMsIDB4MzBmZiwgMHgzMTA1LCAweDMxMmMsIDB4MzEzMSwgMHgzMThlLCAweDMxOTAsIDB4MzFiNywgMHgzMWYwLCAweDMyMWMsIDB4MzIyMCwgMHgzMjQzLCAweDMyNjAsIDB4MzI3YiwgMHgzMjdmLCAweDMyYjAsIDB4MzJjMCwgMHgzMmNiLCAweDMyZDAsIDB4MzJmZSwgMHgzMzAwLCAweDMzNzYsIDB4MzM3YiwgMHgzM2RkLCAweDMzZTAsIDB4MzNmZSwgMHgzNDAwLCAweDRkYjUsIDB4NGUwMCwgMHg5ZmE1LCAweGEwMDAsIDB4YTQ4YywgMHhhYzAwLCAweGQ3YTMsIDB4ZDgwMCwgMHhmYTJkLCAweGZhMzAsIDB4ZmE2YSwgMHhmYjAwLCAweGZiMDYsIDB4ZmIxMywgMHhmYjE3LCAweGZmMjEsIDB4ZmYzYSwgMHhmZjQxLCAweGZmNWEsIDB4ZmY2NiwgMHhmZmJlLCAweGZmYzIsIDB4ZmZjNywgMHhmZmNhLCAweGZmY2YsIDB4ZmZkMiwgMHhmZmQ3LCAweGZmZGEsIDB4ZmZkYywgMHgxMDMwMCwgMHgxMDMxZSwgMHgxMDMyMCwgMHgxMDMyMywgMHgxMDMzMCwgMHgxMDM0YSwgMHgxMDQwMCwgMHgxMDQyNSwgMHgxMDQyOCwgMHgxMDQ0ZCwgMHgxZDAwMCwgMHgxZDBmNSwgMHgxZDEwMCwgMHgxZDEyNiwgMHgxZDEyYSwgMHgxZDE2NiwgMHgxZDE2YSwgMHgxZDE3MiwgMHgxZDE4MywgMHgxZDE4NCwgMHgxZDE4YywgMHgxZDFhOSwgMHgxZDFhZSwgMHgxZDFkZCwgMHgxZDQwMCwgMHgxZDQ1NCwgMHgxZDQ1NiwgMHgxZDQ5YywgMHgxZDQ5ZSwgMHgxZDQ5ZiwgMHgxZDRhMiwgMHgxZDRhMiwgMHgxZDRhNSwgMHgxZDRhNiwgMHgxZDRhOSwgMHgxZDRhYywgMHgxZDRhZSwgMHgxZDRiOSwgMHgxZDRiYiwgMHgxZDRiYiwgMHgxZDRiZCwgMHgxZDRjMCwgMHgxZDRjMiwgMHgxZDRjMywgMHgxZDRjNSwgMHgxZDUwNSwgMHgxZDUwNywgMHgxZDUwYSwgMHgxZDUwZCwgMHgxZDUxNCwgMHgxZDUxNiwgMHgxZDUxYywgMHgxZDUxZSwgMHgxZDUzOSwgMHgxZDUzYiwgMHgxZDUzZSwgMHgxZDU0MCwgMHgxZDU0NCwgMHgxZDU0NiwgMHgxZDU0NiwgMHgxZDU0YSwgMHgxZDU1MCwgMHgxZDU1MiwgMHgxZDZhMywgMHgxZDZhOCwgMHgxZDdjOSwgMHgyMDAwMCwgMHgyYTZkNiwgMHgyZjgwMCwgMHgyZmExZCwgMHhmMDAwMCwgMHhmZmZmZCwgMHgxMDAwMDAsIDB4MTBmZmZkXTtcbi8vIHByZXR0aWVyLWlnbm9yZS1lbmRcblxuY29uc3QgaXNCaWRpcmVjdGlvbmFsTCA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3RlciwgYmlkaXJlY3Rpb25hbF9sKTtcblxuLy8gMi4xLiAgTWFwcGluZ1xuXG4vKipcclxuICogbm9uLUFTQ0lJIHNwYWNlIGNoYXJhY3RlcnMgW1N0cmluZ1ByZXAsIEMuMS4yXSB0aGF0IGNhbiBiZVxyXG4gKiBtYXBwZWQgdG8gU1BBQ0UgKFUrMDAyMClcclxuICovXG5jb25zdCBtYXBwaW5nMnNwYWNlID0gaXNOb25BU0NJSVNwYWNlQ2hhcmFjdGVyO1xuXG4vKipcclxuICogdGhlIFwiY29tbW9ubHkgbWFwcGVkIHRvIG5vdGhpbmdcIiBjaGFyYWN0ZXJzIFtTdHJpbmdQcmVwLCBCLjFdXHJcbiAqIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBub3RoaW5nLlxyXG4gKi9cbmNvbnN0IG1hcHBpbmcybm90aGluZyA9IGlzQ29tbW9ubHlNYXBwZWRUb05vdGhpbmc7XG5cbi8vIHV0aWxzXG5jb25zdCBnZXRDb2RlUG9pbnQgPSBjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApO1xuY29uc3QgZmlyc3QgPSB4ID0+IHhbMF07XG5jb25zdCBsYXN0ID0geCA9PiB4W3gubGVuZ3RoIC0gMV07XG5cbi8qKlxyXG4gKiBDb252ZXJ0IHByb3ZpZGVkIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIFVuaWNvZGUgQ29kZSBQb2ludHMuXHJcbiAqIEJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTQwOTE2NS8xNTU2MjQ5XHJcbiAqIGFuZCBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9jb2RlLXBvaW50LWF0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcclxuICogQHJldHVybnMge251bWJlcltdfVxyXG4gKi9cbmZ1bmN0aW9uIHRvQ29kZVBvaW50cyhpbnB1dCkge1xuICBjb25zdCBjb2RlcG9pbnRzID0gW107XG4gIGNvbnN0IHNpemUgPSBpbnB1dC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgY29uc3QgYmVmb3JlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYmVmb3JlID49IDB4ZDgwMCAmJiBiZWZvcmUgPD0gMHhkYmZmICYmIHNpemUgPiBpICsgMSkge1xuICAgICAgY29uc3QgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKG5leHQgPj0gMHhkYzAwICYmIG5leHQgPD0gMHhkZmZmKSB7XG4gICAgICAgIGNvZGVwb2ludHMucHVzaCgoYmVmb3JlIC0gMHhkODAwKSAqIDB4NDAwICsgbmV4dCAtIDB4ZGMwMCArIDB4MTAwMDApO1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2RlcG9pbnRzLnB1c2goYmVmb3JlKTtcbiAgfVxuICByZXR1cm4gY29kZXBvaW50cztcbn1cblxuLyoqXHJcbiAqIFNBU0xwcmVwLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICogQHBhcmFtIHtib29sZWFufSBvcHRzLmFsbG93VW5hc3NpZ25lZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cbmZ1bmN0aW9uIHNhc2xwcmVwKGlucHV0KSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzdHJpbmcuJyk7XG4gIH1cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIDEuIE1hcFxuICBjb25zdCBtYXBwZWRfaW5wdXQgPSB0b0NvZGVQb2ludHMoaW5wdXQpXG4gIC8vIDEuMSBtYXBwaW5nIHRvIHNwYWNlXG4gIC5tYXAoY2hhcmFjdGVyID0+IG1hcHBpbmcyc3BhY2UoY2hhcmFjdGVyKSA/IDB4MjAgOiBjaGFyYWN0ZXIpXG4gIC8vIDEuMiBtYXBwaW5nIHRvIG5vdGhpbmdcbiAgLmZpbHRlcihjaGFyYWN0ZXIgPT4gIW1hcHBpbmcybm90aGluZyhjaGFyYWN0ZXIpKTtcblxuICAvLyAyLiBOb3JtYWxpemVcbiAgY29uc3Qgbm9ybWFsaXplZF9pbnB1dCA9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIG1hcHBlZF9pbnB1dCkubm9ybWFsaXplKCdORktDJyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRfbWFwID0gdG9Db2RlUG9pbnRzKG5vcm1hbGl6ZWRfaW5wdXQpO1xuXG4gIC8vIDMuIFByb2hpYml0XG4gIGNvbnN0IGhhc1Byb2hpYml0ZWQgPSBub3JtYWxpemVkX21hcC5zb21lKGlzUHJvaGliaXRlZENoYXJhY3Rlcik7XG4gIGlmIChoYXNQcm9oaWJpdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm9oaWJpdGVkIGNoYXJhY3Rlciwgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MDEzI3NlY3Rpb24tMi4zJyk7XG4gIH1cblxuICAvLyBVbmFzc2lnbmVkIENvZGUgUG9pbnRzXG4gIGlmIChvcHRzLmFsbG93VW5hc3NpZ25lZCAhPT0gdHJ1ZSkge1xuICAgIGNvbnN0IGhhc1VuYXNzaWduZWQgPSBub3JtYWxpemVkX21hcC5zb21lKGlzVW5hc3NpZ25lZENvZGVQb2ludCk7XG4gICAgaWYgKGhhc1VuYXNzaWduZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hc3NpZ25lZCBjb2RlIHBvaW50LCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQwMTMjc2VjdGlvbi0yLjUnKTtcbiAgICB9XG4gIH1cblxuICAvLyA0LiBjaGVjayBiaWRpXG5cbiAgY29uc3QgaGFzQmlkaVJBTCA9IG5vcm1hbGl6ZWRfbWFwLnNvbWUoaXNCaWRpcmVjdGlvbmFsUkFMKTtcbiAgY29uc3QgaGFzQmlkaUwgPSBub3JtYWxpemVkX21hcC5zb21lKGlzQmlkaXJlY3Rpb25hbEwpO1xuXG4gIC8vIDQuMSBJZiBhIHN0cmluZyBjb250YWlucyBhbnkgUmFuZEFMQ2F0IGNoYXJhY3RlciwgdGhlIHN0cmluZyBNVVNUIE5PVFxuICAvLyBjb250YWluIGFueSBMQ2F0IGNoYXJhY3Rlci5cbiAgaWYgKGhhc0JpZGlSQUwgJiYgaGFzQmlkaUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBtdXN0IG5vdCBjb250YWluIFJhbmRBTENhdCBhbmQgTENhdCBhdCB0aGUgc2FtZSB0aW1lLCcgKyAnIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNzZWN0aW9uLTYnKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIDQuMiBJZiBhIHN0cmluZyBjb250YWlucyBhbnkgUmFuZEFMQ2F0IGNoYXJhY3RlciwgYSBSYW5kQUxDYXRcclxuICAgKiBjaGFyYWN0ZXIgTVVTVCBiZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcsIGFuZCBhXHJcbiAgICogUmFuZEFMQ2F0IGNoYXJhY3RlciBNVVNUIGJlIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLlxyXG4gICAqL1xuXG4gIGNvbnN0IGlzRmlyc3RCaWRpUkFMID0gaXNCaWRpcmVjdGlvbmFsUkFMKGdldENvZGVQb2ludChmaXJzdChub3JtYWxpemVkX2lucHV0KSkpO1xuICBjb25zdCBpc0xhc3RCaWRpUkFMID0gaXNCaWRpcmVjdGlvbmFsUkFMKGdldENvZGVQb2ludChsYXN0KG5vcm1hbGl6ZWRfaW5wdXQpKSk7XG4gIGlmIChoYXNCaWRpUkFMICYmICEoaXNGaXJzdEJpZGlSQUwgJiYgaXNMYXN0QmlkaVJBTCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZGlyZWN0aW9uYWwgUmFuZEFMQ2F0IGNoYXJhY3RlciBtdXN0IGJlIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QnICsgJyBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZywgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I3NlY3Rpb24tNicpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkX2lucHV0O1xufVxuXG4vKlxyXG4gICBQREZTZWN1cml0eSAtIHJlcHJlc2VudHMgUERGIHNlY3VyaXR5IHNldHRpbmdzXHJcbiAgIEJ5IFlhbmcgTGl1IDxoaUB6ZXNpay5jb20+XHJcbiAqL1xuY2xhc3MgUERGU2VjdXJpdHkge1xuICBzdGF0aWMgZ2VuZXJhdGVGaWxlSUQoKSB7XG4gICAgbGV0IGluZm8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBpbmZvU3RyID0gYCR7aW5mby5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpfVxcbmA7XG4gICAgZm9yIChsZXQga2V5IGluIGluZm8pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIGlmICghaW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaW5mb1N0ciArPSBgJHtrZXl9OiAke2luZm9ba2V5XS52YWx1ZU9mKCl9XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmRBcnJheVRvQnVmZmVyKENyeXB0b0pTLk1ENShpbmZvU3RyKSk7XG4gIH1cbiAgc3RhdGljIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KGJ5dGVzKSB7XG4gICAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKGJ5dGVzKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5vd25lclBhc3N3b3JkICYmICFvcHRpb25zLnVzZXJQYXNzd29yZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGU2VjdXJpdHkoZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGlmICghb3B0aW9ucy5vd25lclBhc3N3b3JkICYmICFvcHRpb25zLnVzZXJQYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIG93bmVyIHBhc3N3b3JkIGFuZCB1c2VyIHBhc3N3b3JkIGlzIGRlZmluZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb24ob3B0aW9ucyk7XG4gIH1cbiAgX3NldHVwRW5jcnlwdGlvbihvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLnBkZlZlcnNpb24pIHtcbiAgICAgIGNhc2UgJzEuNCc6XG4gICAgICBjYXNlICcxLjUnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuNic6XG4gICAgICBjYXNlICcxLjcnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuN2V4dDMnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSA1O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBlbmNEaWN0ID0ge1xuICAgICAgRmlsdGVyOiAnU3RhbmRhcmQnXG4gICAgfTtcbiAgICBzd2l0Y2ggKHRoaXMudmVyc2lvbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAyOlxuICAgICAgY2FzZSA0OlxuICAgICAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb25WMVYyVjQodGhpcy52ZXJzaW9uLCBlbmNEaWN0LCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHRoaXMuX3NldHVwRW5jcnlwdGlvblY1KGVuY0RpY3QsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5kaWN0aW9uYXJ5ID0gdGhpcy5kb2N1bWVudC5yZWYoZW5jRGljdCk7XG4gIH1cbiAgX3NldHVwRW5jcnlwdGlvblYxVjJWNCh2LCBlbmNEaWN0LCBvcHRpb25zKSB7XG4gICAgbGV0IHIsIHBlcm1pc3Npb25zO1xuICAgIHN3aXRjaCAodikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByID0gMjtcbiAgICAgICAgdGhpcy5rZXlCaXRzID0gNDA7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMihvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSAzO1xuICAgICAgICB0aGlzLmtleUJpdHMgPSAxMjg7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMyhvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSA0O1xuICAgICAgICB0aGlzLmtleUJpdHMgPSAxMjg7XG4gICAgICAgIHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMyhvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZFVzZXJQYXNzd29yZCA9IHByb2Nlc3NQYXNzd29yZFIyUjNSNChvcHRpb25zLnVzZXJQYXNzd29yZCk7XG4gICAgY29uc3QgcGFkZGVkT3duZXJQYXNzd29yZCA9IG9wdGlvbnMub3duZXJQYXNzd29yZCA/IHByb2Nlc3NQYXNzd29yZFIyUjNSNChvcHRpb25zLm93bmVyUGFzc3dvcmQpIDogcGFkZGVkVXNlclBhc3N3b3JkO1xuICAgIGNvbnN0IG93bmVyUGFzc3dvcmRFbnRyeSA9IGdldE93bmVyUGFzc3dvcmRSMlIzUjQociwgdGhpcy5rZXlCaXRzLCBwYWRkZWRVc2VyUGFzc3dvcmQsIHBhZGRlZE93bmVyUGFzc3dvcmQpO1xuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSMlIzUjQociwgdGhpcy5rZXlCaXRzLCB0aGlzLmRvY3VtZW50Ll9pZCwgcGFkZGVkVXNlclBhc3N3b3JkLCBvd25lclBhc3N3b3JkRW50cnksIHBlcm1pc3Npb25zKTtcbiAgICBsZXQgdXNlclBhc3N3b3JkRW50cnk7XG4gICAgaWYgKHIgPT09IDIpIHtcbiAgICAgIHVzZXJQYXNzd29yZEVudHJ5ID0gZ2V0VXNlclBhc3N3b3JkUjIodGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSM1I0KHRoaXMuZG9jdW1lbnQuX2lkLCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgIH1cbiAgICBlbmNEaWN0LlYgPSB2O1xuICAgIGlmICh2ID49IDIpIHtcbiAgICAgIGVuY0RpY3QuTGVuZ3RoID0gdGhpcy5rZXlCaXRzO1xuICAgIH1cbiAgICBpZiAodiA9PT0gNCkge1xuICAgICAgZW5jRGljdC5DRiA9IHtcbiAgICAgICAgU3RkQ0Y6IHtcbiAgICAgICAgICBBdXRoRXZlbnQ6ICdEb2NPcGVuJyxcbiAgICAgICAgICBDRk06ICdBRVNWMicsXG4gICAgICAgICAgTGVuZ3RoOiB0aGlzLmtleUJpdHMgLyA4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbmNEaWN0LlN0bUYgPSAnU3RkQ0YnO1xuICAgICAgZW5jRGljdC5TdHJGID0gJ1N0ZENGJztcbiAgICB9XG4gICAgZW5jRGljdC5SID0gcjtcbiAgICBlbmNEaWN0Lk8gPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuVSA9IHdvcmRBcnJheVRvQnVmZmVyKHVzZXJQYXNzd29yZEVudHJ5KTtcbiAgICBlbmNEaWN0LlAgPSBwZXJtaXNzaW9ucztcbiAgfVxuICBfc2V0dXBFbmNyeXB0aW9uVjUoZW5jRGljdCwgb3B0aW9ucykge1xuICAgIHRoaXMua2V5Qml0cyA9IDI1NjtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zUjMob3B0aW9ucy5wZXJtaXNzaW9ucyk7XG4gICAgY29uc3QgcHJvY2Vzc2VkVXNlclBhc3N3b3JkID0gcHJvY2Vzc1Bhc3N3b3JkUjUob3B0aW9ucy51c2VyUGFzc3dvcmQpO1xuICAgIGNvbnN0IHByb2Nlc3NlZE93bmVyUGFzc3dvcmQgPSBvcHRpb25zLm93bmVyUGFzc3dvcmQgPyBwcm9jZXNzUGFzc3dvcmRSNShvcHRpb25zLm93bmVyUGFzc3dvcmQpIDogcHJvY2Vzc2VkVXNlclBhc3N3b3JkO1xuICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSNShQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgY29uc3QgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSNShwcm9jZXNzZWRVc2VyUGFzc3dvcmQsIFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICBjb25zdCB1c2VyS2V5U2FsdCA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKHVzZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgIGNvbnN0IHVzZXJFbmNyeXB0aW9uS2V5RW50cnkgPSBnZXRVc2VyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgdXNlcktleVNhbHQsIHRoaXMuZW5jcnlwdGlvbktleSk7XG4gICAgY29uc3Qgb3duZXJQYXNzd29yZEVudHJ5ID0gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgY29uc3Qgb3duZXJLZXlTYWx0ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3duZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgIGNvbnN0IG93bmVyRW5jcnlwdGlvbktleUVudHJ5ID0gZ2V0T3duZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgb3duZXJLZXlTYWx0LCB1c2VyUGFzc3dvcmRFbnRyeSwgdGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICBjb25zdCBwZXJtc0VudHJ5ID0gZ2V0RW5jcnlwdGVkUGVybWlzc2lvbnNSNShwZXJtaXNzaW9ucywgdGhpcy5lbmNyeXB0aW9uS2V5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgZW5jRGljdC5WID0gNTtcbiAgICBlbmNEaWN0Lkxlbmd0aCA9IHRoaXMua2V5Qml0cztcbiAgICBlbmNEaWN0LkNGID0ge1xuICAgICAgU3RkQ0Y6IHtcbiAgICAgICAgQXV0aEV2ZW50OiAnRG9jT3BlbicsXG4gICAgICAgIENGTTogJ0FFU1YzJyxcbiAgICAgICAgTGVuZ3RoOiB0aGlzLmtleUJpdHMgLyA4XG4gICAgICB9XG4gICAgfTtcbiAgICBlbmNEaWN0LlN0bUYgPSAnU3RkQ0YnO1xuICAgIGVuY0RpY3QuU3RyRiA9ICdTdGRDRic7XG4gICAgZW5jRGljdC5SID0gNTtcbiAgICBlbmNEaWN0Lk8gPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuT0UgPSB3b3JkQXJyYXlUb0J1ZmZlcihvd25lckVuY3J5cHRpb25LZXlFbnRyeSk7XG4gICAgZW5jRGljdC5VID0gd29yZEFycmF5VG9CdWZmZXIodXNlclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuVUUgPSB3b3JkQXJyYXlUb0J1ZmZlcih1c2VyRW5jcnlwdGlvbktleUVudHJ5KTtcbiAgICBlbmNEaWN0LlAgPSBwZXJtaXNzaW9ucztcbiAgICBlbmNEaWN0LlBlcm1zID0gd29yZEFycmF5VG9CdWZmZXIocGVybXNFbnRyeSk7XG4gIH1cbiAgZ2V0RW5jcnlwdEZuKG9iaiwgZ2VuKSB7XG4gICAgbGV0IGRpZ2VzdDtcbiAgICBpZiAodGhpcy52ZXJzaW9uIDwgNSkge1xuICAgICAgZGlnZXN0ID0gdGhpcy5lbmNyeXB0aW9uS2V5LmNsb25lKCkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsob2JqICYgMHhmZikgPDwgMjQgfCAob2JqICYgMHhmZjAwKSA8PCA4IHwgb2JqID4+IDggJiAweGZmMDAgfCBnZW4gJiAweGZmLCAoZ2VuICYgMHhmZjAwKSA8PCAxNl0sIDUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSB8fCB0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGxldCBrZXkgPSBDcnlwdG9KUy5NRDUoZGlnZXN0KTtcbiAgICAgIGtleS5zaWdCeXRlcyA9IE1hdGgubWluKDE2LCB0aGlzLmtleUJpdHMgLyA4ICsgNSk7XG4gICAgICByZXR1cm4gYnVmZmVyID0+IHdvcmRBcnJheVRvQnVmZmVyKENyeXB0b0pTLlJDNC5lbmNyeXB0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGJ1ZmZlciksIGtleSkuY2lwaGVydGV4dCk7XG4gICAgfVxuICAgIGxldCBrZXk7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gNCkge1xuICAgICAga2V5ID0gQ3J5cHRvSlMuTUQ1KGRpZ2VzdC5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4NzM0MTZjNTRdLCA0KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSB0aGlzLmVuY3J5cHRpb25LZXk7XG4gICAgfVxuICAgIGNvbnN0IGl2ID0gUERGU2VjdXJpdHkuZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoMTYpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzNyxcbiAgICAgIGl2XG4gICAgfTtcbiAgICByZXR1cm4gYnVmZmVyID0+IHdvcmRBcnJheVRvQnVmZmVyKGl2LmNsb25lKCkuY29uY2F0KENyeXB0b0pTLkFFUy5lbmNyeXB0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGJ1ZmZlciksIGtleSwgb3B0aW9ucykuY2lwaGVydGV4dCkpO1xuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBlcm1pc3Npb25zUjIoKSB7XG4gIGxldCBwZXJtaXNzaW9uT2JqZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IHBlcm1pc3Npb25zID0gMHhmZmZmZmZjMCA+PiAwO1xuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAwMTAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0Lm1vZGlmeWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAxMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmNvcHlpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAxMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5hbm5vdGF0aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAxMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnNSMygpIHtcbiAgbGV0IHBlcm1pc3Npb25PYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgcGVybWlzc2lvbnMgPSAweGZmZmZmMGMwID4+IDA7XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LnByaW50aW5nID09PSAnbG93UmVzb2x1dGlvbicpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAwMDEwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZyA9PT0gJ2hpZ2hSZXNvbHV0aW9uJykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMTAwMDAwMDAwMTAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0Lm1vZGlmeWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAxMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmNvcHlpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDAxMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5hbm5vdGF0aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAxMDAwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuZmlsbGluZ0Zvcm1zKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAxMDAwMDAwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuY29udGVudEFjY2Vzc2liaWxpdHkpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMTAwMDAwMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5kb2N1bWVudEFzc2VtYmx5KSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMTAwMDAwMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuZnVuY3Rpb24gZ2V0VXNlclBhc3N3b3JkUjIoZW5jcnlwdGlvbktleSkge1xuICByZXR1cm4gQ3J5cHRvSlMuUkM0LmVuY3J5cHQocHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCksIGVuY3J5cHRpb25LZXkpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBnZXRVc2VyUGFzc3dvcmRSM1I0KGRvY3VtZW50SWQsIGVuY3J5cHRpb25LZXkpIHtcbiAgY29uc3Qga2V5ID0gZW5jcnlwdGlvbktleS5jbG9uZSgpO1xuICBsZXQgY2lwaGVyID0gQ3J5cHRvSlMuTUQ1KHByb2Nlc3NQYXNzd29yZFIyUjNSNCgpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShkb2N1bWVudElkKSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICBjb25zdCB4b3JSb3VuZCA9IE1hdGguY2VpbChrZXkuc2lnQnl0ZXMgLyA0KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHhvclJvdW5kOyBqKyspIHtcbiAgICAgIGtleS53b3Jkc1tqXSA9IGVuY3J5cHRpb25LZXkud29yZHNbal0gXiAoaSB8IGkgPDwgOCB8IGkgPDwgMTYgfCBpIDw8IDI0KTtcbiAgICB9XG4gICAgY2lwaGVyID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQoY2lwaGVyLCBrZXkpLmNpcGhlcnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNpcGhlci5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpKTtcbn1cbmZ1bmN0aW9uIGdldE93bmVyUGFzc3dvcmRSMlIzUjQociwga2V5Qml0cywgcGFkZGVkVXNlclBhc3N3b3JkLCBwYWRkZWRPd25lclBhc3N3b3JkKSB7XG4gIGxldCBkaWdlc3QgPSBwYWRkZWRPd25lclBhc3N3b3JkO1xuICBsZXQgcm91bmQgPSByID49IDMgPyA1MSA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGRpZ2VzdCA9IENyeXB0b0pTLk1ENShkaWdlc3QpO1xuICB9XG4gIGNvbnN0IGtleSA9IGRpZ2VzdC5jbG9uZSgpO1xuICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgbGV0IGNpcGhlciA9IHBhZGRlZFVzZXJQYXNzd29yZDtcbiAgcm91bmQgPSByID49IDMgPyAyMCA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGNvbnN0IHhvclJvdW5kID0gTWF0aC5jZWlsKGtleS5zaWdCeXRlcyAvIDQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgeG9yUm91bmQ7IGorKykge1xuICAgICAga2V5LndvcmRzW2pdID0gZGlnZXN0LndvcmRzW2pdIF4gKGkgfCBpIDw8IDggfCBpIDw8IDE2IHwgaSA8PCAyNCk7XG4gICAgfVxuICAgIGNpcGhlciA9IENyeXB0b0pTLlJDNC5lbmNyeXB0KGNpcGhlciwga2V5KS5jaXBoZXJ0ZXh0O1xuICB9XG4gIHJldHVybiBjaXBoZXI7XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5UjJSM1I0KHIsIGtleUJpdHMsIGRvY3VtZW50SWQsIHBhZGRlZFVzZXJQYXNzd29yZCwgb3duZXJQYXNzd29yZEVudHJ5LCBwZXJtaXNzaW9ucykge1xuICBsZXQga2V5ID0gcGFkZGVkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KG93bmVyUGFzc3dvcmRFbnRyeSkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtsc2JGaXJzdFdvcmQocGVybWlzc2lvbnMpXSwgNCkpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShkb2N1bWVudElkKSk7XG4gIGNvbnN0IHJvdW5kID0gciA+PSAzID8gNTEgOiAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kOyBpKyspIHtcbiAgICBrZXkgPSBDcnlwdG9KUy5NRDUoa2V5KTtcbiAgICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZ2V0VXNlclBhc3N3b3JkUjUocHJvY2Vzc2VkVXNlclBhc3N3b3JkLCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICBjb25zdCB2YWxpZGF0aW9uU2FsdCA9IGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDgpO1xuICBjb25zdCBrZXlTYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHZhbGlkYXRpb25TYWx0KSkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQoa2V5U2FsdCk7XG59XG5mdW5jdGlvbiBnZXRVc2VyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgdXNlcktleVNhbHQsIGVuY3J5cHRpb25LZXkpIHtcbiAgY29uc3Qga2V5ID0gQ3J5cHRvSlMuU0hBMjU2KHByb2Nlc3NlZFVzZXJQYXNzd29yZC5jbG9uZSgpLmNvbmNhdCh1c2VyS2V5U2FsdCkpO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcsXG4gICAgaXY6IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKG51bGwsIDE2KVxuICB9O1xuICByZXR1cm4gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoZW5jcnlwdGlvbktleSwga2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICBjb25zdCB2YWxpZGF0aW9uU2FsdCA9IGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDgpO1xuICBjb25zdCBrZXlTYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkT3duZXJQYXNzd29yZC5jbG9uZSgpLmNvbmNhdCh2YWxpZGF0aW9uU2FsdCkuY29uY2F0KHVzZXJQYXNzd29yZEVudHJ5KSkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQoa2V5U2FsdCk7XG59XG5mdW5jdGlvbiBnZXRPd25lckVuY3J5cHRpb25LZXlSNShwcm9jZXNzZWRPd25lclBhc3N3b3JkLCBvd25lcktleVNhbHQsIHVzZXJQYXNzd29yZEVudHJ5LCBlbmNyeXB0aW9uS2V5KSB7XG4gIGNvbnN0IGtleSA9IENyeXB0b0pTLlNIQTI1Nihwcm9jZXNzZWRPd25lclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KG93bmVyS2V5U2FsdCkuY29uY2F0KHVzZXJQYXNzd29yZEVudHJ5KSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyxcbiAgICBpdjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpXG4gIH07XG4gIHJldHVybiBDcnlwdG9KUy5BRVMuZW5jcnlwdChlbmNyeXB0aW9uS2V5LCBrZXksIG9wdGlvbnMpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5UjUoZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkpIHtcbiAgcmV0dXJuIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDMyKTtcbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRlZFBlcm1pc3Npb25zUjUocGVybWlzc2lvbnMsIGVuY3J5cHRpb25LZXksIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KSB7XG4gIGNvbnN0IGNpcGhlciA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtsc2JGaXJzdFdvcmQocGVybWlzc2lvbnMpLCAweGZmZmZmZmZmLCAweDU0NjE2NDYyXSwgMTIpLmNvbmNhdChnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg0KSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZ1xuICB9O1xuICByZXR1cm4gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoY2lwaGVyLCBlbmNyeXB0aW9uS2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCkge1xuICBsZXQgcGFzc3dvcmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICBjb25zdCBvdXQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICBjb25zdCBsZW5ndGggPSBwYXNzd29yZC5sZW5ndGg7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiBpbmRleCA8IDMyKSB7XG4gICAgY29uc3QgY29kZSA9IHBhc3N3b3JkLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGlmIChjb2RlID4gMHhmZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBjb250YWlucyBvbmUgb3IgbW9yZSBpbnZhbGlkIGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuICAgIG91dFtpbmRleF0gPSBjb2RlO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgd2hpbGUgKGluZGV4IDwgMzIpIHtcbiAgICBvdXRbaW5kZXhdID0gUEFTU1dPUkRfUEFERElOR1tpbmRleCAtIGxlbmd0aF07XG4gICAgaW5kZXgrKztcbiAgfVxuICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3V0KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NQYXNzd29yZFI1KCkge1xuICBsZXQgcGFzc3dvcmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICBwYXNzd29yZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzYXNscHJlcChwYXNzd29yZCkpKTtcbiAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oMTI3LCBwYXNzd29yZC5sZW5ndGgpO1xuICBjb25zdCBvdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dFtpXSA9IHBhc3N3b3JkLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKG91dCk7XG59XG5mdW5jdGlvbiBsc2JGaXJzdFdvcmQoZGF0YSkge1xuICByZXR1cm4gKGRhdGEgJiAweGZmKSA8PCAyNCB8IChkYXRhICYgMHhmZjAwKSA8PCA4IHwgZGF0YSA+PiA4ICYgMHhmZjAwIHwgZGF0YSA+PiAyNCAmIDB4ZmY7XG59XG5mdW5jdGlvbiB3b3JkQXJyYXlUb0J1ZmZlcih3b3JkQXJyYXkpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZEFycmF5LnNpZ0J5dGVzOyBpKyspIHtcbiAgICBieXRlQXJyYXkucHVzaCh3b3JkQXJyYXkud29yZHNbTWF0aC5mbG9vcihpIC8gNCldID4+IDggKiAoMyAtIGkgJSA0KSAmIDB4ZmYpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShieXRlQXJyYXkpO1xufVxuY29uc3QgUEFTU1dPUkRfUEFERElORyA9IFsweDI4LCAweGJmLCAweDRlLCAweDVlLCAweDRlLCAweDc1LCAweDhhLCAweDQxLCAweDY0LCAweDAwLCAweDRlLCAweDU2LCAweGZmLCAweGZhLCAweDAxLCAweDA4LCAweDJlLCAweDJlLCAweDAwLCAweGI2LCAweGQwLCAweDY4LCAweDNlLCAweDgwLCAweDJmLCAweDBjLCAweGE5LCAweGZlLCAweDY0LCAweDUzLCAweDY5LCAweDdhXTtcblxuY29uc3Qge1xuICBudW1iZXJcbn0gPSBQREZPYmplY3Q7XG5jbGFzcyBQREZHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvYykge1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB0aGlzLmVtYmVkZGVkID0gZmFsc2U7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIH1cbiAgc3RvcChwb3MsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGNvbG9yID0gdGhpcy5kb2MuX25vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgICBpZiAodGhpcy5zdG9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VSR0InO1xuICAgICAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VDTVlLJztcbiAgICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3Igc3BhY2UnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NvbG9yU3BhY2UgPT09ICdEZXZpY2VSR0InICYmIGNvbG9yLmxlbmd0aCAhPT0gMyB8fCB0aGlzLl9jb2xvclNwYWNlID09PSAnRGV2aWNlQ01ZSycgJiYgY29sb3IubGVuZ3RoICE9PSA0IHx8IHRoaXMuX2NvbG9yU3BhY2UgPT09ICdEZXZpY2VHcmF5JyAmJiBjb2xvci5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGdyYWRpZW50IHN0b3BzIG11c3QgdXNlIHRoZSBzYW1lIGNvbG9yIHNwYWNlJyk7XG4gICAgfVxuICAgIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG4gICAgdGhpcy5zdG9wcy5wdXNoKFtwb3MsIGNvbG9yLCBvcGFjaXR5XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0VHJhbnNmb3JtKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVtYmVkKG0pIHtcbiAgICBsZXQgZm47XG4gICAgY29uc3Qgc3RvcHNMZW5ndGggPSB0aGlzLnN0b3BzLmxlbmd0aDtcbiAgICBpZiAoc3RvcHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWJlZGRlZCA9IHRydWU7XG4gICAgdGhpcy5tYXRyaXggPSBtO1xuXG4gICAgLy8gaWYgdGhlIGxhc3Qgc3RvcCBjb21lcyBiZWZvcmUgMTAwJSwgYWRkIGEgY29weSBhdCAxMDAlXG4gICAgY29uc3QgbGFzdCA9IHRoaXMuc3RvcHNbc3RvcHNMZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFswXSA8IDEpIHtcbiAgICAgIHRoaXMuc3RvcHMucHVzaChbMSwgbGFzdFsxXSwgbGFzdFsyXV0pO1xuICAgIH1cbiAgICBjb25zdCBib3VuZHMgPSBbXTtcbiAgICBjb25zdCBlbmNvZGUgPSBbXTtcbiAgICBjb25zdCBzdG9wcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcHNMZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGVuY29kZS5wdXNoKDAsIDEpO1xuICAgICAgaWYgKGkgKyAyICE9PSBzdG9wc0xlbmd0aCkge1xuICAgICAgICBib3VuZHMucHVzaCh0aGlzLnN0b3BzW2kgKyAxXVswXSk7XG4gICAgICB9XG4gICAgICBmbiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIEZ1bmN0aW9uVHlwZTogMixcbiAgICAgICAgRG9tYWluOiBbMCwgMV0sXG4gICAgICAgIEMwOiB0aGlzLnN0b3BzW2kgKyAwXVsxXSxcbiAgICAgICAgQzE6IHRoaXMuc3RvcHNbaSArIDFdWzFdLFxuICAgICAgICBOOiAxXG4gICAgICB9KTtcbiAgICAgIHN0b3BzLnB1c2goZm4pO1xuICAgICAgZm4uZW5kKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG9ubHkgdHdvIHN0b3BzLCB3ZSBkb24ndCBuZWVkIGEgc3RpdGNoaW5nIGZ1bmN0aW9uXG4gICAgaWYgKHN0b3BzTGVuZ3RoID09PSAxKSB7XG4gICAgICBmbiA9IHN0b3BzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIEZ1bmN0aW9uVHlwZTogMyxcbiAgICAgICAgLy8gc3RpdGNoaW5nIGZ1bmN0aW9uXG4gICAgICAgIERvbWFpbjogWzAsIDFdLFxuICAgICAgICBGdW5jdGlvbnM6IHN0b3BzLFxuICAgICAgICBCb3VuZHM6IGJvdW5kcyxcbiAgICAgICAgRW5jb2RlOiBlbmNvZGVcbiAgICAgIH0pO1xuICAgICAgZm4uZW5kKCk7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBgU2gkeysrdGhpcy5kb2MuX2dyYWRDb3VudH1gO1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyKGZuKTtcbiAgICBzaGFkZXIuZW5kKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICBUeXBlOiAnUGF0dGVybicsXG4gICAgICBQYXR0ZXJuVHlwZTogMixcbiAgICAgIFNoYWRpbmc6IHNoYWRlcixcbiAgICAgIE1hdHJpeDogdGhpcy5tYXRyaXgubWFwKG51bWJlcilcbiAgICB9KTtcbiAgICBwYXR0ZXJuLmVuZCgpO1xuICAgIGlmICh0aGlzLnN0b3BzLnNvbWUoc3RvcCA9PiBzdG9wWzJdIDwgMSkpIHtcbiAgICAgIGxldCBncmFkID0gdGhpcy5vcGFjaXR5R3JhZGllbnQoKTtcbiAgICAgIGdyYWQuX2NvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICBmb3IgKGxldCBzdG9wIG9mIHRoaXMuc3RvcHMpIHtcbiAgICAgICAgZ3JhZC5zdG9wKHN0b3BbMF0sIFtzdG9wWzJdXSk7XG4gICAgICB9XG4gICAgICBncmFkID0gZ3JhZC5lbWJlZCh0aGlzLm1hdHJpeCk7XG4gICAgICBjb25zdCBwYWdlQkJveCA9IFswLCAwLCB0aGlzLmRvYy5wYWdlLndpZHRoLCB0aGlzLmRvYy5wYWdlLmhlaWdodF07XG4gICAgICBjb25zdCBmb3JtID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnRm9ybScsXG4gICAgICAgIEZvcm1UeXBlOiAxLFxuICAgICAgICBCQm94OiBwYWdlQkJveCxcbiAgICAgICAgR3JvdXA6IHtcbiAgICAgICAgICBUeXBlOiAnR3JvdXAnLFxuICAgICAgICAgIFM6ICdUcmFuc3BhcmVuY3knLFxuICAgICAgICAgIENTOiAnRGV2aWNlR3JheSdcbiAgICAgICAgfSxcbiAgICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgICAgUHJvY1NldDogWydQREYnLCAnVGV4dCcsICdJbWFnZUInLCAnSW1hZ2VDJywgJ0ltYWdlSSddLFxuICAgICAgICAgIFBhdHRlcm46IHtcbiAgICAgICAgICAgIFNoMTogZ3JhZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3JtLndyaXRlKCcvUGF0dGVybiBjcyAvU2gxIHNjbicpO1xuICAgICAgZm9ybS5lbmQoYCR7cGFnZUJCb3guam9pbignICcpfSByZSBmYCk7XG4gICAgICBjb25zdCBnc3RhdGUgPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICBUeXBlOiAnRXh0R1N0YXRlJyxcbiAgICAgICAgU01hc2s6IHtcbiAgICAgICAgICBUeXBlOiAnTWFzaycsXG4gICAgICAgICAgUzogJ0x1bWlub3NpdHknLFxuICAgICAgICAgIEc6IGZvcm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBnc3RhdGUuZW5kKCk7XG4gICAgICBjb25zdCBvcGFjaXR5UGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIFR5cGU6ICdQYXR0ZXJuJyxcbiAgICAgICAgUGF0dGVyblR5cGU6IDEsXG4gICAgICAgIFBhaW50VHlwZTogMSxcbiAgICAgICAgVGlsaW5nVHlwZTogMixcbiAgICAgICAgQkJveDogcGFnZUJCb3gsXG4gICAgICAgIFhTdGVwOiBwYWdlQkJveFsyXSxcbiAgICAgICAgWVN0ZXA6IHBhZ2VCQm94WzNdLFxuICAgICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ10sXG4gICAgICAgICAgUGF0dGVybjoge1xuICAgICAgICAgICAgU2gxOiBwYXR0ZXJuXG4gICAgICAgICAgfSxcbiAgICAgICAgICBFeHRHU3RhdGU6IHtcbiAgICAgICAgICAgIEdzMTogZ3N0YXRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9wYWNpdHlQYXR0ZXJuLndyaXRlKCcvR3MxIGdzIC9QYXR0ZXJuIGNzIC9TaDEgc2NuJyk7XG4gICAgICBvcGFjaXR5UGF0dGVybi5lbmQoYCR7cGFnZUJCb3guam9pbignICcpfSByZSBmYCk7XG4gICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gb3BhY2l0eVBhdHRlcm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9jLnBhZ2UucGF0dGVybnNbdGhpcy5pZF0gPSBwYXR0ZXJuO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBhcHBseShzdHJva2UpIHtcbiAgICAvLyBhcHBseSBncmFkaWVudCB0cmFuc2Zvcm0gdG8gZXhpc3RpbmcgZG9jdW1lbnQgY3RtXG4gICAgY29uc3QgW20wLCBtMSwgbTIsIG0zLCBtNCwgbTVdID0gdGhpcy5kb2MuX2N0bTtcbiAgICBjb25zdCBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldID0gdGhpcy50cmFuc2Zvcm07XG4gICAgY29uc3QgbSA9IFttMCAqIG0xMSArIG0yICogbTEyLCBtMSAqIG0xMSArIG0zICogbTEyLCBtMCAqIG0yMSArIG0yICogbTIyLCBtMSAqIG0yMSArIG0zICogbTIyLCBtMCAqIGR4ICsgbTIgKiBkeSArIG00LCBtMSAqIGR4ICsgbTMgKiBkeSArIG01XTtcbiAgICBpZiAoIXRoaXMuZW1iZWRkZWQgfHwgbS5qb2luKCcgJykgIT09IHRoaXMubWF0cml4LmpvaW4oJyAnKSkge1xuICAgICAgdGhpcy5lbWJlZChtKTtcbiAgICB9XG4gICAgdGhpcy5kb2MuX3NldENvbG9yU3BhY2UoJ1BhdHRlcm4nLCBzdHJva2UpO1xuICAgIGNvbnN0IG9wID0gc3Ryb2tlID8gJ1NDTicgOiAnc2NuJztcbiAgICByZXR1cm4gdGhpcy5kb2MuYWRkQ29udGVudChgLyR7dGhpcy5pZH0gJHtvcH1gKTtcbiAgfVxufVxuY2xhc3MgUERGTGluZWFyR3JhZGllbnQgZXh0ZW5kcyBQREZHcmFkaWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvYywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBzdXBlcihkb2MpO1xuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcbiAgfVxuICBzaGFkZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5kb2MucmVmKHtcbiAgICAgIFNoYWRpbmdUeXBlOiAyLFxuICAgICAgQ29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSxcbiAgICAgIENvb3JkczogW3RoaXMueDEsIHRoaXMueTEsIHRoaXMueDIsIHRoaXMueTJdLFxuICAgICAgRnVuY3Rpb246IGZuLFxuICAgICAgRXh0ZW5kOiBbdHJ1ZSwgdHJ1ZV1cbiAgICB9KTtcbiAgfVxuICBvcGFjaXR5R3JhZGllbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQREZMaW5lYXJHcmFkaWVudCh0aGlzLmRvYywgdGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiwgdGhpcy55Mik7XG4gIH1cbn1cbmNsYXNzIFBERlJhZGlhbEdyYWRpZW50IGV4dGVuZHMgUERGR3JhZGllbnQge1xuICBjb25zdHJ1Y3Rvcihkb2MsIHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIpIHtcbiAgICBzdXBlcihkb2MpO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy5yMSA9IHIxO1xuICAgIHRoaXMueDIgPSB4MjtcbiAgICB0aGlzLnkyID0geTI7XG4gICAgdGhpcy5yMiA9IHIyO1xuICB9XG4gIHNoYWRlcihmbikge1xuICAgIHJldHVybiB0aGlzLmRvYy5yZWYoe1xuICAgICAgU2hhZGluZ1R5cGU6IDMsXG4gICAgICBDb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLFxuICAgICAgQ29vcmRzOiBbdGhpcy54MSwgdGhpcy55MSwgdGhpcy5yMSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yMl0sXG4gICAgICBGdW5jdGlvbjogZm4sXG4gICAgICBFeHRlbmQ6IFt0cnVlLCB0cnVlXVxuICAgIH0pO1xuICB9XG4gIG9wYWNpdHlHcmFkaWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFBERlJhZGlhbEdyYWRpZW50KHRoaXMuZG9jLCB0aGlzLngxLCB0aGlzLnkxLCB0aGlzLnIxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnIyKTtcbiAgfVxufVxudmFyIEdyYWRpZW50ID0ge1xuICBQREZHcmFkaWVudCxcbiAgUERGTGluZWFyR3JhZGllbnQsXG4gIFBERlJhZGlhbEdyYWRpZW50XG59O1xuXG4vKlxyXG5QREYgdGlsaW5nIHBhdHRlcm4gc3VwcG9ydC4gVW5jb2xvcmVkIG9ubHkuXHJcbiAqL1xuXG5jb25zdCB1bmRlcmx5aW5nQ29sb3JTcGFjZXMgPSBbJ0RldmljZUNNWUsnLCAnRGV2aWNlUkdCJ107XG5jbGFzcyBQREZUaWxpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoZG9jLCBiQm94LCB4U3RlcCwgeVN0ZXAsIHN0cmVhbSkge1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuYkJveCA9IGJCb3g7XG4gICAgdGhpcy54U3RlcCA9IHhTdGVwO1xuICAgIHRoaXMueVN0ZXAgPSB5U3RlcDtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuKCkge1xuICAgIC8vIG5vIHJlc291cmNlcyBuZWVkZWQgZm9yIG91ciBjdXJyZW50IHVzYWdlXG4gICAgLy8gcmVxdWlyZWQgZW50cnlcbiAgICBjb25zdCByZXNvdXJjZXMgPSB0aGlzLmRvYy5yZWYoKTtcbiAgICByZXNvdXJjZXMuZW5kKCk7XG4gICAgLy8gYXBwbHkgZGVmYXVsdCB0cmFuc2Zvcm0gbWF0cml4IChmbGlwcGVkIGluIHRoZSBkZWZhdWx0IGRvYy5fY3RtKVxuICAgIC8vIHNlZSBkb2N1bWVudC5qcyAmIGdyYWRpZW50LmpzXG4gICAgY29uc3QgW20wLCBtMSwgbTIsIG0zLCBtNCwgbTVdID0gdGhpcy5kb2MuX2N0bTtcbiAgICBjb25zdCBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIGNvbnN0IG0gPSBbbTAgKiBtMTEgKyBtMiAqIG0xMiwgbTEgKiBtMTEgKyBtMyAqIG0xMiwgbTAgKiBtMjEgKyBtMiAqIG0yMiwgbTEgKiBtMjEgKyBtMyAqIG0yMiwgbTAgKiBkeCArIG0yICogZHkgKyBtNCwgbTEgKiBkeCArIG0zICogZHkgKyBtNV07XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICBUeXBlOiAnUGF0dGVybicsXG4gICAgICBQYXR0ZXJuVHlwZTogMSxcbiAgICAgIC8vIHRpbGluZ1xuICAgICAgUGFpbnRUeXBlOiAyLFxuICAgICAgLy8gMS1jb2xvcmVkLCAyLXVuY29sb3JlZFxuICAgICAgVGlsaW5nVHlwZTogMixcbiAgICAgIC8vIDItbm8gZGlzdG9ydGlvblxuICAgICAgQkJveDogdGhpcy5iQm94LFxuICAgICAgWFN0ZXA6IHRoaXMueFN0ZXAsXG4gICAgICBZU3RlcDogdGhpcy55U3RlcCxcbiAgICAgIE1hdHJpeDogbS5tYXAodiA9PiArdi50b0ZpeGVkKDUpKSxcbiAgICAgIFJlc291cmNlczogcmVzb3VyY2VzXG4gICAgfSk7XG4gICAgcGF0dGVybi5lbmQodGhpcy5zdHJlYW0pO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIGVtYmVkUGF0dGVybkNvbG9yU3BhY2VzKCkge1xuICAgIC8vIG1hcCBlYWNoIHBhdHRlcm4gdG8gYW4gdW5kZXJseWluZyBjb2xvciBzcGFjZVxuICAgIC8vIGFuZCBlbWJlZCBvbiBlYWNoIHBhZ2VcbiAgICB1bmRlcmx5aW5nQ29sb3JTcGFjZXMuZm9yRWFjaChjc05hbWUgPT4ge1xuICAgICAgY29uc3QgY3NJZCA9IHRoaXMuZ2V0UGF0dGVybkNvbG9yU3BhY2VJZChjc05hbWUpO1xuICAgICAgaWYgKHRoaXMuZG9jLnBhZ2UuY29sb3JTcGFjZXNbY3NJZF0pIHJldHVybjtcbiAgICAgIGNvbnN0IGNzID0gdGhpcy5kb2MucmVmKFsnUGF0dGVybicsIGNzTmFtZV0pO1xuICAgICAgY3MuZW5kKCk7XG4gICAgICB0aGlzLmRvYy5wYWdlLmNvbG9yU3BhY2VzW2NzSWRdID0gY3M7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGF0dGVybkNvbG9yU3BhY2VJZCh1bmRlcmx5aW5nQ29sb3JzcGFjZSkge1xuICAgIHJldHVybiBgQ3NQJHt1bmRlcmx5aW5nQ29sb3JzcGFjZX1gO1xuICB9XG4gIGVtYmVkKCkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgdGhpcy5kb2MuX3BhdHRlcm5Db3VudCA9IHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQgKyAxO1xuICAgICAgdGhpcy5pZCA9ICdQJyArIHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQ7XG4gICAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLmNyZWF0ZVBhdHRlcm4oKTtcbiAgICB9XG5cbiAgICAvLyBwYXR0ZXJucyBhcmUgZW1iZWRkZWQgaW4gZWFjaCBwYWdlXG4gICAgaWYgKCF0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdKSB7XG4gICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gdGhpcy5wYXR0ZXJuO1xuICAgIH1cbiAgfVxuICBhcHBseShzdHJva2UsIHBhdHRlcm5Db2xvcikge1xuICAgIC8vIGRvIGFueSBlbWJlZGRpbmcvY3JlYXRpbmcgdGhhdCBtaWdodCBiZSBuZWVkZWRcbiAgICB0aGlzLmVtYmVkUGF0dGVybkNvbG9yU3BhY2VzKCk7XG4gICAgdGhpcy5lbWJlZCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IHRoaXMuZG9jLl9ub3JtYWxpemVDb2xvcihwYXR0ZXJuQ29sb3IpO1xuICAgIGlmICghbm9ybWFsaXplZENvbG9yKSB0aHJvdyBFcnJvcihgaW52YWxpZCBwYXR0ZXJuIGNvbG9yLiAodmFsdWU6ICR7cGF0dGVybkNvbG9yfSlgKTtcblxuICAgIC8vIHNlbGVjdCBvbmUgb2YgdGhlIHBhdHRlcm4gY29sb3Igc3BhY2VzXG4gICAgY29uc3QgY3NJZCA9IHRoaXMuZ2V0UGF0dGVybkNvbG9yU3BhY2VJZCh0aGlzLmRvYy5fZ2V0Q29sb3JTcGFjZShub3JtYWxpemVkQ29sb3IpKTtcbiAgICB0aGlzLmRvYy5fc2V0Q29sb3JTcGFjZShjc0lkLCBzdHJva2UpO1xuXG4gICAgLy8gc3Ryb2tlL2ZpbGwgdXNpbmcgdGhlIHBhdHRlcm4gYW5kIGNvbG9yIChpbiB0aGUgYWJvdmUgdW5kZXJseWluZyBjb2xvciBzcGFjZSlcbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdTQ04nIDogJ3Njbic7XG4gICAgcmV0dXJuIHRoaXMuZG9jLmFkZENvbnRlbnQoYCR7bm9ybWFsaXplZENvbG9yLmpvaW4oJyAnKX0gLyR7dGhpcy5pZH0gJHtvcH1gKTtcbiAgfVxufVxudmFyIHBhdHRlcm4gPSB7XG4gIFBERlRpbGluZ1BhdHRlcm5cbn07XG5cbmNvbnN0IHtcbiAgUERGR3JhZGllbnQ6IFBERkdyYWRpZW50JDEsXG4gIFBERkxpbmVhckdyYWRpZW50OiBQREZMaW5lYXJHcmFkaWVudCQxLFxuICBQREZSYWRpYWxHcmFkaWVudDogUERGUmFkaWFsR3JhZGllbnQkMVxufSA9IEdyYWRpZW50O1xuY29uc3Qge1xuICBQREZUaWxpbmdQYXR0ZXJuOiBQREZUaWxpbmdQYXR0ZXJuJDFcbn0gPSBwYXR0ZXJuO1xudmFyIENvbG9yTWl4aW4gPSB7XG4gIGluaXRDb2xvcigpIHtcbiAgICAvLyBUaGUgb3BhY2l0eSBkaWN0aW9uYXJpZXNcbiAgICB0aGlzLl9vcGFjaXR5UmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLl9vcGFjaXR5Q291bnQgPSAwO1xuICAgIHRoaXMuX3BhdHRlcm5Db3VudCA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX2dyYWRDb3VudCA9IDA7XG4gIH0sXG4gIF9ub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgvIyhbMC05QS1GXSkoWzAtOUEtRl0pKFswLTlBLUZdKS9pLCAnIyQxJDEkMiQyJDMkMycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgICAgIGNvbG9yID0gW2hleCA+PiAxNiwgaGV4ID4+IDggJiAweGZmLCBoZXggJiAweGZmXTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZWRDb2xvcnNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZWRDb2xvcnNbY29sb3JdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICAgIC8vIFJHQlxuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb2xvciA9IGNvbG9yLm1hcChwYXJ0ID0+IHBhcnQgLyAyNTUpO1xuICAgICAgICAvLyBDTVlLXG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBjb2xvciA9IGNvbG9yLm1hcChwYXJ0ID0+IHBhcnQgLyAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgX3NldENvbG9yKGNvbG9yLCBzdHJva2UpIHtcbiAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBQREZHcmFkaWVudCQxKSB7XG4gICAgICBjb2xvci5hcHBseShzdHJva2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyBzZWUgaWYgdGlsaW5nIHBhdHRlcm4sIGRlY29kZSAmIGFwcGx5IGl0IGl0XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSBpbnN0YW5jZW9mIFBERlRpbGluZ1BhdHRlcm4kMSkge1xuICAgICAgY29sb3JbMF0uYXBwbHkoc3Ryb2tlLCBjb2xvclsxXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYW55IG90aGVyIGNhc2Ugc2hvdWxkIGJlIGEgbm9ybWFsIGNvbG9yIGFuZCBub3QgYSBwYXR0ZXJuXG4gICAgcmV0dXJuIHRoaXMuX3NldENvbG9yQ29yZShjb2xvciwgc3Ryb2tlKTtcbiAgfSxcbiAgX3NldENvbG9yQ29yZShjb2xvciwgc3Ryb2tlKSB7XG4gICAgY29sb3IgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdTQ04nIDogJ3Njbic7XG4gICAgY29uc3Qgc3BhY2UgPSB0aGlzLl9nZXRDb2xvclNwYWNlKGNvbG9yKTtcbiAgICB0aGlzLl9zZXRDb2xvclNwYWNlKHNwYWNlLCBzdHJva2UpO1xuICAgIGNvbG9yID0gY29sb3Iuam9pbignICcpO1xuICAgIHRoaXMuYWRkQ29udGVudChgJHtjb2xvcn0gJHtvcH1gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgX3NldENvbG9yU3BhY2Uoc3BhY2UsIHN0cm9rZSkge1xuICAgIGNvbnN0IG9wID0gc3Ryb2tlID8gJ0NTJyA6ICdjcyc7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgLyR7c3BhY2V9ICR7b3B9YCk7XG4gIH0sXG4gIF9nZXRDb2xvclNwYWNlKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLmxlbmd0aCA9PT0gNCA/ICdEZXZpY2VDTVlLJyA6ICdEZXZpY2VSR0InO1xuICB9LFxuICBmaWxsQ29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICBjb25zdCBzZXQgPSB0aGlzLl9zZXRDb2xvcihjb2xvciwgZmFsc2UpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHRoaXMuZmlsbE9wYWNpdHkob3BhY2l0eSk7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSB0aGlzIGZvciB0ZXh0IHdyYXBwZXIsIHdoaWNoIG5lZWRzIHRvIHJlc2V0XG4gICAgLy8gdGhlIGZpbGwgY29sb3Igb24gbmV3IHBhZ2VzXG4gICAgdGhpcy5fZmlsbENvbG9yID0gW2NvbG9yLCBvcGFjaXR5XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3Ryb2tlQ29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICBjb25zdCBzZXQgPSB0aGlzLl9zZXRDb2xvcihjb2xvciwgdHJ1ZSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgdGhpcy5zdHJva2VPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KG9wYWNpdHksIG9wYWNpdHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmaWxsT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KG9wYWNpdHksIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJva2VPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9kb09wYWNpdHkobnVsbCwgb3BhY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb09wYWNpdHkoZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkpIHtcbiAgICBsZXQgZGljdGlvbmFyeSwgbmFtZTtcbiAgICBpZiAoZmlsbE9wYWNpdHkgPT0gbnVsbCAmJiBzdHJva2VPcGFjaXR5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgIGZpbGxPcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZmlsbE9wYWNpdHkpKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZU9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgc3Ryb2tlT3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHN0cm9rZU9wYWNpdHkpKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYCR7ZmlsbE9wYWNpdHl9XyR7c3Ryb2tlT3BhY2l0eX1gO1xuICAgIGlmICh0aGlzLl9vcGFjaXR5UmVnaXN0cnlba2V5XSkge1xuICAgICAgW2RpY3Rpb25hcnksIG5hbWVdID0gdGhpcy5fb3BhY2l0eVJlZ2lzdHJ5W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3Rpb25hcnkgPSB7XG4gICAgICAgIFR5cGU6ICdFeHRHU3RhdGUnXG4gICAgICB9O1xuICAgICAgaWYgKGZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgZGljdGlvbmFyeS5jYSA9IGZpbGxPcGFjaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkNBID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGRpY3Rpb25hcnkgPSB0aGlzLnJlZihkaWN0aW9uYXJ5KTtcbiAgICAgIGRpY3Rpb25hcnkuZW5kKCk7XG4gICAgICBjb25zdCBpZCA9ICsrdGhpcy5fb3BhY2l0eUNvdW50O1xuICAgICAgbmFtZSA9IGBHcyR7aWR9YDtcbiAgICAgIHRoaXMuX29wYWNpdHlSZWdpc3RyeVtrZXldID0gW2RpY3Rpb25hcnksIG5hbWVdO1xuICAgIH1cbiAgICB0aGlzLnBhZ2UuZXh0X2dzdGF0ZXNbbmFtZV0gPSBkaWN0aW9uYXJ5O1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYC8ke25hbWV9IGdzYCk7XG4gIH0sXG4gIGxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIG5ldyBQREZMaW5lYXJHcmFkaWVudCQxKHRoaXMsIHgxLCB5MSwgeDIsIHkyKTtcbiAgfSxcbiAgcmFkaWFsR3JhZGllbnQoeDEsIHkxLCByMSwgeDIsIHkyLCByMikge1xuICAgIHJldHVybiBuZXcgUERGUmFkaWFsR3JhZGllbnQkMSh0aGlzLCB4MSwgeTEsIHIxLCB4MiwgeTIsIHIyKTtcbiAgfSxcbiAgcGF0dGVybihiYm94LCB4U3RlcCwgeVN0ZXAsIHN0cmVhbSkge1xuICAgIHJldHVybiBuZXcgUERGVGlsaW5nUGF0dGVybiQxKHRoaXMsIGJib3gsIHhTdGVwLCB5U3RlcCwgc3RyZWFtKTtcbiAgfVxufTtcbnZhciBuYW1lZENvbG9ycyA9IHtcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbmxldCBjeCwgY3ksIHB4LCBweSwgc3gsIHN5O1xuY3ggPSBjeSA9IHB4ID0gcHkgPSBzeCA9IHN5ID0gMDtcbmNvbnN0IHBhcmFtZXRlcnMgPSB7XG4gIEE6IDcsXG4gIGE6IDcsXG4gIEM6IDYsXG4gIGM6IDYsXG4gIEg6IDEsXG4gIGg6IDEsXG4gIEw6IDIsXG4gIGw6IDIsXG4gIE06IDIsXG4gIG06IDIsXG4gIFE6IDQsXG4gIHE6IDQsXG4gIFM6IDQsXG4gIHM6IDQsXG4gIFQ6IDIsXG4gIHQ6IDIsXG4gIFY6IDEsXG4gIHY6IDEsXG4gIFo6IDAsXG4gIHo6IDBcbn07XG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGxldCBjbWQ7XG4gIGNvbnN0IHJldCA9IFtdO1xuICBsZXQgYXJncyA9IFtdO1xuICBsZXQgY3VyQXJnID0gJyc7XG4gIGxldCBmb3VuZERlY2ltYWwgPSBmYWxzZTtcbiAgbGV0IHBhcmFtcyA9IDA7XG4gIGZvciAobGV0IGMgb2YgcGF0aCkge1xuICAgIGlmIChwYXJhbWV0ZXJzW2NdICE9IG51bGwpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtZXRlcnNbY107XG4gICAgICBpZiAoY21kKSB7XG4gICAgICAgIC8vIHNhdmUgZXhpc3RpbmcgY29tbWFuZFxuICAgICAgICBpZiAoY3VyQXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgICAgICAgIGNtZCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgY3VyQXJnID0gJyc7XG4gICAgICAgIGZvdW5kRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY21kID0gYztcbiAgICB9IGVsc2UgaWYgKFsnICcsICcsJ10uaW5jbHVkZXMoYykgfHwgYyA9PT0gJy0nICYmIGN1ckFyZy5sZW5ndGggPiAwICYmIGN1ckFyZ1tjdXJBcmcubGVuZ3RoIC0gMV0gIT09ICdlJyB8fCBjID09PSAnLicgJiYgZm91bmREZWNpbWFsKSB7XG4gICAgICBpZiAoY3VyQXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gcGFyYW1zKSB7XG4gICAgICAgIC8vIGhhbmRsZSByZXVzZWQgY29tbWFuZHNcbiAgICAgICAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgICAgICAgIGNtZCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MgPSBbK2N1ckFyZ107XG5cbiAgICAgICAgLy8gaGFuZGxlIGFzc3VtZWQgY29tbWFuZHNcbiAgICAgICAgaWYgKGNtZCA9PT0gJ00nKSB7XG4gICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQgPT09ICdtJykge1xuICAgICAgICAgIGNtZCA9ICdsJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aF0gPSArY3VyQXJnO1xuICAgICAgfVxuICAgICAgZm91bmREZWNpbWFsID0gYyA9PT0gJy4nO1xuXG4gICAgICAvLyBmaXggZm9yIG5lZ2F0aXZlIG51bWJlcnMgb3IgcmVwZWF0ZWQgZGVjaW1hbHMgd2l0aCBubyBkZWxpbWV0ZXIgYmV0d2VlbiBjb21tYW5kc1xuICAgICAgY3VyQXJnID0gWyctJywgJy4nXS5pbmNsdWRlcyhjKSA/IGMgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyQXJnICs9IGM7XG4gICAgICBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAgIGZvdW5kRGVjaW1hbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRoZSBsYXN0IGNvbW1hbmRcbiAgaWYgKGN1ckFyZy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSBwYXJhbXMpIHtcbiAgICAgIC8vIGhhbmRsZSByZXVzZWQgY29tbWFuZHNcbiAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICAgICAgY21kLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgICAgYXJncyA9IFsrY3VyQXJnXTtcblxuICAgICAgLy8gaGFuZGxlIGFzc3VtZWQgY29tbWFuZHNcbiAgICAgIGlmIChjbWQgPT09ICdNJykge1xuICAgICAgICBjbWQgPSAnTCc7XG4gICAgICB9XG4gICAgICBpZiAoY21kID09PSAnbScpIHtcbiAgICAgICAgY21kID0gJ2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgfVxuICB9XG4gIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICBjbWQsXG4gICAgYXJnc1xuICB9O1xuICByZXR1cm4gcmV0O1xufTtcbmNvbnN0IGFwcGx5ID0gZnVuY3Rpb24gKGNvbW1hbmRzLCBkb2MpIHtcbiAgLy8gY3VycmVudCBwb2ludCwgY29udHJvbCBwb2ludCwgYW5kIHN1YnBhdGggc3RhcnRpbmcgcG9pbnRcbiAgY3ggPSBjeSA9IHB4ID0gcHkgPSBzeCA9IHN5ID0gMDtcblxuICAvLyBydW4gdGhlIGNvbW1hbmRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjID0gY29tbWFuZHNbaV07XG4gICAgaWYgKHR5cGVvZiBydW5uZXJzW2MuY21kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcnVubmVyc1tjLmNtZF0oZG9jLCBjLmFyZ3MpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHJ1bm5lcnMgPSB7XG4gIE0oZG9jLCBhKSB7XG4gICAgY3ggPSBhWzBdO1xuICAgIGN5ID0gYVsxXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICBzeCA9IGN4O1xuICAgIHN5ID0gY3k7XG4gICAgcmV0dXJuIGRvYy5tb3ZlVG8oY3gsIGN5KTtcbiAgfSxcbiAgbShkb2MsIGEpIHtcbiAgICBjeCArPSBhWzBdO1xuICAgIGN5ICs9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgc3ggPSBjeDtcbiAgICBzeSA9IGN5O1xuICAgIHJldHVybiBkb2MubW92ZVRvKGN4LCBjeSk7XG4gIH0sXG4gIEMoZG9jLCBhKSB7XG4gICAgY3ggPSBhWzRdO1xuICAgIGN5ID0gYVs1XTtcbiAgICBweCA9IGFbMl07XG4gICAgcHkgPSBhWzNdO1xuICAgIHJldHVybiBkb2MuYmV6aWVyQ3VydmVUbyguLi5hKTtcbiAgfSxcbiAgYyhkb2MsIGEpIHtcbiAgICBkb2MuYmV6aWVyQ3VydmVUbyhhWzBdICsgY3gsIGFbMV0gKyBjeSwgYVsyXSArIGN4LCBhWzNdICsgY3ksIGFbNF0gKyBjeCwgYVs1XSArIGN5KTtcbiAgICBweCA9IGN4ICsgYVsyXTtcbiAgICBweSA9IGN5ICsgYVszXTtcbiAgICBjeCArPSBhWzRdO1xuICAgIHJldHVybiBjeSArPSBhWzVdO1xuICB9LFxuICBTKGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfVxuICAgIGRvYy5iZXppZXJDdXJ2ZVRvKGN4IC0gKHB4IC0gY3gpLCBjeSAtIChweSAtIGN5KSwgYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgcHggPSBhWzBdO1xuICAgIHB5ID0gYVsxXTtcbiAgICBjeCA9IGFbMl07XG4gICAgcmV0dXJuIGN5ID0gYVszXTtcbiAgfSxcbiAgcyhkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH1cbiAgICBkb2MuYmV6aWVyQ3VydmVUbyhjeCAtIChweCAtIGN4KSwgY3kgLSAocHkgLSBjeSksIGN4ICsgYVswXSwgY3kgKyBhWzFdLCBjeCArIGFbMl0sIGN5ICsgYVszXSk7XG4gICAgcHggPSBjeCArIGFbMF07XG4gICAgcHkgPSBjeSArIGFbMV07XG4gICAgY3ggKz0gYVsyXTtcbiAgICByZXR1cm4gY3kgKz0gYVszXTtcbiAgfSxcbiAgUShkb2MsIGEpIHtcbiAgICBweCA9IGFbMF07XG4gICAgcHkgPSBhWzFdO1xuICAgIGN4ID0gYVsyXTtcbiAgICBjeSA9IGFbM107XG4gICAgcmV0dXJuIGRvYy5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0sIGFbMV0sIGN4LCBjeSk7XG4gIH0sXG4gIHEoZG9jLCBhKSB7XG4gICAgZG9jLnF1YWRyYXRpY0N1cnZlVG8oYVswXSArIGN4LCBhWzFdICsgY3ksIGFbMl0gKyBjeCwgYVszXSArIGN5KTtcbiAgICBweCA9IGN4ICsgYVswXTtcbiAgICBweSA9IGN5ICsgYVsxXTtcbiAgICBjeCArPSBhWzJdO1xuICAgIHJldHVybiBjeSArPSBhWzNdO1xuICB9LFxuICBUKGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB4ID0gY3ggLSAocHggLSBjeCk7XG4gICAgICBweSA9IGN5IC0gKHB5IC0gY3kpO1xuICAgIH1cbiAgICBkb2MucXVhZHJhdGljQ3VydmVUbyhweCwgcHksIGFbMF0sIGFbMV0pO1xuICAgIHB4ID0gY3ggLSAocHggLSBjeCk7XG4gICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICBjeCA9IGFbMF07XG4gICAgcmV0dXJuIGN5ID0gYVsxXTtcbiAgfSxcbiAgdChkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH0gZWxzZSB7XG4gICAgICBweCA9IGN4IC0gKHB4IC0gY3gpO1xuICAgICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICB9XG4gICAgZG9jLnF1YWRyYXRpY0N1cnZlVG8ocHgsIHB5LCBjeCArIGFbMF0sIGN5ICsgYVsxXSk7XG4gICAgY3ggKz0gYVswXTtcbiAgICByZXR1cm4gY3kgKz0gYVsxXTtcbiAgfSxcbiAgQShkb2MsIGEpIHtcbiAgICBzb2x2ZUFyYyhkb2MsIGN4LCBjeSwgYSk7XG4gICAgY3ggPSBhWzVdO1xuICAgIHJldHVybiBjeSA9IGFbNl07XG4gIH0sXG4gIGEoZG9jLCBhKSB7XG4gICAgYVs1XSArPSBjeDtcbiAgICBhWzZdICs9IGN5O1xuICAgIHNvbHZlQXJjKGRvYywgY3gsIGN5LCBhKTtcbiAgICBjeCA9IGFbNV07XG4gICAgcmV0dXJuIGN5ID0gYVs2XTtcbiAgfSxcbiAgTChkb2MsIGEpIHtcbiAgICBjeCA9IGFbMF07XG4gICAgY3kgPSBhWzFdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIGwoZG9jLCBhKSB7XG4gICAgY3ggKz0gYVswXTtcbiAgICBjeSArPSBhWzFdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIEgoZG9jLCBhKSB7XG4gICAgY3ggPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIGgoZG9jLCBhKSB7XG4gICAgY3ggKz0gYVswXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBWKGRvYywgYSkge1xuICAgIGN5ID0gYVswXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICB2KGRvYywgYSkge1xuICAgIGN5ICs9IGFbMF07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgWihkb2MpIHtcbiAgICBkb2MuY2xvc2VQYXRoKCk7XG4gICAgY3ggPSBzeDtcbiAgICByZXR1cm4gY3kgPSBzeTtcbiAgfSxcbiAgeihkb2MpIHtcbiAgICBkb2MuY2xvc2VQYXRoKCk7XG4gICAgY3ggPSBzeDtcbiAgICByZXR1cm4gY3kgPSBzeTtcbiAgfVxufTtcbmNvbnN0IHNvbHZlQXJjID0gZnVuY3Rpb24gKGRvYywgeCwgeSwgY29vcmRzKSB7XG4gIGNvbnN0IFtyeCwgcnksIHJvdCwgbGFyZ2UsIHN3ZWVwLCBleCwgZXldID0gY29vcmRzO1xuICBjb25zdCBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgIGNvbnN0IGJleiA9IHNlZ21lbnRUb0JlemllciguLi5zZWcpO1xuICAgIGRvYy5iZXppZXJDdXJ2ZVRvKC4uLmJleik7XG4gIH1cbn07XG5cbi8vIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcbmNvbnN0IGFyY1RvU2VnbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBjb25zdCB0aCA9IHJvdGF0ZVggKiAoTWF0aC5QSSAvIDE4MCk7XG4gIGNvbnN0IHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgY29uc3QgY29zX3RoID0gTWF0aC5jb3ModGgpO1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICBsZXQgcGwgPSBweCAqIHB4IC8gKHJ4ICogcngpICsgcHkgKiBweSAvIChyeSAqIHJ5KTtcbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuICBjb25zdCBhMDAgPSBjb3NfdGggLyByeDtcbiAgY29uc3QgYTAxID0gc2luX3RoIC8gcng7XG4gIGNvbnN0IGExMCA9IC1zaW5fdGggLyByeTtcbiAgY29uc3QgYTExID0gY29zX3RoIC8gcnk7XG4gIGNvbnN0IHgwID0gYTAwICogb3ggKyBhMDEgKiBveTtcbiAgY29uc3QgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICBjb25zdCB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICBjb25zdCB5MSA9IGExMCAqIHggKyBhMTEgKiB5O1xuICBjb25zdCBkID0gKHgxIC0geDApICogKHgxIC0geDApICsgKHkxIC0geTApICogKHkxIC0geTApO1xuICBsZXQgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSB7XG4gICAgc2ZhY3Rvcl9zcSA9IDA7XG4gIH1cbiAgbGV0IHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PT0gbGFyZ2UpIHtcbiAgICBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIH1cbiAgY29uc3QgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxIC0geTApO1xuICBjb25zdCB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEgLSB4MCk7XG4gIGNvbnN0IHRoMCA9IE1hdGguYXRhbjIoeTAgLSB5YywgeDAgLSB4Yyk7XG4gIGNvbnN0IHRoMSA9IE1hdGguYXRhbjIoeTEgLSB5YywgeDEgLSB4Yyk7XG4gIGxldCB0aF9hcmMgPSB0aDEgLSB0aDA7XG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09PSAxKSB7XG4gICAgdGhfYXJjICs9IDIgKiBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKE1hdGguUEkgKiAwLjUgKyAwLjAwMSkpKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGNvbnN0IHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICBjb25zdCB0aDMgPSB0aDAgKyAoaSArIDEpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3Qgc2VnbWVudFRvQmV6aWVyID0gZnVuY3Rpb24gKGN4LCBjeSwgdGgwLCB0aDEsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGgpIHtcbiAgY29uc3QgYTAwID0gY29zX3RoICogcng7XG4gIGNvbnN0IGEwMSA9IC1zaW5fdGggKiByeTtcbiAgY29uc3QgYTEwID0gc2luX3RoICogcng7XG4gIGNvbnN0IGExMSA9IGNvc190aCAqIHJ5O1xuICBjb25zdCB0aF9oYWxmID0gMC41ICogKHRoMSAtIHRoMCk7XG4gIGNvbnN0IHQgPSA4IC8gMyAqIE1hdGguc2luKHRoX2hhbGYgKiAwLjUpICogTWF0aC5zaW4odGhfaGFsZiAqIDAuNSkgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgY29uc3QgeDEgPSBjeCArIE1hdGguY29zKHRoMCkgLSB0ICogTWF0aC5zaW4odGgwKTtcbiAgY29uc3QgeTEgPSBjeSArIE1hdGguc2luKHRoMCkgKyB0ICogTWF0aC5jb3ModGgwKTtcbiAgY29uc3QgeDMgPSBjeCArIE1hdGguY29zKHRoMSk7XG4gIGNvbnN0IHkzID0gY3kgKyBNYXRoLnNpbih0aDEpO1xuICBjb25zdCB4MiA9IHgzICsgdCAqIE1hdGguc2luKHRoMSk7XG4gIGNvbnN0IHkyID0geTMgLSB0ICogTWF0aC5jb3ModGgxKTtcbiAgcmV0dXJuIFthMDAgKiB4MSArIGEwMSAqIHkxLCBhMTAgKiB4MSArIGExMSAqIHkxLCBhMDAgKiB4MiArIGEwMSAqIHkyLCBhMTAgKiB4MiArIGExMSAqIHkyLCBhMDAgKiB4MyArIGEwMSAqIHkzLCBhMTAgKiB4MyArIGExMSAqIHkzXTtcbn07XG5jbGFzcyBTVkdQYXRoIHtcbiAgc3RhdGljIGFwcGx5KGRvYywgcGF0aCkge1xuICAgIGNvbnN0IGNvbW1hbmRzID0gcGFyc2UocGF0aCk7XG4gICAgYXBwbHkoY29tbWFuZHMsIGRvYyk7XG4gIH1cbn1cblxuY29uc3Qge1xuICBudW1iZXI6IG51bWJlciQxXG59ID0gUERGT2JqZWN0O1xuXG4vLyBUaGlzIGNvbnN0YW50IGlzIHVzZWQgdG8gYXBwcm94aW1hdGUgYSBzeW1tZXRyaWNhbCBhcmMgdXNpbmcgYSBjdWJpY1xuLy8gQmV6aWVyIGN1cnZlLlxuY29uc3QgS0FQUEEgPSA0LjAgKiAoKE1hdGguc3FydCgyKSAtIDEuMCkgLyAzLjApO1xudmFyIFZlY3Rvck1peGluID0ge1xuICBpbml0VmVjdG9yKCkge1xuICAgIHRoaXMuX2N0bSA9IFsxLCAwLCAwLCAxLCAwLCAwXTsgLy8gY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICByZXR1cm4gdGhpcy5fY3RtU3RhY2sgPSBbXTtcbiAgfSxcbiAgc2F2ZSgpIHtcbiAgICB0aGlzLl9jdG1TdGFjay5wdXNoKHRoaXMuX2N0bS5zbGljZSgpKTtcbiAgICAvLyBUT0RPOiBzYXZlL3Jlc3RvcmUgY29sb3JzcGFjZSBhbmQgc3R5bGVzIHNvIG5vdCBzZXR0aW5nIGl0IHVubmVzc2VzYXJpbHkgYWxsIHRoZSB0aW1lP1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ3EnKTtcbiAgfSxcbiAgcmVzdG9yZSgpIHtcbiAgICB0aGlzLl9jdG0gPSB0aGlzLl9jdG1TdGFjay5wb3AoKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUScpO1xuICB9LFxuICBjbG9zZVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnaCcpO1xuICB9LFxuICBsaW5lV2lkdGgodykge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEodyl9IHdgKTtcbiAgfSxcbiAgX0NBUF9TVFlMRVM6IHtcbiAgICBCVVRUOiAwLFxuICAgIFJPVU5EOiAxLFxuICAgIFNRVUFSRTogMlxuICB9LFxuICBsaW5lQ2FwKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjID0gdGhpcy5fQ0FQX1NUWUxFU1tjLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke2N9IEpgKTtcbiAgfSxcbiAgX0pPSU5fU1RZTEVTOiB7XG4gICAgTUlURVI6IDAsXG4gICAgUk9VTkQ6IDEsXG4gICAgQkVWRUw6IDJcbiAgfSxcbiAgbGluZUpvaW4oaikge1xuICAgIGlmICh0eXBlb2YgaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGogPSB0aGlzLl9KT0lOX1NUWUxFU1tqLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke2p9IGpgKTtcbiAgfSxcbiAgbWl0ZXJMaW1pdChtKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMShtKX0gTWApO1xuICB9LFxuICBkYXNoKGxlbmd0aCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IGxlbmd0aDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gW2xlbmd0aCwgb3B0aW9ucy5zcGFjZSB8fCBsZW5ndGhdO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGxlbmd0aC5ldmVyeSh4ID0+IE51bWJlci5pc0Zpbml0ZSh4KSAmJiB4ID4gMCk7XG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBkYXNoKCR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxMZW5ndGgpfSwgJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX0pIGludmFsaWQsIGxlbmd0aHMgbXVzdCBiZSBudW1lcmljIGFuZCBncmVhdGVyIHRoYW4gemVyb2ApO1xuICAgIH1cbiAgICBsZW5ndGggPSBsZW5ndGgubWFwKG51bWJlciQxKS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgWyR7bGVuZ3RofV0gJHtudW1iZXIkMShvcHRpb25zLnBoYXNlIHx8IDApfSBkYCk7XG4gIH0sXG4gIHVuZGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KCdbXSAwIGQnKTtcbiAgfSxcbiAgbW92ZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSBtYCk7XG4gIH0sXG4gIGxpbmVUbyh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMSh4KX0gJHtudW1iZXIkMSh5KX0gbGApO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKGNwMXgpfSAke251bWJlciQxKGNwMXkpfSAke251bWJlciQxKGNwMngpfSAke251bWJlciQxKGNwMnkpfSAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSBjYCk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKGNweCl9ICR7bnVtYmVyJDEoY3B5KX0gJHtudW1iZXIkMSh4KX0gJHtudW1iZXIkMSh5KX0gdmApO1xuICB9LFxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSAke251bWJlciQxKHcpfSAke251bWJlciQxKGgpfSByZWApO1xuICB9LFxuICByb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKSB7XG4gICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgciA9IDA7XG4gICAgfVxuICAgIHIgPSBNYXRoLm1pbihyLCAwLjUgKiB3LCAwLjUgKiBoKTtcblxuICAgIC8vIGFtb3VudCB0byBpbnNldCBjb250cm9sIHBvaW50cyBmcm9tIGNvcm5lcnMgKHNlZSBgZWxsaXBzZWApXG4gICAgY29uc3QgYyA9IHIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ICsgdyAtIGMsIHksIHggKyB3LCB5ICsgYywgeCArIHcsIHkgKyByKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gYywgeCArIHcgLSBjLCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCk7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCArIGMsIHkgKyBoLCB4LCB5ICsgaCAtIGMsIHgsIHkgKyBoIC0gcik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4LCB5ICsgYywgeCArIGMsIHksIHggKyByLCB5KTtcbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgZWxsaXBzZSh4LCB5LCByMSwgcjIpIHtcbiAgICAvLyBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXMvMjE3MzA4NCMyMTczMDg0XG4gICAgaWYgKHIyID09IG51bGwpIHtcbiAgICAgIHIyID0gcjE7XG4gICAgfVxuICAgIHggLT0gcjE7XG4gICAgeSAtPSByMjtcbiAgICBjb25zdCBveCA9IHIxICogS0FQUEE7XG4gICAgY29uc3Qgb3kgPSByMiAqIEtBUFBBO1xuICAgIGNvbnN0IHhlID0geCArIHIxICogMjtcbiAgICBjb25zdCB5ZSA9IHkgKyByMiAqIDI7XG4gICAgY29uc3QgeG0gPSB4ICsgcjE7XG4gICAgY29uc3QgeW0gPSB5ICsgcjI7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeW0pO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5lbGxpcHNlKHgsIHksIHJhZGl1cyk7XG4gIH0sXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgaWYgKGFudGljbG9ja3dpc2UgPT0gbnVsbCkge1xuICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBUV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuICAgIGNvbnN0IEhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuICAgIGxldCBkZWx0YUFuZyA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFBbmcpID4gVFdPX1BJKSB7XG4gICAgICAvLyBkcmF3IG9ubHkgZnVsbCBjaXJjbGUgaWYgbW9yZSB0aGFuIHRoYXQgaXMgc3BlY2lmaWVkXG4gICAgICBkZWx0YUFuZyA9IFRXT19QSTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhQW5nICE9PSAwICYmIGFudGljbG9ja3dpc2UgIT09IGRlbHRhQW5nIDwgMCkge1xuICAgICAgLy8gbmVjZXNzYXJ5IHRvIGZsaXAgZGlyZWN0aW9uIG9mIHJlbmRlcmluZ1xuICAgICAgY29uc3QgZGlyID0gYW50aWNsb2Nrd2lzZSA/IC0xIDogMTtcbiAgICAgIGRlbHRhQW5nID0gZGlyICogVFdPX1BJICsgZGVsdGFBbmc7XG4gICAgfVxuICAgIGNvbnN0IG51bVNlZ3MgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGVsdGFBbmcpIC8gSEFMRl9QSSk7XG4gICAgY29uc3Qgc2VnQW5nID0gZGVsdGFBbmcgLyBudW1TZWdzO1xuICAgIGNvbnN0IGhhbmRsZUxlbiA9IHNlZ0FuZyAvIEhBTEZfUEkgKiBLQVBQQSAqIHJhZGl1cztcbiAgICBsZXQgY3VyQW5nID0gc3RhcnRBbmdsZTtcblxuICAgIC8vIGNvbXBvbmVudCBkaXN0YW5jZXMgYmV0d2VlbiBhbmNob3IgcG9pbnQgYW5kIGNvbnRyb2wgcG9pbnRcbiAgICBsZXQgZGVsdGFDeCA9IC1NYXRoLnNpbihjdXJBbmcpICogaGFuZGxlTGVuO1xuICAgIGxldCBkZWx0YUN5ID0gTWF0aC5jb3MoY3VyQW5nKSAqIGhhbmRsZUxlbjtcblxuICAgIC8vIGFuY2hvciBwb2ludFxuICAgIGxldCBheCA9IHggKyBNYXRoLmNvcyhjdXJBbmcpICogcmFkaXVzO1xuICAgIGxldCBheSA9IHkgKyBNYXRoLnNpbihjdXJBbmcpICogcmFkaXVzO1xuXG4gICAgLy8gY2FsY3VsYXRlIGFuZCByZW5kZXIgc2VnbWVudHNcbiAgICB0aGlzLm1vdmVUbyhheCwgYXkpO1xuICAgIGZvciAobGV0IHNlZ0lkeCA9IDA7IHNlZ0lkeCA8IG51bVNlZ3M7IHNlZ0lkeCsrKSB7XG4gICAgICAvLyBzdGFydGluZyBjb250cm9sIHBvaW50XG4gICAgICBjb25zdCBjcDF4ID0gYXggKyBkZWx0YUN4O1xuICAgICAgY29uc3QgY3AxeSA9IGF5ICsgZGVsdGFDeTtcblxuICAgICAgLy8gc3RlcCBhbmdsZVxuICAgICAgY3VyQW5nICs9IHNlZ0FuZztcblxuICAgICAgLy8gbmV4dCBhbmNob3IgcG9pbnRcbiAgICAgIGF4ID0geCArIE1hdGguY29zKGN1ckFuZykgKiByYWRpdXM7XG4gICAgICBheSA9IHkgKyBNYXRoLnNpbihjdXJBbmcpICogcmFkaXVzO1xuXG4gICAgICAvLyBuZXh0IGNvbnRyb2wgcG9pbnQgZGVsdGFcbiAgICAgIGRlbHRhQ3ggPSAtTWF0aC5zaW4oY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICAgIGRlbHRhQ3kgPSBNYXRoLmNvcyhjdXJBbmcpICogaGFuZGxlTGVuO1xuXG4gICAgICAvLyBlbmRpbmcgY29udHJvbCBwb2ludFxuICAgICAgY29uc3QgY3AyeCA9IGF4IC0gZGVsdGFDeDtcbiAgICAgIGNvbnN0IGNwMnkgPSBheSAtIGRlbHRhQ3k7XG5cbiAgICAgIC8vIHJlbmRlciBzZWdtZW50XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgYXgsIGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBvbHlnb24oKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBvaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5tb3ZlVG8oLi4uKHBvaW50cy5zaGlmdCgpIHx8IFtdKSk7XG4gICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICB0aGlzLmxpbmVUbyguLi4ocG9pbnQgfHwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBhdGgocGF0aCkge1xuICAgIFNWR1BhdGguYXBwbHkodGhpcywgcGF0aCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF93aW5kaW5nUnVsZShydWxlKSB7XG4gICAgaWYgKC9ldmVuLT9vZGQvLnRlc3QocnVsZSkpIHtcbiAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgZmlsbChjb2xvciwgcnVsZSkge1xuICAgIGlmICgvKGV2ZW4tP29kZCl8KG5vbi0/emVybykvLnRlc3QoY29sb3IpKSB7XG4gICAgICBydWxlID0gY29sb3I7XG4gICAgICBjb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5maWxsQ29sb3IoY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGBmJHt0aGlzLl93aW5kaW5nUnVsZShydWxlKX1gKTtcbiAgfSxcbiAgc3Ryb2tlKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0cm9rZUNvbG9yKGNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUycpO1xuICB9LFxuICBmaWxsQW5kU3Ryb2tlKGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IsIHJ1bGUpIHtcbiAgICBpZiAoc3Ryb2tlQ29sb3IgPT0gbnVsbCkge1xuICAgICAgc3Ryb2tlQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfVxuICAgIGNvbnN0IGlzRmlsbFJ1bGUgPSAvKGV2ZW4tP29kZCl8KG5vbi0/emVybykvO1xuICAgIGlmIChpc0ZpbGxSdWxlLnRlc3QoZmlsbENvbG9yKSkge1xuICAgICAgcnVsZSA9IGZpbGxDb2xvcjtcbiAgICAgIGZpbGxDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChpc0ZpbGxSdWxlLnRlc3Qoc3Ryb2tlQ29sb3IpKSB7XG4gICAgICBydWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgICBzdHJva2VDb2xvciA9IGZpbGxDb2xvcjtcbiAgICB9XG4gICAgaWYgKGZpbGxDb2xvcikge1xuICAgICAgdGhpcy5maWxsQ29sb3IoZmlsbENvbG9yKTtcbiAgICAgIHRoaXMuc3Ryb2tlQ29sb3Ioc3Ryb2tlQ29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGBCJHt0aGlzLl93aW5kaW5nUnVsZShydWxlKX1gKTtcbiAgfSxcbiAgY2xpcChydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgVyR7dGhpcy5fd2luZGluZ1J1bGUocnVsZSl9IG5gKTtcbiAgfSxcbiAgdHJhbnNmb3JtKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICBpZiAobTExID09PSAxICYmIG0xMiA9PT0gMCAmJiBtMjEgPT09IDAgJiYgbTIyID09PSAxICYmIGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgICAvLyBJZ25vcmUgaWRlbnRpdHkgdHJhbnNmb3Jtc1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IG0gPSB0aGlzLl9jdG07XG4gICAgY29uc3QgW20wLCBtMSwgbTIsIG0zLCBtNCwgbTVdID0gbTtcbiAgICBtWzBdID0gbTAgKiBtMTEgKyBtMiAqIG0xMjtcbiAgICBtWzFdID0gbTEgKiBtMTEgKyBtMyAqIG0xMjtcbiAgICBtWzJdID0gbTAgKiBtMjEgKyBtMiAqIG0yMjtcbiAgICBtWzNdID0gbTEgKiBtMjEgKyBtMyAqIG0yMjtcbiAgICBtWzRdID0gbTAgKiBkeCArIG0yICogZHkgKyBtNDtcbiAgICBtWzVdID0gbTEgKiBkeCArIG0zICogZHkgKyBtNTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldLm1hcCh2ID0+IG51bWJlciQxKHYpKS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHt2YWx1ZXN9IGNtYCk7XG4gIH0sXG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuICB9LFxuICByb3RhdGUoYW5nbGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IHk7XG4gICAgY29uc3QgcmFkID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJhZCk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgICBsZXQgeCA9IHkgPSAwO1xuICAgIGlmIChvcHRpb25zLm9yaWdpbiAhPSBudWxsKSB7XG4gICAgICBbeCwgeV0gPSBvcHRpb25zLm9yaWdpbjtcbiAgICAgIGNvbnN0IHgxID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICBjb25zdCB5MSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgeCAtPSB4MTtcbiAgICAgIHkgLT0geTE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgfSxcbiAgc2NhbGUoeEZhY3RvciwgeUZhY3Rvcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgeTtcbiAgICBpZiAoeUZhY3RvciA9PSBudWxsKSB7XG4gICAgICB5RmFjdG9yID0geEZhY3RvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB5RmFjdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHlGYWN0b3I7XG4gICAgICB5RmFjdG9yID0geEZhY3RvcjtcbiAgICB9XG4gICAgbGV0IHggPSB5ID0gMDtcbiAgICBpZiAob3B0aW9ucy5vcmlnaW4gIT0gbnVsbCkge1xuICAgICAgW3gsIHldID0gb3B0aW9ucy5vcmlnaW47XG4gICAgICB4IC09IHhGYWN0b3IgKiB4O1xuICAgICAgeSAtPSB5RmFjdG9yICogeTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHhGYWN0b3IsIDAsIDAsIHlGYWN0b3IsIHgsIHkpO1xuICB9XG59O1xuXG5jb25zdCBXSU5fQU5TSV9NQVAgPSB7XG4gIDQwMjogMTMxLFxuICA4MjExOiAxNTAsXG4gIDgyMTI6IDE1MSxcbiAgODIxNjogMTQ1LFxuICA4MjE3OiAxNDYsXG4gIDgyMTg6IDEzMCxcbiAgODIyMDogMTQ3LFxuICA4MjIxOiAxNDgsXG4gIDgyMjI6IDEzMixcbiAgODIyNDogMTM0LFxuICA4MjI1OiAxMzUsXG4gIDgyMjY6IDE0OSxcbiAgODIzMDogMTMzLFxuICA4MzY0OiAxMjgsXG4gIDgyNDA6IDEzNyxcbiAgODI0OTogMTM5LFxuICA4MjUwOiAxNTUsXG4gIDcxMDogMTM2LFxuICA4NDgyOiAxNTMsXG4gIDMzODogMTQwLFxuICAzMzk6IDE1NixcbiAgNzMyOiAxNTIsXG4gIDM1MjogMTM4LFxuICAzNTM6IDE1NCxcbiAgMzc2OiAxNTksXG4gIDM4MTogMTQyLFxuICAzODI6IDE1OFxufTtcbmNvbnN0IGNoYXJhY3RlcnMgPSBgXFxcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4gIFxuc3BhY2UgICAgICAgICBleGNsYW0gICAgICAgICBxdW90ZWRibCAgICAgICBudW1iZXJzaWduXG5kb2xsYXIgICAgICAgIHBlcmNlbnQgICAgICAgIGFtcGVyc2FuZCAgICAgIHF1b3Rlc2luZ2xlXG5wYXJlbmxlZnQgICAgIHBhcmVucmlnaHQgICAgIGFzdGVyaXNrICAgICAgIHBsdXNcbmNvbW1hICAgICAgICAgaHlwaGVuICAgICAgICAgcGVyaW9kICAgICAgICAgc2xhc2hcbnplcm8gICAgICAgICAgb25lICAgICAgICAgICAgdHdvICAgICAgICAgICAgdGhyZWVcbmZvdXIgICAgICAgICAgZml2ZSAgICAgICAgICAgc2l4ICAgICAgICAgICAgc2V2ZW5cbmVpZ2h0ICAgICAgICAgbmluZSAgICAgICAgICAgY29sb24gICAgICAgICAgc2VtaWNvbG9uXG5sZXNzICAgICAgICAgIGVxdWFsICAgICAgICAgIGdyZWF0ZXIgICAgICAgIHF1ZXN0aW9uXG4gIFxuYXQgICAgICAgICAgICBBICAgICAgICAgICAgICBCICAgICAgICAgICAgICBDXG5EICAgICAgICAgICAgIEUgICAgICAgICAgICAgIEYgICAgICAgICAgICAgIEdcbkggICAgICAgICAgICAgSSAgICAgICAgICAgICAgSiAgICAgICAgICAgICAgS1xuTCAgICAgICAgICAgICBNICAgICAgICAgICAgICBOICAgICAgICAgICAgICBPXG5QICAgICAgICAgICAgIFEgICAgICAgICAgICAgIFIgICAgICAgICAgICAgIFNcblQgICAgICAgICAgICAgVSAgICAgICAgICAgICAgViAgICAgICAgICAgICAgV1xuWCAgICAgICAgICAgICBZICAgICAgICAgICAgICBaICAgICAgICAgICAgICBicmFja2V0bGVmdFxuYmFja3NsYXNoICAgICBicmFja2V0cmlnaHQgICBhc2NpaWNpcmN1bSAgICB1bmRlcnNjb3JlXG4gIFxuZ3JhdmUgICAgICAgICBhICAgICAgICAgICAgICBiICAgICAgICAgICAgICBjXG5kICAgICAgICAgICAgIGUgICAgICAgICAgICAgIGYgICAgICAgICAgICAgIGdcbmggICAgICAgICAgICAgaSAgICAgICAgICAgICAgaiAgICAgICAgICAgICAga1xubCAgICAgICAgICAgICBtICAgICAgICAgICAgICBuICAgICAgICAgICAgICBvXG5wICAgICAgICAgICAgIHEgICAgICAgICAgICAgIHIgICAgICAgICAgICAgIHNcbnQgICAgICAgICAgICAgdSAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgd1xueCAgICAgICAgICAgICB5ICAgICAgICAgICAgICB6ICAgICAgICAgICAgICBicmFjZWxlZnRcbmJhciAgICAgICAgICAgYnJhY2VyaWdodCAgICAgYXNjaWl0aWxkZSAgICAgLm5vdGRlZlxuICBcbkV1cm8gICAgICAgICAgLm5vdGRlZiAgICAgICAgcXVvdGVzaW5nbGJhc2UgZmxvcmluXG5xdW90ZWRibGJhc2UgIGVsbGlwc2lzICAgICAgIGRhZ2dlciAgICAgICAgIGRhZ2dlcmRibFxuY2lyY3VtZmxleCAgICBwZXJ0aG91c2FuZCAgICBTY2Fyb24gICAgICAgICBndWlsc2luZ2xsZWZ0XG5PRSAgICAgICAgICAgIC5ub3RkZWYgICAgICAgIFpjYXJvbiAgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgcXVvdGVsZWZ0ICAgICAgcXVvdGVyaWdodCAgICAgcXVvdGVkYmxsZWZ0XG5xdW90ZWRibHJpZ2h0IGJ1bGxldCAgICAgICAgIGVuZGFzaCAgICAgICAgIGVtZGFzaFxudGlsZGUgICAgICAgICB0cmFkZW1hcmsgICAgICBzY2Fyb24gICAgICAgICBndWlsc2luZ2xyaWdodFxub2UgICAgICAgICAgICAubm90ZGVmICAgICAgICB6Y2Fyb24gICAgICAgICB5ZGllcmVzaXNcbiAgXG5zcGFjZSAgICAgICAgIGV4Y2xhbWRvd24gICAgIGNlbnQgICAgICAgICAgIHN0ZXJsaW5nXG5jdXJyZW5jeSAgICAgIHllbiAgICAgICAgICAgIGJyb2tlbmJhciAgICAgIHNlY3Rpb25cbmRpZXJlc2lzICAgICAgY29weXJpZ2h0ICAgICAgb3JkZmVtaW5pbmUgICAgZ3VpbGxlbW90bGVmdFxubG9naWNhbG5vdCAgICBoeXBoZW4gICAgICAgICByZWdpc3RlcmVkICAgICBtYWNyb25cbmRlZ3JlZSAgICAgICAgcGx1c21pbnVzICAgICAgdHdvc3VwZXJpb3IgICAgdGhyZWVzdXBlcmlvclxuYWN1dGUgICAgICAgICBtdSAgICAgICAgICAgICBwYXJhZ3JhcGggICAgICBwZXJpb2RjZW50ZXJlZFxuY2VkaWxsYSAgICAgICBvbmVzdXBlcmlvciAgICBvcmRtYXNjdWxpbmUgICBndWlsbGVtb3RyaWdodFxub25lcXVhcnRlciAgICBvbmVoYWxmICAgICAgICB0aHJlZXF1YXJ0ZXJzICBxdWVzdGlvbmRvd25cbiAgXG5BZ3JhdmUgICAgICAgIEFhY3V0ZSAgICAgICAgIEFjaXJjdW1mbGV4ICAgIEF0aWxkZVxuQWRpZXJlc2lzICAgICBBcmluZyAgICAgICAgICBBRSAgICAgICAgICAgICBDY2VkaWxsYVxuRWdyYXZlICAgICAgICBFYWN1dGUgICAgICAgICBFY2lyY3VtZmxleCAgICBFZGllcmVzaXNcbklncmF2ZSAgICAgICAgSWFjdXRlICAgICAgICAgSWNpcmN1bWZsZXggICAgSWRpZXJlc2lzXG5FdGggICAgICAgICAgIE50aWxkZSAgICAgICAgIE9ncmF2ZSAgICAgICAgIE9hY3V0ZVxuT2NpcmN1bWZsZXggICBPdGlsZGUgICAgICAgICBPZGllcmVzaXMgICAgICBtdWx0aXBseVxuT3NsYXNoICAgICAgICBVZ3JhdmUgICAgICAgICBVYWN1dGUgICAgICAgICBVY2lyY3VtZmxleFxuVWRpZXJlc2lzICAgICBZYWN1dGUgICAgICAgICBUaG9ybiAgICAgICAgICBnZXJtYW5kYmxzXG4gIFxuYWdyYXZlICAgICAgICBhYWN1dGUgICAgICAgICBhY2lyY3VtZmxleCAgICBhdGlsZGVcbmFkaWVyZXNpcyAgICAgYXJpbmcgICAgICAgICAgYWUgICAgICAgICAgICAgY2NlZGlsbGFcbmVncmF2ZSAgICAgICAgZWFjdXRlICAgICAgICAgZWNpcmN1bWZsZXggICAgZWRpZXJlc2lzXG5pZ3JhdmUgICAgICAgIGlhY3V0ZSAgICAgICAgIGljaXJjdW1mbGV4ICAgIGlkaWVyZXNpc1xuZXRoICAgICAgICAgICBudGlsZGUgICAgICAgICBvZ3JhdmUgICAgICAgICBvYWN1dGVcbm9jaXJjdW1mbGV4ICAgb3RpbGRlICAgICAgICAgb2RpZXJlc2lzICAgICAgZGl2aWRlXG5vc2xhc2ggICAgICAgIHVncmF2ZSAgICAgICAgIHVhY3V0ZSAgICAgICAgIHVjaXJjdW1mbGV4XG51ZGllcmVzaXMgICAgIHlhY3V0ZSAgICAgICAgIHRob3JuICAgICAgICAgIHlkaWVyZXNpc1xcXG5gLnNwbGl0KC9cXHMrLyk7XG5jbGFzcyBBRk1Gb250IHtcbiAgc3RhdGljIG9wZW4oZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEFGTUZvbnQoZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250ZW50cykge1xuICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cztcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmdseXBoV2lkdGhzID0ge307XG4gICAgdGhpcy5ib3VuZGluZ0JveGVzID0ge307XG4gICAgdGhpcy5rZXJuUGFpcnMgPSB7fTtcbiAgICB0aGlzLnBhcnNlKCk7XG4gICAgLy8gdG9kbzogcmVtb3ZlIGNoYXJXaWR0aHMgc2luY2UgYXBwZWFycyB0byBub3QgYmUgdXNlZFxuICAgIHRoaXMuY2hhcldpZHRocyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGNoYXIgPSAwOyBjaGFyIDw9IDI1NTsgY2hhcisrKSB7XG4gICAgICB0aGlzLmNoYXJXaWR0aHNbY2hhcl0gPSB0aGlzLmdseXBoV2lkdGhzW2NoYXJhY3RlcnNbY2hhcl1dO1xuICAgIH1cbiAgICB0aGlzLmJib3ggPSB0aGlzLmF0dHJpYnV0ZXNbJ0ZvbnRCQm94J10uc3BsaXQoL1xccysvKS5tYXAoZSA9PiArZSk7XG4gICAgdGhpcy5hc2NlbmRlciA9ICsodGhpcy5hdHRyaWJ1dGVzWydBc2NlbmRlciddIHx8IDApO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gKyh0aGlzLmF0dHJpYnV0ZXNbJ0Rlc2NlbmRlciddIHx8IDApO1xuICAgIHRoaXMueEhlaWdodCA9ICsodGhpcy5hdHRyaWJ1dGVzWydYSGVpZ2h0J10gfHwgMCk7XG4gICAgdGhpcy5jYXBIZWlnaHQgPSArKHRoaXMuYXR0cmlidXRlc1snQ2FwSGVpZ2h0J10gfHwgMCk7XG4gICAgdGhpcy5saW5lR2FwID0gdGhpcy5iYm94WzNdIC0gdGhpcy5iYm94WzFdIC0gKHRoaXMuYXNjZW5kZXIgLSB0aGlzLmRlc2NlbmRlcik7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgbGV0IHNlY3Rpb24gPSAnJztcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMuY29udGVudHMuc3BsaXQoJ1xcbicpKSB7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgYTtcbiAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goL15TdGFydChcXHcrKS8pKSB7XG4gICAgICAgIHNlY3Rpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaCgvXkVuZChcXHcrKS8pKSB7XG4gICAgICAgIHNlY3Rpb24gPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHNlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnRm9udE1ldHJpY3MnOlxuICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvKF5cXHcrKVxccysoLiopLyk7XG4gICAgICAgICAgdmFyIGtleSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgICAgIGlmIChhID0gdGhpcy5hdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgICBhID0gdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSBbYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ2hhck1ldHJpY3MnOlxuICAgICAgICAgIGlmICghL15DSD9cXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IGxpbmUubWF0Y2goL1xcYk5cXHMrKFxcLj9cXHcrKVxccyo7LylbMV07XG4gICAgICAgICAgdGhpcy5nbHlwaFdpZHRoc1tuYW1lXSA9ICtsaW5lLm1hdGNoKC9cXGJXWFxccysoXFxkKylcXHMqOy8pWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLZXJuUGFpcnMnOlxuICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvXktQWFxccysoXFwuP1xcdyspXFxzKyhcXC4/XFx3KylcXHMrKC0/XFxkKykvKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMua2VyblBhaXJzW21hdGNoWzFdICsgJ1xcMCcgKyBtYXRjaFsyXV0gPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmNvZGVUZXh0KHRleHQpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGNoYXIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjaGFyID0gV0lOX0FOU0lfTUFQW2NoYXJdIHx8IGNoYXI7XG4gICAgICByZXMucHVzaChjaGFyLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZ2x5cGhzRm9yU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IGdseXBocyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBnbHlwaHMucHVzaCh0aGlzLmNoYXJhY3RlclRvR2x5cGgoY2hhckNvZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdseXBocztcbiAgfVxuICBjaGFyYWN0ZXJUb0dseXBoKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXJzW1dJTl9BTlNJX01BUFtjaGFyYWN0ZXJdIHx8IGNoYXJhY3Rlcl0gfHwgJy5ub3RkZWYnO1xuICB9XG4gIHdpZHRoT2ZHbHlwaChnbHlwaCkge1xuICAgIHJldHVybiB0aGlzLmdseXBoV2lkdGhzW2dseXBoXSB8fCAwO1xuICB9XG4gIGdldEtlcm5QYWlyKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMua2VyblBhaXJzW2xlZnQgKyAnXFwwJyArIHJpZ2h0XSB8fCAwO1xuICB9XG4gIGFkdmFuY2VzRm9yR2x5cGhzKGdseXBocykge1xuICAgIGNvbnN0IGFkdmFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGdseXBocy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnbHlwaHNbaW5kZXhdO1xuICAgICAgY29uc3QgcmlnaHQgPSBnbHlwaHNbaW5kZXggKyAxXTtcbiAgICAgIGFkdmFuY2VzLnB1c2godGhpcy53aWR0aE9mR2x5cGgobGVmdCkgKyB0aGlzLmdldEtlcm5QYWlyKGxlZnQsIHJpZ2h0KSk7XG4gICAgfVxuICAgIHJldHVybiBhZHZhbmNlcztcbiAgfVxufVxuXG5jbGFzcyBQREZGb250IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuICBlbmNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgfVxuICB3aWR0aE9mU3RyaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkgIT0gbnVsbCA/IHRoaXMuZGljdGlvbmFyeSA6IHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gIH1cbiAgZmluYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZW1iZWRkZWQgfHwgdGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWJlZCgpO1xuICAgIHJldHVybiB0aGlzLmVtYmVkZGVkID0gdHJ1ZTtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG4gIGxpbmVIZWlnaHQoc2l6ZSwgaW5jbHVkZUdhcCkge1xuICAgIGlmIChpbmNsdWRlR2FwID09IG51bGwpIHtcbiAgICAgIGluY2x1ZGVHYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZ2FwID0gaW5jbHVkZUdhcCA/IHRoaXMubGluZUdhcCA6IDA7XG4gICAgcmV0dXJuICh0aGlzLmFzY2VuZGVyICsgZ2FwIC0gdGhpcy5kZXNjZW5kZXIpIC8gMTAwMCAqIHNpemU7XG4gIH1cbn1cblxuLy8gVGhpcyBpbnNhbml0eSBpcyBzbyBidW5kbGVycyBjYW4gaW5saW5lIHRoZSBmb250IGZpbGVzXG5jb25zdCBTVEFOREFSRF9GT05UUyA9IHtcbiAgQ291cmllcigpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdDb3VyaWVyLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItQm9sZC5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnQ291cmllci1PYmxpcXVlJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLU9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0NvdXJpZXItQm9sZE9ibGlxdWUnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItQm9sZE9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgSGVsdmV0aWNhKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnSGVsdmV0aWNhLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS1Cb2xkLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdIZWx2ZXRpY2EtT2JsaXF1ZScoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLU9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0hlbHZldGljYS1Cb2xkT2JsaXF1ZScoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLUJvbGRPYmxpcXVlLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdUaW1lcy1Sb21hbicoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvVGltZXMtUm9tYW4uYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUJvbGQnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLUJvbGQuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUl0YWxpYycoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvVGltZXMtSXRhbGljLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdUaW1lcy1Cb2xkSXRhbGljJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9UaW1lcy1Cb2xkSXRhbGljLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gIFN5bWJvbCgpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9TeW1ib2wuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgWmFwZkRpbmdiYXRzKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1phcGZEaW5nYmF0cy5hZm0nLCAndXRmOCcpO1xuICB9XG59O1xuY2xhc3MgU3RhbmRhcmRGb250IGV4dGVuZHMgUERGRm9udCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCBpZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZm9udCA9IG5ldyBBRk1Gb250KFNUQU5EQVJEX0ZPTlRTW3RoaXMubmFtZV0oKSk7XG4gICAgKHtcbiAgICAgIGFzY2VuZGVyOiB0aGlzLmFzY2VuZGVyLFxuICAgICAgZGVzY2VuZGVyOiB0aGlzLmRlc2NlbmRlcixcbiAgICAgIGJib3g6IHRoaXMuYmJveCxcbiAgICAgIGxpbmVHYXA6IHRoaXMubGluZUdhcCxcbiAgICAgIHhIZWlnaHQ6IHRoaXMueEhlaWdodCxcbiAgICAgIGNhcEhlaWdodDogdGhpcy5jYXBIZWlnaHRcbiAgICB9ID0gdGhpcy5mb250KTtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YSA9IHtcbiAgICAgIFR5cGU6ICdGb250JyxcbiAgICAgIEJhc2VGb250OiB0aGlzLm5hbWUsXG4gICAgICBTdWJ0eXBlOiAnVHlwZTEnLFxuICAgICAgRW5jb2Rpbmc6ICdXaW5BbnNpRW5jb2RpbmcnXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICB9XG4gIGVuY29kZSh0ZXh0KSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuZm9udC5lbmNvZGVUZXh0KHRleHQpO1xuICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHNGb3JTdHJpbmcoYCR7dGV4dH1gKTtcbiAgICBjb25zdCBhZHZhbmNlcyA9IHRoaXMuZm9udC5hZHZhbmNlc0ZvckdseXBocyhnbHlwaHMpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgeEFkdmFuY2U6IGFkdmFuY2VzW2ldLFxuICAgICAgICB5QWR2YW5jZTogMCxcbiAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgeU9mZnNldDogMCxcbiAgICAgICAgYWR2YW5jZVdpZHRoOiB0aGlzLmZvbnQud2lkdGhPZkdseXBoKGdseXBoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbZW5jb2RlZCwgcG9zaXRpb25zXTtcbiAgfVxuICB3aWR0aE9mU3RyaW5nKHN0cmluZywgc2l6ZSkge1xuICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHNGb3JTdHJpbmcoYCR7c3RyaW5nfWApO1xuICAgIGNvbnN0IGFkdmFuY2VzID0gdGhpcy5mb250LmFkdmFuY2VzRm9yR2x5cGhzKGdseXBocyk7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBhZHZhbmNlIG9mIGFkdmFuY2VzKSB7XG4gICAgICB3aWR0aCArPSBhZHZhbmNlO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZSA9IHNpemUgLyAxMDAwO1xuICAgIHJldHVybiB3aWR0aCAqIHNjYWxlO1xuICB9XG4gIHN0YXRpYyBpc1N0YW5kYXJkRm9udChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gU1RBTkRBUkRfRk9OVFM7XG4gIH1cbn1cblxuY29uc3QgdG9IZXggPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBgMDAwMCR7bnVtLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC00KTtcbn07XG5jbGFzcyBFbWJlZGRlZEZvbnQgZXh0ZW5kcyBQREZGb250IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGZvbnQsIGlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zdWJzZXQgPSB0aGlzLmZvbnQuY3JlYXRlU3Vic2V0KCk7XG4gICAgdGhpcy51bmljb2RlID0gW1swXV07XG4gICAgdGhpcy53aWR0aHMgPSBbdGhpcy5mb250LmdldEdseXBoKDApLmFkdmFuY2VXaWR0aF07XG4gICAgdGhpcy5uYW1lID0gdGhpcy5mb250LnBvc3RzY3JpcHROYW1lO1xuICAgIHRoaXMuc2NhbGUgPSAxMDAwIC8gdGhpcy5mb250LnVuaXRzUGVyRW07XG4gICAgdGhpcy5hc2NlbmRlciA9IHRoaXMuZm9udC5hc2NlbnQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gdGhpcy5mb250LmRlc2NlbnQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMueEhlaWdodCA9IHRoaXMuZm9udC54SGVpZ2h0ICogdGhpcy5zY2FsZTtcbiAgICB0aGlzLmNhcEhlaWdodCA9IHRoaXMuZm9udC5jYXBIZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMubGluZUdhcCA9IHRoaXMuZm9udC5saW5lR2FwICogdGhpcy5zY2FsZTtcbiAgICB0aGlzLmJib3ggPSB0aGlzLmZvbnQuYmJveDtcbiAgICBpZiAoZG9jdW1lbnQub3B0aW9ucy5mb250TGF5b3V0Q2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxheW91dENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH1cbiAgbGF5b3V0UnVuKHRleHQsIGZlYXR1cmVzKSB7XG4gICAgY29uc3QgcnVuID0gdGhpcy5mb250LmxheW91dCh0ZXh0LCBmZWF0dXJlcyk7XG5cbiAgICAvLyBOb3JtYWxpemUgcG9zaXRpb24gdmFsdWVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydW4ucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJ1bi5wb3NpdGlvbnNbaV07XG4gICAgICBmb3IgKGxldCBrZXkgaW4gcG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb25ba2V5XSAqPSB0aGlzLnNjYWxlO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24uYWR2YW5jZVdpZHRoID0gcnVuLmdseXBoc1tpXS5hZHZhbmNlV2lkdGggKiB0aGlzLnNjYWxlO1xuICAgIH1cbiAgICByZXR1cm4gcnVuO1xuICB9XG4gIGxheW91dENhY2hlZCh0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLmxheW91dENhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXRSdW4odGV4dCk7XG4gICAgfVxuICAgIGxldCBjYWNoZWQ7XG4gICAgaWYgKGNhY2hlZCA9IHRoaXMubGF5b3V0Q2FjaGVbdGV4dF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJ1biA9IHRoaXMubGF5b3V0UnVuKHRleHQpO1xuICAgIHRoaXMubGF5b3V0Q2FjaGVbdGV4dF0gPSBydW47XG4gICAgcmV0dXJuIHJ1bjtcbiAgfVxuICBsYXlvdXQodGV4dCwgZmVhdHVyZXMsIG9ubHlXaWR0aCkge1xuICAgIC8vIFNraXAgdGhlIGNhY2hlIGlmIGFueSB1c2VyIGRlZmluZWQgZmVhdHVyZXMgYXJlIGFwcGxpZWRcbiAgICBpZiAoZmVhdHVyZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dFJ1bih0ZXh0LCBmZWF0dXJlcyk7XG4gICAgfVxuICAgIGxldCBnbHlwaHMgPSBvbmx5V2lkdGggPyBudWxsIDogW107XG4gICAgbGV0IHBvc2l0aW9ucyA9IG9ubHlXaWR0aCA/IG51bGwgOiBbXTtcbiAgICBsZXQgYWR2YW5jZVdpZHRoID0gMDtcblxuICAgIC8vIFNwbGl0IHRoZSBzdHJpbmcgYnkgd29yZHMgdG8gaW5jcmVhc2UgY2FjaGUgZWZmaWNpZW5jeS5cbiAgICAvLyBGb3IgdGhpcyBwdXJwb3NlLCBzcGFjZXMgYW5kIHRhYnMgYXJlIGEgZ29vZCBlbm91Z2ggZGVsaW1ldGVyLlxuICAgIGxldCBsYXN0ID0gMDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIG5lZWRsZTtcbiAgICAgIGlmIChpbmRleCA9PT0gdGV4dC5sZW5ndGggJiYgbGFzdCA8IGluZGV4IHx8IChuZWVkbGUgPSB0ZXh0LmNoYXJBdChpbmRleCksIFsnICcsICdcXHQnXS5pbmNsdWRlcyhuZWVkbGUpKSkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLmxheW91dENhY2hlZCh0ZXh0LnNsaWNlKGxhc3QsICsraW5kZXgpKTtcbiAgICAgICAgaWYgKCFvbmx5V2lkdGgpIHtcbiAgICAgICAgICBnbHlwaHMgPSBnbHlwaHMuY29uY2F0KHJ1bi5nbHlwaHMpO1xuICAgICAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQocnVuLnBvc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZVdpZHRoICs9IHJ1bi5hZHZhbmNlV2lkdGg7XG4gICAgICAgIGxhc3QgPSBpbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBnbHlwaHMsXG4gICAgICBwb3NpdGlvbnMsXG4gICAgICBhZHZhbmNlV2lkdGhcbiAgICB9O1xuICB9XG4gIGVuY29kZSh0ZXh0LCBmZWF0dXJlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdseXBocyxcbiAgICAgIHBvc2l0aW9uc1xuICAgIH0gPSB0aGlzLmxheW91dCh0ZXh0LCBmZWF0dXJlcyk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgY29uc3QgZ2lkID0gdGhpcy5zdWJzZXQuaW5jbHVkZUdseXBoKGdseXBoLmlkKTtcbiAgICAgIHJlcy5wdXNoKGAwMDAwJHtnaWQudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTQpKTtcbiAgICAgIGlmICh0aGlzLndpZHRoc1tnaWRdID09IG51bGwpIHtcbiAgICAgICAgdGhpcy53aWR0aHNbZ2lkXSA9IGdseXBoLmFkdmFuY2VXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bmljb2RlW2dpZF0gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuaWNvZGVbZ2lkXSA9IGdseXBoLmNvZGVQb2ludHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcmVzLCBwb3NpdGlvbnNdO1xuICB9XG4gIHdpZHRoT2ZTdHJpbmcoc3RyaW5nLCBzaXplLCBmZWF0dXJlcykge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5sYXlvdXQoc3RyaW5nLCBmZWF0dXJlcywgdHJ1ZSkuYWR2YW5jZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gc2l6ZSAvIDEwMDA7XG4gICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gIH1cbiAgZW1iZWQoKSB7XG4gICAgY29uc3QgaXNDRkYgPSB0aGlzLnN1YnNldC5jZmYgIT0gbnVsbDtcbiAgICBjb25zdCBmb250RmlsZSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgaWYgKGlzQ0ZGKSB7XG4gICAgICBmb250RmlsZS5kYXRhLlN1YnR5cGUgPSAnQ0lERm9udFR5cGUwQyc7XG4gICAgfVxuICAgIHRoaXMuc3Vic2V0LmVuY29kZVN0cmVhbSgpLm9uKCdkYXRhJywgZGF0YSA9PiBmb250RmlsZS53cml0ZShkYXRhKSkub24oJ2VuZCcsICgpID0+IGZvbnRGaWxlLmVuZCgpKTtcbiAgICBjb25zdCBmYW1pbHlDbGFzcyA9ICgodGhpcy5mb250WydPUy8yJ10gIT0gbnVsbCA/IHRoaXMuZm9udFsnT1MvMiddLnNGYW1pbHlDbGFzcyA6IHVuZGVmaW5lZCkgfHwgMCkgPj4gODtcbiAgICBsZXQgZmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLmZvbnQucG9zdC5pc0ZpeGVkUGl0Y2gpIHtcbiAgICAgIGZsYWdzIHw9IDEgPDwgMDtcbiAgICB9XG4gICAgaWYgKDEgPD0gZmFtaWx5Q2xhc3MgJiYgZmFtaWx5Q2xhc3MgPD0gNykge1xuICAgICAgZmxhZ3MgfD0gMSA8PCAxO1xuICAgIH1cbiAgICBmbGFncyB8PSAxIDw8IDI7IC8vIGFzc3VtZSB0aGUgZm9udCB1c2VzIG5vbi1sYXRpbiBjaGFyYWN0ZXJzXG4gICAgaWYgKGZhbWlseUNsYXNzID09PSAxMCkge1xuICAgICAgZmxhZ3MgfD0gMSA8PCAzO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb250LmhlYWQubWFjU3R5bGUuaXRhbGljKSB7XG4gICAgICBmbGFncyB8PSAxIDw8IDY7XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgYSB0YWcgKDYgdXBwZXJjYXNlIGxldHRlcnMuIDE3IGlzIHRoZSBjaGFyIGNvZGUgb2Zmc2V0IGZyb20gJzAnIHRvICdBJy4gNzMgd2lsbCBtYXAgdG8gJ1onKVxuICAgIGNvbnN0IHRhZyA9IFsxLCAyLCAzLCA0LCA1LCA2XS5tYXAoaSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKCh0aGlzLmlkLmNoYXJDb2RlQXQoaSkgfHwgNzMpICsgMTcpKS5qb2luKCcnKTtcbiAgICBjb25zdCBuYW1lID0gdGFnICsgJysnICsgdGhpcy5mb250LnBvc3RzY3JpcHROYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIGJib3hcbiAgICB9ID0gdGhpcy5mb250O1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBUeXBlOiAnRm9udERlc2NyaXB0b3InLFxuICAgICAgRm9udE5hbWU6IG5hbWUsXG4gICAgICBGbGFnczogZmxhZ3MsXG4gICAgICBGb250QkJveDogW2Jib3gubWluWCAqIHRoaXMuc2NhbGUsIGJib3gubWluWSAqIHRoaXMuc2NhbGUsIGJib3gubWF4WCAqIHRoaXMuc2NhbGUsIGJib3gubWF4WSAqIHRoaXMuc2NhbGVdLFxuICAgICAgSXRhbGljQW5nbGU6IHRoaXMuZm9udC5pdGFsaWNBbmdsZSxcbiAgICAgIEFzY2VudDogdGhpcy5hc2NlbmRlcixcbiAgICAgIERlc2NlbnQ6IHRoaXMuZGVzY2VuZGVyLFxuICAgICAgQ2FwSGVpZ2h0OiAodGhpcy5mb250LmNhcEhlaWdodCB8fCB0aGlzLmZvbnQuYXNjZW50KSAqIHRoaXMuc2NhbGUsXG4gICAgICBYSGVpZ2h0OiAodGhpcy5mb250LnhIZWlnaHQgfHwgMCkgKiB0aGlzLnNjYWxlLFxuICAgICAgU3RlbVY6IDBcbiAgICB9KTsgLy8gbm90IHN1cmUgaG93IHRvIGNhbGN1bGF0ZSB0aGlzXG5cbiAgICBpZiAoaXNDRkYpIHtcbiAgICAgIGRlc2NyaXB0b3IuZGF0YS5Gb250RmlsZTMgPSBmb250RmlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvci5kYXRhLkZvbnRGaWxlMiA9IGZvbnRGaWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kb2N1bWVudC5zdWJzZXQgJiYgdGhpcy5kb2N1bWVudC5zdWJzZXQgPT09IDEpIHtcbiAgICAgIGNvbnN0IENJRFNldCA9IEJ1ZmZlci5mcm9tKCdGRkZGRkZGRkMwJywgJ2hleCcpO1xuICAgICAgY29uc3QgQ0lEU2V0UmVmID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcbiAgICAgIENJRFNldFJlZi53cml0ZShDSURTZXQpO1xuICAgICAgQ0lEU2V0UmVmLmVuZCgpO1xuICAgICAgZGVzY3JpcHRvci5kYXRhLkNJRFNldCA9IENJRFNldFJlZjtcbiAgICB9XG4gICAgZGVzY3JpcHRvci5lbmQoKTtcbiAgICBjb25zdCBkZXNjZW5kYW50Rm9udERhdGEgPSB7XG4gICAgICBUeXBlOiAnRm9udCcsXG4gICAgICBTdWJ0eXBlOiAnQ0lERm9udFR5cGUwJyxcbiAgICAgIEJhc2VGb250OiBuYW1lLFxuICAgICAgQ0lEU3lzdGVtSW5mbzoge1xuICAgICAgICBSZWdpc3RyeTogbmV3IFN0cmluZygnQWRvYmUnKSxcbiAgICAgICAgT3JkZXJpbmc6IG5ldyBTdHJpbmcoJ0lkZW50aXR5JyksXG4gICAgICAgIFN1cHBsZW1lbnQ6IDBcbiAgICAgIH0sXG4gICAgICBGb250RGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgIFc6IFswLCB0aGlzLndpZHRoc11cbiAgICB9O1xuICAgIGlmICghaXNDRkYpIHtcbiAgICAgIGRlc2NlbmRhbnRGb250RGF0YS5TdWJ0eXBlID0gJ0NJREZvbnRUeXBlMic7XG4gICAgICBkZXNjZW5kYW50Rm9udERhdGEuQ0lEVG9HSURNYXAgPSAnSWRlbnRpdHknO1xuICAgIH1cbiAgICBjb25zdCBkZXNjZW5kYW50Rm9udCA9IHRoaXMuZG9jdW1lbnQucmVmKGRlc2NlbmRhbnRGb250RGF0YSk7XG4gICAgZGVzY2VuZGFudEZvbnQuZW5kKCk7XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEgPSB7XG4gICAgICBUeXBlOiAnRm9udCcsXG4gICAgICBTdWJ0eXBlOiAnVHlwZTAnLFxuICAgICAgQmFzZUZvbnQ6IG5hbWUsXG4gICAgICBFbmNvZGluZzogJ0lkZW50aXR5LUgnLFxuICAgICAgRGVzY2VuZGFudEZvbnRzOiBbZGVzY2VuZGFudEZvbnRdLFxuICAgICAgVG9Vbmljb2RlOiB0aGlzLnRvVW5pY29kZUNtYXAoKVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgfVxuXG4gIC8vIE1hcHMgdGhlIGdseXBoIGlkcyBlbmNvZGVkIGluIHRoZSBQREYgYmFjayB0byB1bmljb2RlIHN0cmluZ3NcbiAgLy8gQmVjYXVzZSBvZiBsaWdhdHVyZSBzdWJzdGl0dXRpb25zIGFuZCB0aGUgbGlrZSwgdGhlcmUgbWF5IGJlIG9uZSBvciBtb3JlXG4gIC8vIHVuaWNvZGUgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBlYWNoIGdseXBoLlxuICB0b1VuaWNvZGVDbWFwKCkge1xuICAgIGNvbnN0IGNtYXAgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGxldCBjb2RlUG9pbnRzIG9mIHRoaXMudW5pY29kZSkge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IFtdO1xuXG4gICAgICAvLyBlbmNvZGUgY29kZVBvaW50cyB0byB1dGYxNlxuICAgICAgZm9yIChsZXQgdmFsdWUgb2YgY29kZVBvaW50cykge1xuICAgICAgICBpZiAodmFsdWUgPiAweGZmZmYpIHtcbiAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgIGVuY29kZWQucHVzaCh0b0hleCh2YWx1ZSA+Pj4gMTAgJiAweDNmZiB8IDB4ZDgwMCkpO1xuICAgICAgICAgIHZhbHVlID0gMHhkYzAwIHwgdmFsdWUgJiAweDNmZjtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkLnB1c2godG9IZXgodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVudHJpZXMucHVzaChgPCR7ZW5jb2RlZC5qb2luKCcgJyl9PmApO1xuICAgIH1cbiAgICBjb25zdCBjaHVua1NpemUgPSAyNTY7XG4gICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGVudHJpZXMubGVuZ3RoIC8gY2h1bmtTaXplKTtcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGkgKiBjaHVua1NpemU7XG4gICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbigoaSArIDEpICogY2h1bmtTaXplLCBlbnRyaWVzLmxlbmd0aCk7XG4gICAgICByYW5nZXMucHVzaChgPCR7dG9IZXgoc3RhcnQpfT4gPCR7dG9IZXgoZW5kIC0gMSl9PiBbJHtlbnRyaWVzLnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJyAnKX1dYCk7XG4gICAgfVxuICAgIGNtYXAuZW5kKGBcXFxuL0NJREluaXQgL1Byb2NTZXQgZmluZHJlc291cmNlIGJlZ2luXG4xMiBkaWN0IGJlZ2luXG5iZWdpbmNtYXBcbi9DSURTeXN0ZW1JbmZvIDw8XG4gIC9SZWdpc3RyeSAoQWRvYmUpXG4gIC9PcmRlcmluZyAoVUNTKVxuICAvU3VwcGxlbWVudCAwXG4+PiBkZWZcbi9DTWFwTmFtZSAvQWRvYmUtSWRlbnRpdHktVUNTIGRlZlxuL0NNYXBUeXBlIDIgZGVmXG4xIGJlZ2luY29kZXNwYWNlcmFuZ2VcbjwwMDAwPjxmZmZmPlxuZW5kY29kZXNwYWNlcmFuZ2VcbjEgYmVnaW5iZnJhbmdlXG4ke3Jhbmdlcy5qb2luKCdcXG4nKX1cbmVuZGJmcmFuZ2VcbmVuZGNtYXBcbkNNYXBOYW1lIGN1cnJlbnRkaWN0IC9DTWFwIGRlZmluZXJlc291cmNlIHBvcFxuZW5kXG5lbmRcXFxuYCk7XG4gICAgcmV0dXJuIGNtYXA7XG4gIH1cbn1cblxuY2xhc3MgUERGRm9udEZhY3Rvcnkge1xuICBzdGF0aWMgb3Blbihkb2N1bWVudCwgc3JjLCBmYW1pbHksIGlkKSB7XG4gICAgbGV0IGZvbnQ7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoU3RhbmRhcmRGb250LmlzU3RhbmRhcmRGb250KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFuZGFyZEZvbnQoZG9jdW1lbnQsIHNyYywgaWQpO1xuICAgICAgfVxuICAgICAgc3JjID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgICAgZm9udCA9IGZvbnRraXQuY3JlYXRlKHNyYywgZmFtaWx5KTtcbiAgICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZvbnQgPSBmb250a2l0LmNyZWF0ZShCdWZmZXIuZnJvbShzcmMpLCBmYW1pbHkpO1xuICAgIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGZvbnQgPSBmb250a2l0LmNyZWF0ZShCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzcmMpKSwgZmFtaWx5KTtcbiAgICB9XG4gICAgaWYgKGZvbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBzdXBwb3J0ZWQgZm9udCBmb3JtYXQgb3Igc3RhbmRhcmQgUERGIGZvbnQuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRW1iZWRkZWRGb250KGRvY3VtZW50LCBmb250LCBpZCk7XG4gIH1cbn1cblxudmFyIEZvbnRzTWl4aW4gPSB7XG4gIGluaXRGb250cygpIHtcbiAgICBsZXQgZGVmYXVsdEZvbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdIZWx2ZXRpY2EnO1xuICAgIC8vIExvb2t1cCB0YWJsZSBmb3IgZW1iZWRkZWQgZm9udHNcbiAgICB0aGlzLl9mb250RmFtaWxpZXMgPSB7fTtcbiAgICB0aGlzLl9mb250Q291bnQgPSAwO1xuXG4gICAgLy8gRm9udCBzdGF0ZVxuICAgIHRoaXMuX2ZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5fZm9udCA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEZvbnRzID0ge307XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgZm9udFxuICAgIGlmIChkZWZhdWx0Rm9udCkge1xuICAgICAgdGhpcy5mb250KGRlZmF1bHRGb250KTtcbiAgICB9XG4gIH0sXG4gIGZvbnQoc3JjLCBmYW1pbHksIHNpemUpIHtcbiAgICBsZXQgY2FjaGVLZXksIGZvbnQ7XG4gICAgaWYgKHR5cGVvZiBmYW1pbHkgPT09ICdudW1iZXInKSB7XG4gICAgICBzaXplID0gZmFtaWx5O1xuICAgICAgZmFtaWx5ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayByZWdpc3RlcmVkIGZvbnRzIGlmIHNyYyBpcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiB0aGlzLl9yZWdpc3RlcmVkRm9udHNbc3JjXSkge1xuICAgICAgY2FjaGVLZXkgPSBzcmM7XG4gICAgICAoe1xuICAgICAgICBzcmMsXG4gICAgICAgIGZhbWlseVxuICAgICAgfSA9IHRoaXMuX3JlZ2lzdGVyZWRGb250c1tzcmNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVLZXkgPSBmYW1pbHkgfHwgc3JjO1xuICAgICAgaWYgKHR5cGVvZiBjYWNoZUtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2FjaGVLZXkgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2l6ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvbnRTaXplKHNpemUpO1xuICAgIH1cblxuICAgIC8vIGZhc3QgcGF0aDogY2hlY2sgaWYgdGhlIGZvbnQgaXMgYWxyZWFkeSBpbiB0aGUgUERGXG4gICAgaWYgKGZvbnQgPSB0aGlzLl9mb250RmFtaWxpZXNbY2FjaGVLZXldKSB7XG4gICAgICB0aGlzLl9mb250ID0gZm9udDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGxvYWQgdGhlIGZvbnRcbiAgICBjb25zdCBpZCA9IGBGJHsrK3RoaXMuX2ZvbnRDb3VudH1gO1xuICAgIHRoaXMuX2ZvbnQgPSBQREZGb250RmFjdG9yeS5vcGVuKHRoaXMsIHNyYywgZmFtaWx5LCBpZCk7XG5cbiAgICAvLyBjaGVjayBmb3IgZXhpc3RpbmcgZm9udCBmYW1pbGVzIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGluIHRoZSBQREZcbiAgICAvLyB1c2VmdWwgaWYgdGhlIGZvbnQgd2FzIHBhc3NlZCBhcyBhIGJ1ZmZlclxuICAgIGlmIChmb250ID0gdGhpcy5fZm9udEZhbWlsaWVzW3RoaXMuX2ZvbnQubmFtZV0pIHtcbiAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gc2F2ZSB0aGUgZm9udCBmb3IgcmV1c2UgbGF0ZXJcbiAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgIHRoaXMuX2ZvbnRGYW1pbGllc1tjYWNoZUtleV0gPSB0aGlzLl9mb250O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZm9udC5uYW1lKSB7XG4gICAgICB0aGlzLl9mb250RmFtaWxpZXNbdGhpcy5fZm9udC5uYW1lXSA9IHRoaXMuX2ZvbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmb250U2l6ZShfZm9udFNpemUpIHtcbiAgICB0aGlzLl9mb250U2l6ZSA9IF9mb250U2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY3VycmVudExpbmVIZWlnaHQoaW5jbHVkZUdhcCkge1xuICAgIGlmIChpbmNsdWRlR2FwID09IG51bGwpIHtcbiAgICAgIGluY2x1ZGVHYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnQubGluZUhlaWdodCh0aGlzLl9mb250U2l6ZSwgaW5jbHVkZUdhcCk7XG4gIH0sXG4gIHJlZ2lzdGVyRm9udChuYW1lLCBzcmMsIGZhbWlseSkge1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRGb250c1tuYW1lXSA9IHtcbiAgICAgIHNyYyxcbiAgICAgIGZhbWlseVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmNvbnN0IFNPRlRfSFlQSEVOID0gJ1xcdTAwQUQnO1xuY29uc3QgSFlQSEVOID0gJy0nO1xuY2xhc3MgTGluZVdyYXBwZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQgfHwgMDtcbiAgICB0aGlzLmNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gb3B0aW9ucy53b3JkU3BhY2luZyA9PT0gMDtcbiAgICB0aGlzLmNvbHVtbnMgPSBvcHRpb25zLmNvbHVtbnMgfHwgMTtcbiAgICB0aGlzLmNvbHVtbkdhcCA9IG9wdGlvbnMuY29sdW1uR2FwICE9IG51bGwgPyBvcHRpb25zLmNvbHVtbkdhcCA6IDE4OyAvLyAxLzQgaW5jaFxuICAgIHRoaXMubGluZVdpZHRoID0gKG9wdGlvbnMud2lkdGggLSB0aGlzLmNvbHVtbkdhcCAqICh0aGlzLmNvbHVtbnMgLSAxKSkgLyB0aGlzLmNvbHVtbnM7XG4gICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aDtcbiAgICB0aGlzLnN0YXJ0WCA9IHRoaXMuZG9jdW1lbnQueDtcbiAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuZG9jdW1lbnQueTtcbiAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgdGhpcy5lbGxpcHNpcyA9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICB0aGlzLmZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWF4aW11bSBZIHBvc2l0aW9uIHRoZSB0ZXh0IGNhbiBhcHBlYXIgYXRcbiAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgIHRoaXMubWF4WSA9IHRoaXMuc3RhcnRZICsgb3B0aW9ucy5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF4WSA9IHRoaXMuZG9jdW1lbnQucGFnZS5tYXhZKCk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHBhcmFncmFwaCBpbmRlbnRzXG4gICAgdGhpcy5vbignZmlyc3RMaW5lJywgb3B0aW9ucyA9PiB7XG4gICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSB0ZXh0IHNlZ21lbnQsIGFuZFxuICAgICAgLy8gd2UncmUgY29udGludWluZyB3aGVyZSB3ZSBsZWZ0IG9mZiwgaW5kZW50IHRoYXQgbXVjaFxuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgdXNlciBzcGVjaWZpZWQgaW5kZW50IG9wdGlvblxuICAgICAgY29uc3QgaW5kZW50ID0gdGhpcy5jb250aW51ZWRYIHx8IHRoaXMuaW5kZW50O1xuICAgICAgdGhpcy5kb2N1bWVudC54ICs9IGluZGVudDtcbiAgICAgIHRoaXMubGluZVdpZHRoIC09IGluZGVudDtcbiAgICAgIHJldHVybiB0aGlzLm9uY2UoJ2xpbmUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQueCAtPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMubGluZVdpZHRoICs9IGluZGVudDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGludWVkICYmICF0aGlzLmNvbnRpbnVlZFgpIHtcbiAgICAgICAgICB0aGlzLmNvbnRpbnVlZFggPSB0aGlzLmluZGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuY29udGludWVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGludWVkWCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gaGFuZGxlIGxlZnQgYWxpZ25pbmcgbGFzdCBsaW5lcyBvZiBwYXJhZ3JhcGhzXG4gICAgdGhpcy5vbignbGFzdExpbmUnLCBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxpZ25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKGFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgb3B0aW9ucy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdExpbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMub25jZSgnbGluZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC55ICs9IG9wdGlvbnMucGFyYWdyYXBoR2FwIHx8IDA7XG4gICAgICAgIG9wdGlvbnMuYWxpZ24gPSBhbGlnbjtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdExpbmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHdvcmRXaWR0aCh3b3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQud2lkdGhPZlN0cmluZyh3b3JkLCB0aGlzKSArIHRoaXMuY2hhcmFjdGVyU3BhY2luZyArIHRoaXMud29yZFNwYWNpbmc7XG4gIH1cbiAgY2FuRml0KHdvcmQsIHcpIHtcbiAgICBpZiAod29yZFt3b3JkLmxlbmd0aCAtIDFdICE9IFNPRlRfSFlQSEVOKSB7XG4gICAgICByZXR1cm4gdyA8PSB0aGlzLnNwYWNlTGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHcgKyB0aGlzLndvcmRXaWR0aChIWVBIRU4pIDw9IHRoaXMuc3BhY2VMZWZ0O1xuICB9XG4gIGVhY2hXb3JkKHRleHQsIGZuKSB7XG4gICAgLy8gc2V0dXAgYSB1bmljb2RlIGxpbmUgYnJlYWtlclxuICAgIGxldCBiaztcbiAgICBjb25zdCBicmVha2VyID0gbmV3IExpbmVCcmVha2VyKHRleHQpO1xuICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICBjb25zdCB3b3JkV2lkdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB3aGlsZSAoYmsgPSBicmVha2VyLm5leHRCcmVhaygpKSB7XG4gICAgICB2YXIgc2hvdWxkQ29udGludWU7XG4gICAgICBsZXQgd29yZCA9IHRleHQuc2xpY2UoKGxhc3QgIT0gbnVsbCA/IGxhc3QucG9zaXRpb24gOiB1bmRlZmluZWQpIHx8IDAsIGJrLnBvc2l0aW9uKTtcbiAgICAgIGxldCB3ID0gd29yZFdpZHRoc1t3b3JkXSAhPSBudWxsID8gd29yZFdpZHRoc1t3b3JkXSA6IHdvcmRXaWR0aHNbd29yZF0gPSB0aGlzLndvcmRXaWR0aCh3b3JkKTtcblxuICAgICAgLy8gaWYgdGhlIHdvcmQgaXMgbG9uZ2VyIHRoYW4gdGhlIHdob2xlIGxpbmUsIGNob3AgaXQgdXBcbiAgICAgIC8vIFRPRE86IGJyZWFrIGJ5IGdyYXBoZW1lIGNsdXN0ZXJzLCBub3QgSlMgc3RyaW5nIGNoYXJhY3RlcnNcbiAgICAgIGlmICh3ID4gdGhpcy5saW5lV2lkdGggKyB0aGlzLmNvbnRpbnVlZFgpIHtcbiAgICAgICAgLy8gbWFrZSBzb21lIGZha2UgYnJlYWsgb2JqZWN0c1xuICAgICAgICBsZXQgbGJrID0gbGFzdDtcbiAgICAgICAgY29uc3QgZmJrID0ge307XG4gICAgICAgIHdoaWxlICh3b3JkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGZpdCBhcyBtdWNoIG9mIHRoZSB3b3JkIGFzIHBvc3NpYmxlIGludG8gdGhlIHNwYWNlIHdlIGhhdmVcbiAgICAgICAgICB2YXIgbCwgbWlnaHRHcm93O1xuICAgICAgICAgIGlmICh3ID4gdGhpcy5zcGFjZUxlZnQpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IG91ciBjaGVjayBhdCB0aGUgZW5kIG9mIG91ciBhdmFpbGFibGUgc3BhY2UgLSB0aGlzIG1ldGhvZCBpcyBmYXN0ZXIgdGhhbiBhIGxvb3Agb2YgZWFjaCBjaGFyYWN0ZXIgYW5kIGl0IHJlc29sdmVzXG4gICAgICAgICAgICAvLyBhbiBpc3N1ZSB3aXRoIGxvbmcgbG9vcHMgd2hlbiBwcm9jZXNzaW5nIG1hc3NpdmUgd29yZHMsIHN1Y2ggYXMgYSBodWdlIG51bWJlciBvZiBzcGFjZXNcbiAgICAgICAgICAgIGwgPSBNYXRoLmNlaWwodGhpcy5zcGFjZUxlZnQgLyAodyAvIHdvcmQubGVuZ3RoKSk7XG4gICAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZC5zbGljZSgwLCBsKSk7XG4gICAgICAgICAgICBtaWdodEdyb3cgPSB3IDw9IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPCB3b3JkLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IHdvcmQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbXVzdFNocmluayA9IHcgPiB0aGlzLnNwYWNlTGVmdCAmJiBsID4gMDtcbiAgICAgICAgICAvLyBzaHJpbmsgb3IgZ3JvdyB3b3JkIGFzIG5lY2Vzc2FyeSBhZnRlciBvdXIgbmVhci1ndWVzcyBhYm92ZVxuICAgICAgICAgIHdoaWxlIChtdXN0U2hyaW5rIHx8IG1pZ2h0R3Jvdykge1xuICAgICAgICAgICAgaWYgKG11c3RTaHJpbmspIHtcbiAgICAgICAgICAgICAgdyA9IHRoaXMud29yZFdpZHRoKHdvcmQuc2xpY2UoMCwgLS1sKSk7XG4gICAgICAgICAgICAgIG11c3RTaHJpbmsgPSB3ID4gdGhpcy5zcGFjZUxlZnQgJiYgbCA+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZC5zbGljZSgwLCArK2wpKTtcbiAgICAgICAgICAgICAgbXVzdFNocmluayA9IHcgPiB0aGlzLnNwYWNlTGVmdCAmJiBsID4gMDtcbiAgICAgICAgICAgICAgbWlnaHRHcm93ID0gdyA8PSB0aGlzLnNwYWNlTGVmdCAmJiBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBlZGdlIGNhc2Ugd2hlcmUgYSBzaW5nbGUgY2hhcmFjdGVyIGNhbm5vdCBmaXQgaW50byBhIGxpbmUuXG4gICAgICAgICAgaWYgKGwgPT09IDAgJiYgdGhpcy5zcGFjZUxlZnQgPT09IHRoaXMubGluZVdpZHRoKSB7XG4gICAgICAgICAgICBsID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZW5kIGEgcmVxdWlyZWQgYnJlYWsgdW5sZXNzIHRoaXMgaXMgdGhlIGxhc3QgcGllY2UgYW5kIGEgbGluZWJyZWFrIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICBmYmsucmVxdWlyZWQgPSBiay5yZXF1aXJlZCB8fCBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgc2hvdWxkQ29udGludWUgPSBmbih3b3JkLnNsaWNlKDAsIGwpLCB3LCBmYmssIGxiayk7XG4gICAgICAgICAgbGJrID0ge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIGdldCB0aGUgcmVtYWluaW5nIHBpZWNlIG9mIHRoZSB3b3JkXG4gICAgICAgICAgd29yZCA9IHdvcmQuc2xpY2UobCk7XG4gICAgICAgICAgdyA9IHRoaXMud29yZFdpZHRoKHdvcmQpO1xuICAgICAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgZW1pdCB0aGUgYnJlYWsgYXMgaXQgd2FzIGdpdmVuIHRvIHVzXG4gICAgICAgIHNob3VsZENvbnRpbnVlID0gZm4od29yZCwgdywgYmssIGxhc3QpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZENvbnRpbnVlID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBiaztcbiAgICB9XG4gIH1cbiAgd3JhcCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgLy8gb3ZlcnJpZGUgb3B0aW9ucyBmcm9tIHByZXZpb3VzIGNvbnRpbnVlZCBmcmFnbWVudHNcbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5pbmRlbnQgPSBvcHRpb25zLmluZGVudDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nICE9IG51bGwpIHtcbiAgICAgIHRoaXMud29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbGxpcHNpcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzID0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgd2UncmUgYWN0dWFsbHkgb24gdGhlIHBhZ2VcbiAgICAvLyBhbmQgdGhhdCB0aGUgZmlyc3QgbGluZSBvZiBpcyBuZXZlciBieVxuICAgIC8vIGl0c2VsZiBhdCB0aGUgYm90dG9tIG9mIGEgcGFnZSAob3JwaGFucylcbiAgICBjb25zdCBuZXh0WSA9IHRoaXMuZG9jdW1lbnQueSArIHRoaXMuZG9jdW1lbnQuY3VycmVudExpbmVIZWlnaHQodHJ1ZSk7XG4gICAgaWYgKHRoaXMuZG9jdW1lbnQueSA+IHRoaXMubWF4WSB8fCBuZXh0WSA+IHRoaXMubWF4WSkge1xuICAgICAgdGhpcy5uZXh0U2VjdGlvbigpO1xuICAgIH1cbiAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgbGV0IHRleHRXaWR0aCA9IDA7XG4gICAgbGV0IHdjID0gMDtcbiAgICBsZXQgbGMgPSAwO1xuICAgIGxldCB7XG4gICAgICB5XG4gICAgfSA9IHRoaXMuZG9jdW1lbnQ7IC8vIHVzZWQgdG8gcmVzZXQgWSBwb3MgaWYgb3B0aW9ucy5jb250aW51ZWQgKGJlbG93KVxuICAgIGNvbnN0IGVtaXRMaW5lID0gKCkgPT4ge1xuICAgICAgb3B0aW9ucy50ZXh0V2lkdGggPSB0ZXh0V2lkdGggKyB0aGlzLndvcmRTcGFjaW5nICogKHdjIC0gMSk7XG4gICAgICBvcHRpb25zLndvcmRDb3VudCA9IHdjO1xuICAgICAgb3B0aW9ucy5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICh7XG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRvY3VtZW50KTtcbiAgICAgIHRoaXMuZW1pdCgnbGluZScsIGJ1ZmZlciwgb3B0aW9ucywgdGhpcyk7XG4gICAgICByZXR1cm4gbGMrKztcbiAgICB9O1xuICAgIHRoaXMuZW1pdCgnc2VjdGlvblN0YXJ0Jywgb3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5lYWNoV29yZCh0ZXh0LCAod29yZCwgdywgYmssIGxhc3QpID0+IHtcbiAgICAgIGlmIChsYXN0ID09IG51bGwgfHwgbGFzdC5yZXF1aXJlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2ZpcnN0TGluZScsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLnNwYWNlTGVmdCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FuRml0KHdvcmQsIHcpKSB7XG4gICAgICAgIGJ1ZmZlciArPSB3b3JkO1xuICAgICAgICB0ZXh0V2lkdGggKz0gdztcbiAgICAgICAgd2MrKztcbiAgICAgIH1cbiAgICAgIGlmIChiay5yZXF1aXJlZCB8fCAhdGhpcy5jYW5GaXQod29yZCwgdykpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgbWF4IGhlaWdodCBhbmQgYW4gZWxsaXBzaXMsIGFuZCBpcyBhYm91dCB0byBwYXNzIHRoZVxuICAgICAgICAvLyBtYXggaGVpZ2h0IGFuZCBtYXggY29sdW1ucyBhZnRlciB0aGUgbmV4dCBsaW5lLCBhcHBlbmQgdGhlIGVsbGlwc2lzXG4gICAgICAgIGNvbnN0IGxoID0gdGhpcy5kb2N1bWVudC5jdXJyZW50TGluZUhlaWdodCh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IG51bGwgJiYgdGhpcy5lbGxpcHNpcyAmJiB0aGlzLmRvY3VtZW50LnkgKyBsaCAqIDIgPiB0aGlzLm1heFkgJiYgdGhpcy5jb2x1bW4gPj0gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxsaXBzaXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxsaXBzaXMgPSAn4oCmJztcbiAgICAgICAgICB9IC8vIG1hcCBkZWZhdWx0IGVsbGlwc2lzIGNoYXJhY3RlclxuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndvcmRXaWR0aChidWZmZXIgKyB0aGlzLmVsbGlwc2lzKTtcblxuICAgICAgICAgIC8vIHJlbW92ZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlciB1bnRpbCB0aGUgZWxsaXBzaXMgZml0c1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3AgbmVlZCB0byBzdG9wIHdoaWxlLWxvb3AgaWYgYnVmZmVyIGlzIGVtcHR5IHN0cmluZ1xuICAgICAgICAgIHdoaWxlIChidWZmZXIgJiYgdGV4dFdpZHRoID4gdGhpcy5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCAtMSkucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndvcmRXaWR0aChidWZmZXIgKyB0aGlzLmVsbGlwc2lzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbmVlZCB0byBhZGQgZWxsaXBzaXMgb25seSBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgZm9yIGl0XG4gICAgICAgICAgaWYgKHRleHRXaWR0aCA8PSB0aGlzLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyICsgdGhpcy5lbGxpcHNpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy53b3JkV2lkdGgoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmsucmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAodyA+IHRoaXMuc3BhY2VMZWZ0KSB7XG4gICAgICAgICAgICBlbWl0TGluZSgpO1xuICAgICAgICAgICAgYnVmZmVyID0gd29yZDtcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IHc7XG4gICAgICAgICAgICB3YyA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgnbGFzdExpbmUnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZpb3VzIGVudHJ5IGlzIGEgc29mdCBoeXBoZW4gLSBhZGQgdmlzaWJsZSBoeXBoZW4uXG4gICAgICAgIGlmIChidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdID09IFNPRlRfSFlQSEVOKSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIC0xKSArIEhZUEhFTjtcbiAgICAgICAgICB0aGlzLnNwYWNlTGVmdCAtPSB0aGlzLndvcmRXaWR0aChIWVBIRU4pO1xuICAgICAgICB9XG4gICAgICAgIGVtaXRMaW5lKCk7XG5cbiAgICAgICAgLy8gaWYgd2UndmUgcmVhY2hlZCB0aGUgZWRnZSBvZiB0aGUgcGFnZSxcbiAgICAgICAgLy8gY29udGludWUgb24gYSBuZXcgcGFnZSBvciBjb2x1bW5cbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnQueSArIGxoID4gdGhpcy5tYXhZKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQ29udGludWUgPSB0aGlzLm5leHRTZWN0aW9uKCk7XG5cbiAgICAgICAgICAvLyBzdG9wIGlmIHdlIHJlYWNoZWQgdGhlIG1heGltdW0gaGVpZ2h0XG4gICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgd2MgPSAwO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgdGhlIHNwYWNlIGxlZnQgYW5kIGJ1ZmZlclxuICAgICAgICBpZiAoYmsucmVxdWlyZWQpIHtcbiAgICAgICAgICB0aGlzLnNwYWNlTGVmdCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHRleHRXaWR0aCA9IDA7XG4gICAgICAgICAgcmV0dXJuIHdjID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXNldCB0aGUgc3BhY2UgbGVmdCBhbmQgYnVmZmVyXG4gICAgICAgICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aCAtIHc7XG4gICAgICAgICAgYnVmZmVyID0gd29yZDtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB3O1xuICAgICAgICAgIHJldHVybiB3YyA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYWNlTGVmdCAtPSB3O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh3YyA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnbGFzdExpbmUnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIGVtaXRMaW5lKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnc2VjdGlvbkVuZCcsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gaWYgdGhlIHdyYXAgaXMgc2V0IHRvIGJlIGNvbnRpbnVlZCwgc2F2ZSB0aGUgWCBwb3NpdGlvblxuICAgIC8vIHRvIHN0YXJ0IHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBuZXh0IHNlZ21lbnQgYXQsIGFuZCByZXNldFxuICAgIC8vIHRoZSB5IHBvc2l0aW9uXG4gICAgaWYgKG9wdGlvbnMuY29udGludWVkID09PSB0cnVlKSB7XG4gICAgICBpZiAobGMgPiAxKSB7XG4gICAgICAgIHRoaXMuY29udGludWVkWCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRpbnVlZFggKz0gb3B0aW9ucy50ZXh0V2lkdGggfHwgMDtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LnkgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC54ID0gdGhpcy5zdGFydFg7XG4gICAgfVxuICB9XG4gIG5leHRTZWN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25FbmQnLCBvcHRpb25zLCB0aGlzKTtcbiAgICBpZiAoKyt0aGlzLmNvbHVtbiA+IHRoaXMuY29sdW1ucykge1xuICAgICAgLy8gaWYgYSBtYXggaGVpZ2h0IHdhcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlJ3JlIGRvbmUuXG4gICAgICAvLyBvdGhlcndpc2UsIHRoZSBkZWZhdWx0IGlzIHRvIG1ha2UgYSBuZXcgcGFnZSBhdCB0aGUgYm90dG9tLlxuICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5kb2N1bWVudC5jb250aW51ZU9uTmV3UGFnZSgpO1xuICAgICAgdGhpcy5jb2x1bW4gPSAxO1xuICAgICAgdGhpcy5zdGFydFkgPSB0aGlzLmRvY3VtZW50LnBhZ2UubWFyZ2lucy50b3A7XG4gICAgICB0aGlzLm1heFkgPSB0aGlzLmRvY3VtZW50LnBhZ2UubWF4WSgpO1xuICAgICAgdGhpcy5kb2N1bWVudC54ID0gdGhpcy5zdGFydFg7XG4gICAgICBpZiAodGhpcy5kb2N1bWVudC5fZmlsbENvbG9yKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuZmlsbENvbG9yKC4uLnRoaXMuZG9jdW1lbnQuX2ZpbGxDb2xvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3BhZ2VCcmVhaycsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvY3VtZW50LnggKz0gdGhpcy5saW5lV2lkdGggKyB0aGlzLmNvbHVtbkdhcDtcbiAgICAgIHRoaXMuZG9jdW1lbnQueSA9IHRoaXMuc3RhcnRZO1xuICAgICAgdGhpcy5lbWl0KCdjb2x1bW5CcmVhaycsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ3NlY3Rpb25TdGFydCcsIG9wdGlvbnMsIHRoaXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmNvbnN0IHtcbiAgbnVtYmVyOiBudW1iZXIkMlxufSA9IFBERk9iamVjdDtcbnZhciBUZXh0TWl4aW4gPSB7XG4gIGluaXRUZXh0KCkge1xuICAgIHRoaXMuX2xpbmUgPSB0aGlzLl9saW5lLmJpbmQodGhpcyk7XG4gICAgLy8gQ3VycmVudCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICByZXR1cm4gdGhpcy5fbGluZUdhcCA9IDA7XG4gIH0sXG4gIGxpbmVHYXAoX2xpbmVHYXApIHtcbiAgICB0aGlzLl9saW5lR2FwID0gX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1vdmVEb3duKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzID09IG51bGwpIHtcbiAgICAgIGxpbmVzID0gMTtcbiAgICB9XG4gICAgdGhpcy55ICs9IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKiBsaW5lcyArIHRoaXMuX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1vdmVVcChsaW5lcykge1xuICAgIGlmIChsaW5lcyA9PSBudWxsKSB7XG4gICAgICBsaW5lcyA9IDE7XG4gICAgfVxuICAgIHRoaXMueSAtPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICogbGluZXMgKyB0aGlzLl9saW5lR2FwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfdGV4dCh0ZXh0LCB4LCB5LCBvcHRpb25zLCBsaW5lQ2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMoeCwgeSwgb3B0aW9ucyk7XG5cbiAgICAvLyBDb252ZXJ0IHRleHQgdG8gYSBzdHJpbmdcbiAgICB0ZXh0ID0gdGV4dCA9PSBudWxsID8gJycgOiBgJHt0ZXh0fWA7XG5cbiAgICAvLyBpZiB0aGUgd29yZFNwYWNpbmcgb3B0aW9uIGlzIHNwZWNpZmllZCwgcmVtb3ZlIG11bHRpcGxlIGNvbnNlY3V0aXZlIHNwYWNlc1xuICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZFN0cnVjdHVyZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICBvcHRpb25zLnN0cnVjdFBhcmVudC5hZGQodGhpcy5zdHJ1Y3Qob3B0aW9ucy5zdHJ1Y3RUeXBlIHx8ICdQJywgW3RoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQob3B0aW9ucy5zdHJ1Y3RUeXBlIHx8ICdQJyldKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHdvcmQgd3JhcHBpbmdcbiAgICBpZiAob3B0aW9ucy53aWR0aCkge1xuICAgICAgbGV0IHdyYXBwZXIgPSB0aGlzLl93cmFwcGVyO1xuICAgICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICAgIHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHdyYXBwZXIub24oJ2xpbmUnLCBsaW5lQ2FsbGJhY2spO1xuICAgICAgICB3cmFwcGVyLm9uKCdmaXJzdExpbmUnLCBhZGRTdHJ1Y3R1cmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fd3JhcHBlciA9IG9wdGlvbnMuY29udGludWVkID8gd3JhcHBlciA6IG51bGw7XG4gICAgICB0aGlzLl90ZXh0T3B0aW9ucyA9IG9wdGlvbnMuY29udGludWVkID8gb3B0aW9ucyA6IG51bGw7XG4gICAgICB3cmFwcGVyLndyYXAodGV4dCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHJlbmRlciBwYXJhZ3JhcGhzIGFzIHNpbmdsZSBsaW5lc1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICAgIGFkZFN0cnVjdHVyZSgpO1xuICAgICAgICBsaW5lQ2FsbGJhY2sobGluZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB0ZXh0KHRleHQsIHgsIHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dCh0ZXh0LCB4LCB5LCBvcHRpb25zLCB0aGlzLl9saW5lKTtcbiAgfSxcbiAgd2lkdGhPZlN0cmluZyhzdHJpbmcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIHRoaXMuX2ZvbnQud2lkdGhPZlN0cmluZyhzdHJpbmcsIHRoaXMuX2ZvbnRTaXplLCBvcHRpb25zLmZlYXR1cmVzKSArIChvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMCkgKiAoc3RyaW5nLmxlbmd0aCAtIDEpO1xuICB9LFxuICBoZWlnaHRPZlN0cmluZyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSBJbmZpbml0eTsgLy8gZG9uJ3QgYnJlYWsgcGFnZXNcblxuICAgIGNvbnN0IGxpbmVHYXAgPSBvcHRpb25zLmxpbmVHYXAgfHwgdGhpcy5fbGluZUdhcCB8fCAwO1xuICAgIHRoaXMuX3RleHQodGV4dCwgdGhpcy54LCB0aGlzLnksIG9wdGlvbnMsICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnkgKz0gdGhpcy5jdXJyZW50TGluZUhlaWdodCh0cnVlKSArIGxpbmVHYXA7XG4gICAgfSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy55IC0geTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfSxcbiAgbGlzdChsaXN0LCB4LCB5LCBvcHRpb25zLCB3cmFwcGVyKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMuX2luaXRPcHRpb25zKHgsIHksIG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpc3RUeXBlID0gb3B0aW9ucy5saXN0VHlwZSB8fCAnYnVsbGV0JztcbiAgICBjb25zdCB1bml0ID0gTWF0aC5yb3VuZCh0aGlzLl9mb250LmFzY2VuZGVyIC8gMTAwMCAqIHRoaXMuX2ZvbnRTaXplKTtcbiAgICBjb25zdCBtaWRMaW5lID0gdW5pdCAvIDI7XG4gICAgY29uc3QgciA9IG9wdGlvbnMuYnVsbGV0UmFkaXVzIHx8IHVuaXQgLyAzO1xuICAgIGNvbnN0IGluZGVudCA9IG9wdGlvbnMudGV4dEluZGVudCB8fCAobGlzdFR5cGUgPT09ICdidWxsZXQnID8gciAqIDUgOiB1bml0ICogMik7XG4gICAgY29uc3QgaXRlbUluZGVudCA9IG9wdGlvbnMuYnVsbGV0SW5kZW50IHx8IChsaXN0VHlwZSA9PT0gJ2J1bGxldCcgPyByICogOCA6IHVuaXQgKiAyKTtcbiAgICBsZXQgbGV2ZWwgPSAxO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgbGV2ZWxzID0gW107XG4gICAgY29uc3QgbnVtYmVycyA9IFtdO1xuICAgIHZhciBmbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIGxldCBuID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICAgIGZsYXR0ZW4oaXRlbSk7XG4gICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgIGxldmVscy5wdXNoKGxldmVsKTtcbiAgICAgICAgICBpZiAobGlzdFR5cGUgIT09ICdidWxsZXQnKSB7XG4gICAgICAgICAgICBudW1iZXJzLnB1c2gobisrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZsYXR0ZW4obGlzdCk7XG4gICAgY29uc3QgbGFiZWwgPSBmdW5jdGlvbiAobikge1xuICAgICAgc3dpdGNoIChsaXN0VHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXJlZCc6XG4gICAgICAgICAgcmV0dXJuIGAke259LmA7XG4gICAgICAgIGNhc2UgJ2xldHRlcmVkJzpcbiAgICAgICAgICB2YXIgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgobiAtIDEpICUgMjYgKyA2NSk7XG4gICAgICAgICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigobiAtIDEpIC8gMjYgKyAxKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IEFycmF5KHRpbWVzICsgMSkuam9pbihsZXR0ZXIpO1xuICAgICAgICAgIHJldHVybiBgJHt0ZXh0fS5gO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZHJhd0xpc3RJdGVtID0gZnVuY3Rpb24gKGxpc3RJdGVtLCBpKSB7XG4gICAgICB3cmFwcGVyID0gbmV3IExpbmVXcmFwcGVyKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgd3JhcHBlci5vbignbGluZScsIHRoaXMuX2xpbmUpO1xuICAgICAgbGV2ZWwgPSAxO1xuICAgICAgd3JhcHBlci5vbmNlKCdmaXJzdExpbmUnLCAoKSA9PiB7XG4gICAgICAgIGxldCBpdGVtLCBpdGVtVHlwZSwgbGFiZWxUeXBlLCBib2R5VHlwZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RydWN0UGFyZW50KSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RydWN0VHlwZXMpIHtcbiAgICAgICAgICAgIFtpdGVtVHlwZSwgbGFiZWxUeXBlLCBib2R5VHlwZV0gPSBvcHRpb25zLnN0cnVjdFR5cGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBbaXRlbVR5cGUsIGxhYmVsVHlwZSwgYm9keVR5cGVdID0gWydMSScsICdMYmwnLCAnTEJvZHknXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1UeXBlKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuc3RydWN0KGl0ZW1UeXBlKTtcbiAgICAgICAgICBvcHRpb25zLnN0cnVjdFBhcmVudC5hZGQoaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJ1Y3RQYXJlbnQpIHtcbiAgICAgICAgICBpdGVtID0gb3B0aW9ucy5zdHJ1Y3RQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGw7XG4gICAgICAgIGlmICgobCA9IGxldmVsc1tpKytdKSAhPT0gbGV2ZWwpIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gaXRlbUluZGVudCAqIChsIC0gbGV2ZWwpO1xuICAgICAgICAgIHRoaXMueCArPSBkaWZmO1xuICAgICAgICAgIHdyYXBwZXIubGluZVdpZHRoIC09IGRpZmY7XG4gICAgICAgICAgbGV2ZWwgPSBsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIChsYWJlbFR5cGUgfHwgYm9keVR5cGUpKSB7XG4gICAgICAgICAgaXRlbS5hZGQodGhpcy5zdHJ1Y3QobGFiZWxUeXBlIHx8IGJvZHlUeXBlLCBbdGhpcy5tYXJrU3RydWN0dXJlQ29udGVudChsYWJlbFR5cGUgfHwgYm9keVR5cGUpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobGlzdFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdidWxsZXQnOlxuICAgICAgICAgICAgdGhpcy5jaXJjbGUodGhpcy54IC0gaW5kZW50ICsgciwgdGhpcy55ICsgbWlkTGluZSwgcik7XG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ251bWJlcmVkJzpcbiAgICAgICAgICBjYXNlICdsZXR0ZXJlZCc6XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGxhYmVsKG51bWJlcnNbaSAtIDFdKTtcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50KHRleHQsIHRoaXMueCAtIGluZGVudCwgdGhpcy55LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIGxhYmVsVHlwZSAmJiBib2R5VHlwZSkge1xuICAgICAgICAgIGl0ZW0uYWRkKHRoaXMuc3RydWN0KGJvZHlUeXBlLCBbdGhpcy5tYXJrU3RydWN0dXJlQ29udGVudChib2R5VHlwZSldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbSAhPT0gb3B0aW9ucy5zdHJ1Y3RQYXJlbnQpIHtcbiAgICAgICAgICBpdGVtLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdyYXBwZXIub24oJ3NlY3Rpb25TdGFydCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gaW5kZW50ICsgaXRlbUluZGVudCAqIChsZXZlbCAtIDEpO1xuICAgICAgICB0aGlzLnggKz0gcG9zO1xuICAgICAgICByZXR1cm4gd3JhcHBlci5saW5lV2lkdGggLT0gcG9zO1xuICAgICAgfSk7XG4gICAgICB3cmFwcGVyLm9uKCdzZWN0aW9uRW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBpbmRlbnQgKyBpdGVtSW5kZW50ICogKGxldmVsIC0gMSk7XG4gICAgICAgIHRoaXMueCAtPSBwb3M7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmxpbmVXaWR0aCArPSBwb3M7XG4gICAgICB9KTtcbiAgICAgIHdyYXBwZXIud3JhcChsaXN0SXRlbSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkcmF3TGlzdEl0ZW0uY2FsbCh0aGlzLCBpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfaW5pdE9wdGlvbnMoKSB7XG4gICAgbGV0IHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB4O1xuICAgICAgeCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2xvbmUgb3B0aW9ucyBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIC8vIGV4dGVuZCBvcHRpb25zIHdpdGggcHJldmlvdXMgdmFsdWVzIGZvciBjb250aW51ZWQgdGV4dFxuICAgIGlmICh0aGlzLl90ZXh0T3B0aW9ucykge1xuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX3RleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX3RleHRPcHRpb25zW2tleV07XG4gICAgICAgIGlmIChrZXkgIT09ICdjb250aW51ZWQnKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgfVxuICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuXG4gICAgLy8gd3JhcCB0byBtYXJnaW5zIGlmIG5vIHggb3IgeSBwb3NpdGlvbiBwYXNzZWRcbiAgICBpZiAocmVzdWx0LmxpbmVCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChyZXN1bHQud2lkdGggPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQud2lkdGggPSB0aGlzLnBhZ2Uud2lkdGggLSB0aGlzLnggLSB0aGlzLnBhZ2UubWFyZ2lucy5yaWdodDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC53aWR0aCA9IE1hdGgubWF4KHJlc3VsdC53aWR0aCwgMCk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0LmNvbHVtbnMpIHtcbiAgICAgIHJlc3VsdC5jb2x1bW5zID0gMDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5jb2x1bW5HYXAgPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmNvbHVtbkdhcCA9IDE4O1xuICAgIH0gLy8gMS80IGluY2hcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9saW5lKHRleHQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IHdyYXBwZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudCh0ZXh0LCB0aGlzLngsIHRoaXMueSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGluZUdhcCA9IG9wdGlvbnMubGluZUdhcCB8fCB0aGlzLl9saW5lR2FwIHx8IDA7XG4gICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICs9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMueSArPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICsgbGluZUdhcDtcbiAgICB9XG4gIH0sXG4gIF9mcmFnbWVudCh0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XG4gICAgbGV0IGR5LCBlbmNvZGVkLCBpLCBwb3NpdGlvbnMsIHRleHRXaWR0aCwgd29yZHM7XG4gICAgdGV4dCA9IGAke3RleHR9YC5yZXBsYWNlKC9cXG4vZywgJycpO1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBvcHRpb25zXG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduIHx8ICdsZWZ0JztcbiAgICBsZXQgd29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nIHx8IDA7XG4gICAgY29uc3QgY2hhcmFjdGVyU3BhY2luZyA9IG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyB8fCAwO1xuXG4gICAgLy8gdGV4dCBhbGlnbm1lbnRzXG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0LnJlcGxhY2UoL1xccyskLywgJycpLCBvcHRpb25zKTtcbiAgICAgICAgICB4ICs9IG9wdGlvbnMubGluZVdpZHRoIC0gdGV4dFdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIHggKz0gb3B0aW9ucy5saW5lV2lkdGggLyAyIC0gb3B0aW9ucy50ZXh0V2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdqdXN0aWZ5JzpcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdvcmQgc3BhY2luZyB2YWx1ZVxuICAgICAgICAgIHdvcmRzID0gdGV4dC50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcodGV4dC5yZXBsYWNlKC9cXHMrL2csICcnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIHNwYWNlV2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcoJyAnKSArIGNoYXJhY3RlclNwYWNpbmc7XG4gICAgICAgICAgd29yZFNwYWNpbmcgPSBNYXRoLm1heCgwLCAob3B0aW9ucy5saW5lV2lkdGggLSB0ZXh0V2lkdGgpIC8gTWF0aC5tYXgoMSwgd29yZHMubGVuZ3RoIC0gMSkgLSBzcGFjZVdpZHRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0ZXh0IGJhc2VsaW5lIGFsaWdubWVudHMgYmFzZWQgb24gaHR0cDovL3dpa2kuYXBhY2hlLm9yZy94bWxncmFwaGljcy1mb3AvTGluZUxheW91dC9BbGlnbm1lbnRIYW5kbGluZ1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlbGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGR5ID0gLW9wdGlvbnMuYmFzZWxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5iYXNlbGluZSkge1xuICAgICAgICBjYXNlICdzdmctbWlkZGxlJzpcbiAgICAgICAgICBkeSA9IDAuNSAqIHRoaXMuX2ZvbnQueEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgY2FzZSAnc3ZnLWNlbnRyYWwnOlxuICAgICAgICAgIGR5ID0gMC41ICogKHRoaXMuX2ZvbnQuZGVzY2VuZGVyICsgdGhpcy5fZm9udC5hc2NlbmRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAgICAgICBkeSA9IHRoaXMuX2ZvbnQuZGVzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21hdGhlbWF0aWNhbCc6XG4gICAgICAgICAgZHkgPSAwLjUgKiB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICBkeSA9IDAuOCAqIHRoaXMuX2ZvbnQuYXNjZW5kZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGR5ID0gdGhpcy5fZm9udC5hc2NlbmRlcjtcbiAgICAgIH1cbiAgICAgIGR5ID0gZHkgLyAxMDAwICogdGhpcy5fZm9udFNpemU7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgcmVuZGVyZWQgd2lkdGggb2YgdGhlIHN0cmluZyBhZnRlciB3b3JkIGFuZCBjaGFyYWN0ZXIgc3BhY2luZ1xuICAgIGNvbnN0IHJlbmRlcmVkV2lkdGggPSBvcHRpb25zLnRleHRXaWR0aCArIHdvcmRTcGFjaW5nICogKG9wdGlvbnMud29yZENvdW50IC0gMSkgKyBjaGFyYWN0ZXJTcGFjaW5nICogKHRleHQubGVuZ3RoIC0gMSk7XG5cbiAgICAvLyBjcmVhdGUgbGluayBhbm5vdGF0aW9ucyBpZiB0aGUgbGluayBvcHRpb24gaXMgZ2l2ZW5cbiAgICBpZiAob3B0aW9ucy5saW5rICE9IG51bGwpIHtcbiAgICAgIHRoaXMubGluayh4LCB5LCByZW5kZXJlZFdpZHRoLCB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCksIG9wdGlvbnMubGluayk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdvVG8gIT0gbnVsbCkge1xuICAgICAgdGhpcy5nb1RvKHgsIHksIHJlbmRlcmVkV2lkdGgsIHRoaXMuY3VycmVudExpbmVIZWlnaHQoKSwgb3B0aW9ucy5nb1RvKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVzdGluYXRpb24gIT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGROYW1lZERlc3RpbmF0aW9uKG9wdGlvbnMuZGVzdGluYXRpb24sICdYWVonLCB4LCB5LCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdW5kZXJsaW5lXG4gICAgaWYgKG9wdGlvbnMudW5kZXJsaW5lKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIGlmICghb3B0aW9ucy5zdHJva2UpIHtcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciguLi4odGhpcy5fZmlsbENvbG9yIHx8IFtdKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLl9mb250U2l6ZSA8IDEwID8gMC41IDogTWF0aC5mbG9vcih0aGlzLl9mb250U2l6ZSAvIDEwKTtcbiAgICAgIHRoaXMubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgICBsZXQgbGluZVkgPSB5ICsgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpIC0gbGluZVdpZHRoO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgbGluZVkpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHJlbmRlcmVkV2lkdGgsIGxpbmVZKTtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgc3RyaWtldGhyb3VnaCBsaW5lXG4gICAgaWYgKG9wdGlvbnMuc3RyaWtlKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIGlmICghb3B0aW9ucy5zdHJva2UpIHtcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciguLi4odGhpcy5fZmlsbENvbG9yIHx8IFtdKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB0aGlzLl9mb250U2l6ZSA8IDEwID8gMC41IDogTWF0aC5mbG9vcih0aGlzLl9mb250U2l6ZSAvIDEwKTtcbiAgICAgIHRoaXMubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgICBsZXQgbGluZVkgPSB5ICsgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpIC8gMjtcbiAgICAgIHRoaXMubW92ZVRvKHgsIGxpbmVZKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByZW5kZXJlZFdpZHRoLCBsaW5lWSk7XG4gICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgLy8gb2JsaXF1ZSAoYW5nbGUgaW4gZGVncmVlcyBvciBib29sZWFuKVxuICAgIGlmIChvcHRpb25zLm9ibGlxdWUpIHtcbiAgICAgIGxldCBza2V3O1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9ibGlxdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNrZXcgPSAtTWF0aC50YW4ob3B0aW9ucy5vYmxpcXVlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2V3ID0gLTAuMjU7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIHNrZXcsIDEsIC1za2V3ICogZHksIDApO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgLXgsIC15KTtcbiAgICB9XG5cbiAgICAvLyBmbGlwIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgMCwgLTEsIDAsIHRoaXMucGFnZS5oZWlnaHQpO1xuICAgIHkgPSB0aGlzLnBhZ2UuaGVpZ2h0IC0geSAtIGR5O1xuXG4gICAgLy8gYWRkIGN1cnJlbnQgZm9udCB0byBwYWdlIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnBhZ2UuZm9udHNbdGhpcy5fZm9udC5pZF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICB9XG5cbiAgICAvLyBiZWdpbiB0aGUgdGV4dCBvYmplY3RcbiAgICB0aGlzLmFkZENvbnRlbnQoJ0JUJyk7XG5cbiAgICAvLyB0ZXh0IHBvc2l0aW9uXG4gICAgdGhpcy5hZGRDb250ZW50KGAxIDAgMCAxICR7bnVtYmVyJDIoeCl9ICR7bnVtYmVyJDIoeSl9IFRtYCk7XG5cbiAgICAvLyBmb250IGFuZCBmb250IHNpemVcbiAgICB0aGlzLmFkZENvbnRlbnQoYC8ke3RoaXMuX2ZvbnQuaWR9ICR7bnVtYmVyJDIodGhpcy5fZm9udFNpemUpfSBUZmApO1xuXG4gICAgLy8gcmVuZGVyaW5nIG1vZGVcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5maWxsICYmIG9wdGlvbnMuc3Ryb2tlID8gMiA6IG9wdGlvbnMuc3Ryb2tlID8gMSA6IDA7XG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChgJHttb2RlfSBUcmApO1xuICAgIH1cblxuICAgIC8vIENoYXJhY3RlciBzcGFjaW5nXG4gICAgaWYgKGNoYXJhY3RlclNwYWNpbmcpIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMihjaGFyYWN0ZXJTcGFjaW5nKX0gVGNgKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGFjdHVhbCB0ZXh0XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHdvcmQgc3BhY2luZyB2YWx1ZSwgd2UgbmVlZCB0byBlbmNvZGUgZWFjaCB3b3JkIHNlcGFyYXRlbHlcbiAgICAvLyBzaW5jZSB0aGUgbm9ybWFsIFR3IG9wZXJhdG9yIG9ubHkgd29ya3Mgb24gY2hhcmFjdGVyIGNvZGUgMzIsIHdoaWNoIGlzbid0XG4gICAgLy8gdXNlZCBmb3IgZW1iZWRkZWQgZm9udHMuXG4gICAgaWYgKHdvcmRTcGFjaW5nKSB7XG4gICAgICB3b3JkcyA9IHRleHQudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICB3b3JkU3BhY2luZyArPSB0aGlzLndpZHRoT2ZTdHJpbmcoJyAnKSArIGNoYXJhY3RlclNwYWNpbmc7XG4gICAgICB3b3JkU3BhY2luZyAqPSAxMDAwIC8gdGhpcy5fZm9udFNpemU7XG4gICAgICBlbmNvZGVkID0gW107XG4gICAgICBwb3NpdGlvbnMgPSBbXTtcbiAgICAgIGZvciAobGV0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgY29uc3QgW2VuY29kZWRXb3JkLCBwb3NpdGlvbnNXb3JkXSA9IHRoaXMuX2ZvbnQuZW5jb2RlKHdvcmQsIG9wdGlvbnMuZmVhdHVyZXMpO1xuICAgICAgICBlbmNvZGVkID0gZW5jb2RlZC5jb25jYXQoZW5jb2RlZFdvcmQpO1xuICAgICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KHBvc2l0aW9uc1dvcmQpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgd29yZCBzcGFjaW5nIHRvIHRoZSBlbmQgb2YgdGhlIHdvcmRcbiAgICAgICAgLy8gY2xvbmUgb2JqZWN0IGJlY2F1c2Ugb2YgY2FjaGVcbiAgICAgICAgY29uc3Qgc3BhY2UgPSB7fTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHNwYWNlW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgc3BhY2UueEFkdmFuY2UgKz0gd29yZFNwYWNpbmc7XG4gICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0gPSBzcGFjZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgW2VuY29kZWQsIHBvc2l0aW9uc10gPSB0aGlzLl9mb250LmVuY29kZSh0ZXh0LCBvcHRpb25zLmZlYXR1cmVzKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9mb250U2l6ZSAvIDEwMDA7XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgbGV0IGhhZE9mZnNldCA9IGZhbHNlO1xuXG4gICAgLy8gQWRkcyBhIHNlZ21lbnQgb2YgdGV4dCB0byB0aGUgVEogY29tbWFuZCBidWZmZXJcbiAgICBjb25zdCBhZGRTZWdtZW50ID0gY3VyID0+IHtcbiAgICAgIGlmIChsYXN0IDwgY3VyKSB7XG4gICAgICAgIGNvbnN0IGhleCA9IGVuY29kZWQuc2xpY2UobGFzdCwgY3VyKS5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgYWR2YW5jZSA9IHBvc2l0aW9uc1tjdXIgLSAxXS54QWR2YW5jZSAtIHBvc2l0aW9uc1tjdXIgLSAxXS5hZHZhbmNlV2lkdGg7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goYDwke2hleH0+ICR7bnVtYmVyJDIoLWFkdmFuY2UpfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3QgPSBjdXI7XG4gICAgfTtcblxuICAgIC8vIEZsdXNoZXMgdGhlIGN1cnJlbnQgVEogY29tbWFuZHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICBjb25zdCBmbHVzaCA9IGkgPT4ge1xuICAgICAgYWRkU2VnbWVudChpKTtcbiAgICAgIGlmIChjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYWRkQ29udGVudChgWyR7Y29tbWFuZHMuam9pbignICcpfV0gVEpgKTtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGFuIHggb3IgeSBvZmZzZXQsIHdlIGhhdmUgdG8gYnJlYWsgb3V0IG9mIHRoZSBjdXJyZW50IFRKIGNvbW1hbmRcbiAgICAgIC8vIHNvIHdlIGNhbiBtb3ZlIHRoZSB0ZXh0IHBvc2l0aW9uLlxuICAgICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgICAgaWYgKHBvcy54T2Zmc2V0IHx8IHBvcy55T2Zmc2V0KSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlclxuICAgICAgICBmbHVzaChpKTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSB0ZXh0IHBvc2l0aW9uIGFuZCBmbHVzaCBqdXN0IHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICB0aGlzLmFkZENvbnRlbnQoYDEgMCAwIDEgJHtudW1iZXIkMih4ICsgcG9zLnhPZmZzZXQgKiBzY2FsZSl9ICR7bnVtYmVyJDIoeSArIHBvcy55T2Zmc2V0ICogc2NhbGUpfSBUbWApO1xuICAgICAgICBmbHVzaChpICsgMSk7XG4gICAgICAgIGhhZE9mZnNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaGFkIGFuIG9mZnNldCwgcmVzZXQgdGhlIHRleHQgcG9zaXRpb25cbiAgICAgICAgaWYgKGhhZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYWRkQ29udGVudChgMSAwIDAgMSAke251bWJlciQyKHgpfSAke251bWJlciQyKHkpfSBUbWApO1xuICAgICAgICAgIGhhZE9mZnNldCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JvdXAgc2VnbWVudHMgdGhhdCBkb24ndCBoYXZlIGFueSBhZHZhbmNlIGFkanVzdG1lbnRzXG4gICAgICAgIGlmIChwb3MueEFkdmFuY2UgLSBwb3MuYWR2YW5jZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgYWRkU2VnbWVudChpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHggKz0gcG9zLnhBZHZhbmNlICogc2NhbGU7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggYW55IHJlbWFpbmluZyBjb21tYW5kc1xuICAgIGZsdXNoKGkpO1xuXG4gICAgLy8gZW5kIHRoZSB0ZXh0IG9iamVjdFxuICAgIHRoaXMuYWRkQ29udGVudCgnRVQnKTtcblxuICAgIC8vIHJlc3RvcmUgZmxpcHBlZCBjb29yZGluYXRlIHN5c3RlbVxuICAgIHJldHVybiB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuY29uc3QgTUFSS0VSUyA9IFsweGZmYzAsIDB4ZmZjMSwgMHhmZmMyLCAweGZmYzMsIDB4ZmZjNSwgMHhmZmM2LCAweGZmYzcsIDB4ZmZjOCwgMHhmZmM5LCAweGZmY2EsIDB4ZmZjYiwgMHhmZmNjLCAweGZmY2QsIDB4ZmZjZSwgMHhmZmNmXTtcbmNvbnN0IENPTE9SX1NQQUNFX01BUCA9IHtcbiAgMTogJ0RldmljZUdyYXknLFxuICAzOiAnRGV2aWNlUkdCJyxcbiAgNDogJ0RldmljZUNNWUsnXG59O1xuY2xhc3MgSlBFRyB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGxhYmVsKSB7XG4gICAgbGV0IG1hcmtlcjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBpZiAodGhpcy5kYXRhLnJlYWRVSW50MTZCRSgwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICB0aHJvdyAnU09JIG5vdCBmb3VuZCBpbiBKUEVHJztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB0aGUgRVhJRiBvcmllbnRhdGlvblxuICAgIHRoaXMub3JpZW50YXRpb24gPSBleGlmLmZyb21CdWZmZXIodGhpcy5kYXRhKS5PcmllbnRhdGlvbiB8fCAxO1xuICAgIGxldCBwb3MgPSAyO1xuICAgIHdoaWxlIChwb3MgPCB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLmRhdGEucmVhZFVJbnQxNkJFKHBvcyk7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGlmIChNQVJLRVJTLmluY2x1ZGVzKG1hcmtlcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwb3MgKz0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIH1cbiAgICBpZiAoIU1BUktFUlMuaW5jbHVkZXMobWFya2VyKSkge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgSlBFRy4nO1xuICAgIH1cbiAgICBwb3MgKz0gMjtcbiAgICB0aGlzLmJpdHMgPSB0aGlzLmRhdGFbcG9zKytdO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIHBvcyArPSAyO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmRhdGEucmVhZFVJbnQxNkJFKHBvcyk7XG4gICAgcG9zICs9IDI7XG4gICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLmRhdGFbcG9zKytdO1xuICAgIHRoaXMuY29sb3JTcGFjZSA9IENPTE9SX1NQQUNFX01BUFtjaGFubmVsc107XG4gICAgdGhpcy5vYmogPSBudWxsO1xuICB9XG4gIGVtYmVkKGRvY3VtZW50KSB7XG4gICAgaWYgKHRoaXMub2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JqID0gZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgIFN1YnR5cGU6ICdJbWFnZScsXG4gICAgICBCaXRzUGVyQ29tcG9uZW50OiB0aGlzLmJpdHMsXG4gICAgICBXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIEhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBDb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXG4gICAgICBGaWx0ZXI6ICdEQ1REZWNvZGUnXG4gICAgfSk7XG5cbiAgICAvLyBhZGQgZXh0cmEgZGVjb2RlIHBhcmFtcyBmb3IgQ01ZSyBpbWFnZXMuIEJ5IHN3YXBwaW5nIHRoZVxuICAgIC8vIG1pbiBhbmQgbWF4IHZhbHVlcyBmcm9tIHRoZSBkZWZhdWx0LCB3ZSBpbnZlcnQgdGhlIGNvbG9ycy4gU2VlXG4gICAgLy8gc2VjdGlvbiA0LjguNCBvZiB0aGUgc3BlYy5cbiAgICBpZiAodGhpcy5jb2xvclNwYWNlID09PSAnRGV2aWNlQ01ZSycpIHtcbiAgICAgIHRoaXMub2JqLmRhdGFbJ0RlY29kZSddID0gWzEuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMC4wXTtcbiAgICB9XG4gICAgdGhpcy5vYmouZW5kKHRoaXMuZGF0YSk7XG5cbiAgICAvLyBmcmVlIG1lbW9yeVxuICAgIHJldHVybiB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG59XG5cbmNsYXNzIFBOR0ltYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbGFiZWwpIHtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5pbWFnZSA9IG5ldyBQTkcoZGF0YSk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICB0aGlzLmltZ0RhdGEgPSB0aGlzLmltYWdlLmltZ0RhdGE7XG4gICAgdGhpcy5vYmogPSBudWxsO1xuICB9XG4gIGVtYmVkKGRvY3VtZW50KSB7XG4gICAgbGV0IGRhdGFEZWNvZGVkID0gZmFsc2U7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIGlmICh0aGlzLm9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNBbHBoYUNoYW5uZWwgPSB0aGlzLmltYWdlLmhhc0FscGhhQ2hhbm5lbDtcbiAgICBjb25zdCBpc0ludGVybGFjZWQgPSB0aGlzLmltYWdlLmludGVybGFjZU1ldGhvZCA9PT0gMTtcbiAgICB0aGlzLm9iaiA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgIFN1YnR5cGU6ICdJbWFnZScsXG4gICAgICBCaXRzUGVyQ29tcG9uZW50OiBoYXNBbHBoYUNoYW5uZWwgPyA4IDogdGhpcy5pbWFnZS5iaXRzLFxuICAgICAgV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgRmlsdGVyOiAnRmxhdGVEZWNvZGUnXG4gICAgfSk7XG4gICAgaWYgKCFoYXNBbHBoYUNoYW5uZWwpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgUHJlZGljdG9yOiBpc0ludGVybGFjZWQgPyAxIDogMTUsXG4gICAgICAgIENvbG9yczogdGhpcy5pbWFnZS5jb2xvcnMsXG4gICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IHRoaXMuaW1hZ2UuYml0cyxcbiAgICAgICAgQ29sdW1uczogdGhpcy53aWR0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLm9iai5kYXRhWydEZWNvZGVQYXJtcyddID0gcGFyYW1zO1xuICAgICAgcGFyYW1zLmVuZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbWFnZS5wYWxldHRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vYmouZGF0YVsnQ29sb3JTcGFjZSddID0gdGhpcy5pbWFnZS5jb2xvclNwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbWJlZCB0aGUgY29sb3IgcGFsZXR0ZSBpbiB0aGUgUERGIGFzIGFuIG9iamVjdCBzdHJlYW1cbiAgICAgIGNvbnN0IHBhbGV0dGUgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgICAgcGFsZXR0ZS5lbmQoQnVmZmVyLmZyb20odGhpcy5pbWFnZS5wYWxldHRlKSk7XG5cbiAgICAgIC8vIGJ1aWxkIHRoZSBjb2xvciBzcGFjZSBhcnJheSBmb3IgdGhlIGltYWdlXG4gICAgICB0aGlzLm9iai5kYXRhWydDb2xvclNwYWNlJ10gPSBbJ0luZGV4ZWQnLCAnRGV2aWNlUkdCJywgdGhpcy5pbWFnZS5wYWxldHRlLmxlbmd0aCAvIDMgLSAxLCBwYWxldHRlXTtcbiAgICB9XG5cbiAgICAvLyBGb3IgUE5HIGNvbG9yIHR5cGVzIDAsIDIgYW5kIDMsIHRoZSB0cmFuc3BhcmVuY3kgZGF0YSBpcyBzdG9yZWQgaW5cbiAgICAvLyBhIGRlZGljYXRlZCBQTkcgY2h1bmsuXG4gICAgaWYgKHRoaXMuaW1hZ2UudHJhbnNwYXJlbmN5LmdyYXlzY2FsZSAhPSBudWxsKSB7XG4gICAgICAvLyBVc2UgQ29sb3IgS2V5IE1hc2tpbmcgKHNwZWMgc2VjdGlvbiA0LjguNSlcbiAgICAgIC8vIEFuIGFycmF5IHdpdGggTiBlbGVtZW50cywgd2hlcmUgTiBpcyB0d28gdGltZXMgdGhlIG51bWJlciBvZiBjb2xvciBjb21wb25lbnRzLlxuICAgICAgY29uc3QgdmFsID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuZ3JheXNjYWxlO1xuICAgICAgdGhpcy5vYmouZGF0YVsnTWFzayddID0gW3ZhbCwgdmFsXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2UudHJhbnNwYXJlbmN5LnJnYikge1xuICAgICAgLy8gVXNlIENvbG9yIEtleSBNYXNraW5nIChzcGVjIHNlY3Rpb24gNC44LjUpXG4gICAgICAvLyBBbiBhcnJheSB3aXRoIE4gZWxlbWVudHMsIHdoZXJlIE4gaXMgdHdvIHRpbWVzIHRoZSBudW1iZXIgb2YgY29sb3IgY29tcG9uZW50cy5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmdiXG4gICAgICB9ID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3k7XG4gICAgICBjb25zdCBtYXNrID0gW107XG4gICAgICBmb3IgKGxldCB4IG9mIHJnYikge1xuICAgICAgICBtYXNrLnB1c2goeCwgeCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9iai5kYXRhWydNYXNrJ10gPSBtYXNrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuaW5kZXhlZCkge1xuICAgICAgLy8gQ3JlYXRlIGEgdHJhbnNwYXJlbmN5IFNNYXNrIGZvciB0aGUgaW1hZ2UgYmFzZWQgb24gdGhlIGRhdGFcbiAgICAgIC8vIGluIHRoZSBQTFRFIGFuZCB0Uk5TIHNlY3Rpb25zLiBTZWUgYmVsb3cgZm9yIGRldGFpbHMgb24gU01hc2tzLlxuICAgICAgZGF0YURlY29kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMubG9hZEluZGV4ZWRBbHBoYUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGhhc0FscGhhQ2hhbm5lbCkge1xuICAgICAgLy8gRm9yIFBORyBjb2xvciB0eXBlcyA0IGFuZCA2LCB0aGUgdHJhbnNwYXJlbmN5IGRhdGEgaXMgc3RvcmVkIGFzIGEgYWxwaGFcbiAgICAgIC8vIGNoYW5uZWwgbWl4ZWQgaW4gd2l0aCB0aGUgbWFpbiBpbWFnZSBkYXRhLiBTZXBhcmF0ZSB0aGlzIGRhdGEgb3V0IGludG8gYW5cbiAgICAgIC8vIFNNYXNrIG9iamVjdCBhbmQgc3RvcmUgaXQgc2VwYXJhdGVseSBpbiB0aGUgUERGLlxuICAgICAgZGF0YURlY29kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXRBbHBoYUNoYW5uZWwoKTtcbiAgICB9XG4gICAgaWYgKGlzSW50ZXJsYWNlZCAmJiAhZGF0YURlY29kZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY29kZURhdGEoKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICB9XG4gIGZpbmFsaXplKCkge1xuICAgIGlmICh0aGlzLmFscGhhQ2hhbm5lbCkge1xuICAgICAgY29uc3Qgc01hc2sgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgICAgU3VidHlwZTogJ0ltYWdlJyxcbiAgICAgICAgSGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IDgsXG4gICAgICAgIEZpbHRlcjogJ0ZsYXRlRGVjb2RlJyxcbiAgICAgICAgQ29sb3JTcGFjZTogJ0RldmljZUdyYXknLFxuICAgICAgICBEZWNvZGU6IFswLCAxXVxuICAgICAgfSk7XG4gICAgICBzTWFzay5lbmQodGhpcy5hbHBoYUNoYW5uZWwpO1xuICAgICAgdGhpcy5vYmouZGF0YVsnU01hc2snXSA9IHNNYXNrO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGUgYWN0dWFsIGltYWdlIGRhdGFcbiAgICB0aGlzLm9iai5lbmQodGhpcy5pbWdEYXRhKTtcblxuICAgIC8vIGZyZWUgbWVtb3J5XG4gICAgdGhpcy5pbWFnZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuaW1nRGF0YSA9IG51bGw7XG4gIH1cbiAgc3BsaXRBbHBoYUNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2UuZGVjb2RlUGl4ZWxzKHBpeGVscyA9PiB7XG4gICAgICBsZXQgYSwgcDtcbiAgICAgIGNvbnN0IGNvbG9yQ291bnQgPSB0aGlzLmltYWdlLmNvbG9ycztcbiAgICAgIGNvbnN0IHBpeGVsQ291bnQgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgICBjb25zdCBpbWdEYXRhID0gQnVmZmVyLmFsbG9jKHBpeGVsQ291bnQgKiBjb2xvckNvdW50KTtcbiAgICAgIGNvbnN0IGFscGhhQ2hhbm5lbCA9IEJ1ZmZlci5hbGxvYyhwaXhlbENvdW50KTtcbiAgICAgIGxldCBpID0gcCA9IGEgPSAwO1xuICAgICAgY29uc3QgbGVuID0gcGl4ZWxzLmxlbmd0aDtcbiAgICAgIC8vIEZvciAxNmJpdCBpbWFnZXMgY29weSBvbmx5IG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSAoTVNCKSAtIFBORyBkYXRhIGlzIGFsd2F5cyBzdG9yZWQgaW4gbmV0d29yayBieXRlIG9yZGVyIChNU0IgZmlyc3QpXG4gICAgICBjb25zdCBza2lwQnl0ZUNvdW50ID0gdGhpcy5pbWFnZS5iaXRzID09PSAxNiA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgZm9yIChsZXQgY29sb3JJbmRleCA9IDA7IGNvbG9ySW5kZXggPCBjb2xvckNvdW50OyBjb2xvckluZGV4KyspIHtcbiAgICAgICAgICBpbWdEYXRhW3ArK10gPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgICBpICs9IHNraXBCeXRlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGFDaGFubmVsW2ErK10gPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgaSArPSBza2lwQnl0ZUNvdW50O1xuICAgICAgfVxuICAgICAgdGhpcy5pbWdEYXRhID0gemxpYi5kZWZsYXRlU3luYyhpbWdEYXRhKTtcbiAgICAgIHRoaXMuYWxwaGFDaGFubmVsID0gemxpYi5kZWZsYXRlU3luYyhhbHBoYUNoYW5uZWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkSW5kZXhlZEFscGhhQ2hhbm5lbCgpIHtcbiAgICBjb25zdCB0cmFuc3BhcmVuY3kgPSB0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5pbmRleGVkO1xuICAgIHJldHVybiB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgY29uc3QgYWxwaGFDaGFubmVsID0gQnVmZmVyLmFsbG9jKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMCwgZW5kID0gcGl4ZWxzLmxlbmd0aDsgaiA8IGVuZDsgaisrKSB7XG4gICAgICAgIGFscGhhQ2hhbm5lbFtpKytdID0gdHJhbnNwYXJlbmN5W3BpeGVsc1tqXV07XG4gICAgICB9XG4gICAgICB0aGlzLmFscGhhQ2hhbm5lbCA9IHpsaWIuZGVmbGF0ZVN5bmMoYWxwaGFDaGFubmVsKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCk7XG4gICAgfSk7XG4gIH1cbiAgZGVjb2RlRGF0YSgpIHtcbiAgICB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgdGhpcy5pbWdEYXRhID0gemxpYi5kZWZsYXRlU3luYyhwaXhlbHMpO1xuICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qXHJcblBERkltYWdlIC0gZW1iZWRzIGltYWdlcyBpbiBQREYgZG9jdW1lbnRzXHJcbkJ5IERldm9uIEdvdmV0dFxyXG4qL1xuY2xhc3MgUERGSW1hZ2Uge1xuICBzdGF0aWMgb3BlbihzcmMsIGxhYmVsKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpKSB7XG4gICAgICBkYXRhID0gc3JjO1xuICAgIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgaWYgKG1hdGNoID0gL15kYXRhOi4rPztiYXNlNjQsKC4qKSQvLmV4ZWMoc3JjKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20obWF0Y2hbMV0sICdiYXNlNjQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoc3JjKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhWzBdID09PSAweGZmICYmIGRhdGFbMV0gPT09IDB4ZDgpIHtcbiAgICAgIHJldHVybiBuZXcgSlBFRyhkYXRhLCBsYWJlbCk7XG4gICAgfSBlbHNlIGlmIChkYXRhWzBdID09PSAweDg5ICYmIGRhdGEudG9TdHJpbmcoJ2FzY2lpJywgMSwgNCkgPT09ICdQTkcnKSB7XG4gICAgICByZXR1cm4gbmV3IFBOR0ltYWdlKGRhdGEsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGltYWdlIGZvcm1hdC4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIEltYWdlc01peGluID0ge1xuICBpbml0SW1hZ2VzKCkge1xuICAgIHRoaXMuX2ltYWdlUmVnaXN0cnkgPSB7fTtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VDb3VudCA9IDA7XG4gIH0sXG4gIGltYWdlKHNyYywgeCwgeSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBsZXQgYmgsIGJwLCBidywgaW1hZ2UsIGlwLCBsZWZ0LCBsZWZ0MSwgcm90YXRlQW5nbGUsIG9yaWdpblgsIG9yaWdpblk7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHg7XG4gICAgICB4ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgb3JpZW50YXRpb24gYmFzZWQgb24gZG9jdW1lbnQgb3B0aW9ucyBvciBpbWFnZSBvcHRpb25zXG4gICAgY29uc3QgaWdub3JlT3JpZW50YXRpb24gPSBvcHRpb25zLmlnbm9yZU9yaWVudGF0aW9uIHx8IG9wdGlvbnMuaWdub3JlT3JpZW50YXRpb24gIT09IGZhbHNlICYmIHRoaXMub3B0aW9ucy5pZ25vcmVPcmllbnRhdGlvbjtcbiAgICB4ID0gKGxlZnQgPSB4ICE9IG51bGwgPyB4IDogb3B0aW9ucy54KSAhPSBudWxsID8gbGVmdCA6IHRoaXMueDtcbiAgICB5ID0gKGxlZnQxID0geSAhPSBudWxsID8geSA6IG9wdGlvbnMueSkgIT0gbnVsbCA/IGxlZnQxIDogdGhpcy55O1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZVJlZ2lzdHJ5W3NyY107XG4gICAgfVxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGlmIChzcmMud2lkdGggJiYgc3JjLmhlaWdodCkge1xuICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gdGhpcy5vcGVuSW1hZ2Uoc3JjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbWFnZS5vYmopIHtcbiAgICAgIGltYWdlLmVtYmVkKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYWdlLnhvYmplY3RzW2ltYWdlLmxhYmVsXSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhZ2UueG9iamVjdHNbaW1hZ2UubGFiZWxdID0gaW1hZ2Uub2JqO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1hZ2U7XG5cbiAgICAvLyBJZiBFWElGIG9yaWVudGF0aW9uIGNhbGxzIGZvciBpdCwgc3dhcCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgaWYgKCFpZ25vcmVPcmllbnRhdGlvbiAmJiBpbWFnZS5vcmllbnRhdGlvbiA+IDQpIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgbGV0IHcgPSBvcHRpb25zLndpZHRoIHx8IHdpZHRoO1xuICAgIGxldCBoID0gb3B0aW9ucy5oZWlnaHQgfHwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLndpZHRoICYmICFvcHRpb25zLmhlaWdodCkge1xuICAgICAgY29uc3Qgd3AgPSB3IC8gd2lkdGg7XG4gICAgICB3ID0gd2lkdGggKiB3cDtcbiAgICAgIGggPSBoZWlnaHQgKiB3cDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVpZ2h0ICYmICFvcHRpb25zLndpZHRoKSB7XG4gICAgICBjb25zdCBocCA9IGggLyBoZWlnaHQ7XG4gICAgICB3ID0gd2lkdGggKiBocDtcbiAgICAgIGggPSBoZWlnaHQgKiBocDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2NhbGUpIHtcbiAgICAgIHcgPSB3aWR0aCAqIG9wdGlvbnMuc2NhbGU7XG4gICAgICBoID0gaGVpZ2h0ICogb3B0aW9ucy5zY2FsZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICBbYncsIGJoXSA9IG9wdGlvbnMuZml0O1xuICAgICAgYnAgPSBidyAvIGJoO1xuICAgICAgaXAgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmIChpcCA+IGJwKSB7XG4gICAgICAgIHcgPSBidztcbiAgICAgICAgaCA9IGJ3IC8gaXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gYmg7XG4gICAgICAgIHcgPSBiaCAqIGlwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb3Zlcikge1xuICAgICAgW2J3LCBiaF0gPSBvcHRpb25zLmNvdmVyO1xuICAgICAgYnAgPSBidyAvIGJoO1xuICAgICAgaXAgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmIChpcCA+IGJwKSB7XG4gICAgICAgIGggPSBiaDtcbiAgICAgICAgdyA9IGJoICogaXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ID0gYnc7XG4gICAgICAgIGggPSBidyAvIGlwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maXQgfHwgb3B0aW9ucy5jb3Zlcikge1xuICAgICAgaWYgKG9wdGlvbnMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSB4ICsgYncgLyAyIC0gdyAvIDI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IHggKyBidyAtIHc7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy52YWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSB5ICsgYmggLyAyIC0gaCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudmFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB5ID0geSArIGJoIC0gaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpZ25vcmVPcmllbnRhdGlvbikge1xuICAgICAgc3dpdGNoIChpbWFnZS5vcmllbnRhdGlvbikge1xuICAgICAgICAvLyBObyBvcmllbnRhdGlvbiAobmVlZCB0byBmbGlwIGltYWdlLCB0aG91Z2gsIGJlY2F1c2Ugb2YgdGhlIGRlZmF1bHQgdHJhbnNmb3JtIG1hdHJpeCBvbiB0aGUgZG9jdW1lbnQpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoID0gLWg7XG4gICAgICAgICAgeSAtPSBoO1xuICAgICAgICAgIHJvdGF0ZUFuZ2xlID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmxpcCBIb3Jpem9udGFsXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB3ID0gLXc7XG4gICAgICAgICAgaCA9IC1oO1xuICAgICAgICAgIHggLT0gdztcbiAgICAgICAgICB5IC09IGg7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBSb3RhdGUgMTgwIGRlZ3JlZXNcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIGggPSAtaDtcbiAgICAgICAgICB4IC09IHc7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSAxODA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZsaXAgdmVydGljYWxcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIC8vIERvIG5vdGhpbmcsIGltYWdlIHdpbGwgYmUgZmxpcHBlZFxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZsaXAgaG9yaXpvbnRhbGx5IGFuZCByb3RhdGUgMjcwIGRlZ3JlZXMgQ1dcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIFt3LCBoXSA9IFtoLCB3XTtcbiAgICAgICAgICB5IC09IGg7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUm90YXRlIDkwIGRlZ3JlZXMgQ1dcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIFt3LCBoXSA9IFtoLCB3XTtcbiAgICAgICAgICBoID0gLWg7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmxpcCBob3Jpem9udGFsbHkgYW5kIHJvdGF0ZSA5MCBkZWdyZWVzIENXXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICBbdywgaF0gPSBbaCwgd107XG4gICAgICAgICAgaCA9IC1oO1xuICAgICAgICAgIHcgPSAtdztcbiAgICAgICAgICB4IC09IHc7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gUm90YXRlIDI3MCBkZWdyZWVzIENXXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICBbdywgaF0gPSBbaCwgd107XG4gICAgICAgICAgaCA9IC1oO1xuICAgICAgICAgIHggLT0gdztcbiAgICAgICAgICB5IC09IGg7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSAtOTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAtaDtcbiAgICAgIHkgLT0gaDtcbiAgICAgIHJvdGF0ZUFuZ2xlID0gMDtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgbGluayBhbm5vdGF0aW9ucyBpZiB0aGUgbGluayBvcHRpb24gaXMgZ2l2ZW5cbiAgICBpZiAob3B0aW9ucy5saW5rICE9IG51bGwpIHtcbiAgICAgIHRoaXMubGluayh4LCB5LCB3LCBoLCBvcHRpb25zLmxpbmspO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nb1RvICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZ29Ubyh4LCB5LCB3LCBoLCBvcHRpb25zLmdvVG8pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZXN0aW5hdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFkZE5hbWVkRGVzdGluYXRpb24ob3B0aW9ucy5kZXN0aW5hdGlvbiwgJ1hZWicsIHgsIHksIG51bGwpO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgY3VycmVudCB5IHBvc2l0aW9uIHRvIGJlbG93IHRoZSBpbWFnZSBpZiBpdCBpcyBpbiB0aGUgZG9jdW1lbnQgZmxvd1xuICAgIGlmICh0aGlzLnkgPT09IHkpIHtcbiAgICAgIHRoaXMueSArPSBoO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAocm90YXRlQW5nbGUpIHtcbiAgICAgIHRoaXMucm90YXRlKHJvdGF0ZUFuZ2xlLCB7XG4gICAgICAgIG9yaWdpbjogW29yaWdpblgsIG9yaWdpblldXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0odywgMCwgMCwgaCwgeCwgeSk7XG4gICAgdGhpcy5hZGRDb250ZW50KGAvJHtpbWFnZS5sYWJlbH0gRG9gKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb3BlbkltYWdlKHNyYykge1xuICAgIGxldCBpbWFnZTtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltYWdlID0gdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xuICAgIH1cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICBpbWFnZSA9IFBERkltYWdlLm9wZW4oc3JjLCBgSSR7Kyt0aGlzLl9pbWFnZUNvdW50fWApO1xuICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2ltYWdlUmVnaXN0cnlbc3JjXSA9IGltYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbnZhciBBbm5vdGF0aW9uc01peGluID0ge1xuICBhbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5UeXBlID0gJ0Fubm90JztcbiAgICBvcHRpb25zLlJlY3QgPSB0aGlzLl9jb252ZXJ0UmVjdCh4LCB5LCB3LCBoKTtcbiAgICBvcHRpb25zLkJvcmRlciA9IFswLCAwLCAwXTtcbiAgICBpZiAob3B0aW9ucy5TdWJ0eXBlID09PSAnTGluaycgJiYgdHlwZW9mIG9wdGlvbnMuRiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuRiA9IDEgPDwgMjsgLy8gUHJpbnQgQW5ub3RhdGlvbiBGbGFnXG4gICAgfVxuICAgIGlmIChvcHRpb25zLlN1YnR5cGUgIT09ICdMaW5rJykge1xuICAgICAgaWYgKG9wdGlvbnMuQyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuQyA9IHRoaXMuX25vcm1hbGl6ZUNvbG9yKG9wdGlvbnMuY29sb3IgfHwgWzAsIDAsIDBdKTtcbiAgICAgIH1cbiAgICB9IC8vIGNvbnZlcnQgY29sb3JzXG4gICAgZGVsZXRlIG9wdGlvbnMuY29sb3I7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLkRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zLkRlc3QgPSBuZXcgU3RyaW5nKG9wdGlvbnMuRGVzdCk7XG4gICAgfVxuXG4gICAgLy8gQ2FwaXRhbGl6ZSBrZXlzXG4gICAgZm9yIChsZXQga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbCA9IG9wdGlvbnNba2V5XTtcbiAgICAgIG9wdGlvbnNba2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldID0gdmFsO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB0aGlzLnJlZihvcHRpb25zKTtcbiAgICB0aGlzLnBhZ2UuYW5ub3RhdGlvbnMucHVzaChyZWYpO1xuICAgIHJlZi5lbmQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm90ZSh4LCB5LCB3LCBoLCBjb250ZW50cykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnVGV4dCc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcoY29udGVudHMpO1xuICAgIG9wdGlvbnMuTmFtZSA9ICdDb21tZW50JztcbiAgICBpZiAob3B0aW9ucy5jb2xvciA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmNvbG9yID0gWzI0MywgMjIzLCA5Ml07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBnb1RvKHgsIHksIHcsIGgsIG5hbWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0xpbmsnO1xuICAgIG9wdGlvbnMuQSA9IHRoaXMucmVmKHtcbiAgICAgIFM6ICdHb1RvJyxcbiAgICAgIEQ6IG5ldyBTdHJpbmcobmFtZSlcbiAgICB9KTtcbiAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbmsoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5rJztcbiAgICBpZiAodHlwZW9mIHVybCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIExpbmsgdG8gYSBwYWdlIGluIHRoZSBkb2N1bWVudCAodGhlIHBhZ2UgbXVzdCBhbHJlYWR5IGV4aXN0KVxuICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLl9yb290LmRhdGEuUGFnZXMuZGF0YTtcbiAgICAgIGlmICh1cmwgPj0gMCAmJiB1cmwgPCBwYWdlcy5LaWRzLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLkEgPSB0aGlzLnJlZih7XG4gICAgICAgICAgUzogJ0dvVG8nLFxuICAgICAgICAgIEQ6IFtwYWdlcy5LaWRzW3VybF0sICdYWVonLCBudWxsLCBudWxsLCBudWxsXVxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5BLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZG9jdW1lbnQgaGFzIG5vIHBhZ2UgJHt1cmx9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpbmsgdG8gYW4gZXh0ZXJuYWwgdXJsXG4gICAgICBvcHRpb25zLkEgPSB0aGlzLnJlZih7XG4gICAgICAgIFM6ICdVUkknLFxuICAgICAgICBVUkk6IG5ldyBTdHJpbmcodXJsKVxuICAgICAgfSk7XG4gICAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfbWFya3VwKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuX2NvbnZlcnRSZWN0KHgsIHksIHcsIGgpO1xuICAgIG9wdGlvbnMuUXVhZFBvaW50cyA9IFt4MSwgeTIsIHgyLCB5MiwgeDEsIHkxLCB4MiwgeTFdO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGhpZ2hsaWdodCh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdIaWdobGlnaHQnO1xuICAgIGlmIChvcHRpb25zLmNvbG9yID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuY29sb3IgPSBbMjQxLCAyMzgsIDE0OF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHVuZGVybGluZSh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdVbmRlcmxpbmUnO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0cmlrZSh4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdTdHJpa2VPdXQnO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbmVBbm5vdGF0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5lJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIG9wdGlvbnMuTCA9IFt4MSwgdGhpcy5wYWdlLmhlaWdodCAtIHkxLCB4MiwgdGhpcy5wYWdlLmhlaWdodCAtIHkyXTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gIH0sXG4gIHJlY3RBbm5vdGF0aW9uKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ1NxdWFyZSc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZWxsaXBzZUFubm90YXRpb24oeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnQ2lyY2xlJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICB0ZXh0QW5ub3RhdGlvbih4LCB5LCB3LCBoLCB0ZXh0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdGcmVlVGV4dCc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcodGV4dCk7XG4gICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZmlsZUFubm90YXRpb24oeCwgeSwgdywgaCkge1xuICAgIGxldCBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgLy8gY3JlYXRlIGhpZGRlbiBmaWxlXG4gICAgY29uc3QgZmlsZXNwZWMgPSB0aGlzLmZpbGUoZmlsZS5zcmMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaGlkZGVuOiB0cnVlXG4gICAgfSwgZmlsZSkpO1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdGaWxlQXR0YWNobWVudCc7XG4gICAgb3B0aW9ucy5GUyA9IGZpbGVzcGVjO1xuXG4gICAgLy8gYWRkIGRlc2NyaXB0aW9uIGZyb20gZmlsZXNwZWMgdW5sZXNzIGRlc2NyaXB0aW9uIChDb250ZW50cykgaGFzIGFscmVhZHkgYmVlbiBzZXRcbiAgICBpZiAob3B0aW9ucy5Db250ZW50cykge1xuICAgICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcob3B0aW9ucy5Db250ZW50cyk7XG4gICAgfSBlbHNlIGlmIChmaWxlc3BlYy5kYXRhLkRlc2MpIHtcbiAgICAgIG9wdGlvbnMuQ29udGVudHMgPSBmaWxlc3BlYy5kYXRhLkRlc2M7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfY29udmVydFJlY3QoeDEsIHkxLCB3LCBoKSB7XG4gICAgLy8gZmxpcCB5MSBhbmQgeTJcbiAgICBsZXQgeTIgPSB5MTtcbiAgICB5MSArPSBoO1xuXG4gICAgLy8gbWFrZSB4MlxuICAgIGxldCB4MiA9IHgxICsgdztcblxuICAgIC8vIGFwcGx5IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIHBvaW50c1xuICAgIGNvbnN0IFttMCwgbTEsIG0yLCBtMywgbTQsIG01XSA9IHRoaXMuX2N0bTtcbiAgICB4MSA9IG0wICogeDEgKyBtMiAqIHkxICsgbTQ7XG4gICAgeTEgPSBtMSAqIHgxICsgbTMgKiB5MSArIG01O1xuICAgIHgyID0gbTAgKiB4MiArIG0yICogeTIgKyBtNDtcbiAgICB5MiA9IG0xICogeDIgKyBtMyAqIHkyICsgbTU7XG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG4gIH1cbn07XG5cbmNsYXNzIFBERk91dGxpbmUge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcGFyZW50LCB0aXRsZSwgZGVzdCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7XG4gICAgICBleHBhbmRlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMub3V0bGluZURhdGEgPSB7fTtcbiAgICBpZiAoZGVzdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnRGVzdCddID0gW2Rlc3QuZGljdGlvbmFyeSwgJ0ZpdCddO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm91dGxpbmVEYXRhWydQYXJlbnQnXSA9IHBhcmVudDtcbiAgICB9XG4gICAgaWYgKHRpdGxlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm91dGxpbmVEYXRhWydUaXRsZSddID0gbmV3IFN0cmluZyh0aXRsZSk7XG4gICAgfVxuICAgIHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKHRoaXMub3V0bGluZURhdGEpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgfVxuICBhZGRJdGVtKHRpdGxlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGV4cGFuZGVkOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFBERk91dGxpbmUodGhpcy5kb2N1bWVudCwgdGhpcy5kaWN0aW9uYXJ5LCB0aXRsZSwgdGhpcy5kb2N1bWVudC5wYWdlLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGVuZE91dGxpbmUoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBhbmRlZCkge1xuICAgICAgICB0aGlzLm91dGxpbmVEYXRhLkNvdW50ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuY2hpbGRyZW5bMF0sXG4gICAgICAgIGxhc3QgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLm91dGxpbmVEYXRhLkZpcnN0ID0gZmlyc3QuZGljdGlvbmFyeTtcbiAgICAgIHRoaXMub3V0bGluZURhdGEuTGFzdCA9IGxhc3QuZGljdGlvbmFyeTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgY2hpbGQub3V0bGluZURhdGEuUHJldiA9IHRoaXMuY2hpbGRyZW5baSAtIDFdLmRpY3Rpb25hcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjaGlsZC5vdXRsaW5lRGF0YS5OZXh0ID0gdGhpcy5jaGlsZHJlbltpICsgMV0uZGljdGlvbmFyeTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5lbmRPdXRsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbn1cblxudmFyIE91dGxpbmVNaXhpbiA9IHtcbiAgaW5pdE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0bGluZSA9IG5ldyBQREZPdXRsaW5lKHRoaXMsIG51bGwsIG51bGwsIG51bGwpO1xuICB9LFxuICBlbmRPdXRsaW5lKCkge1xuICAgIHRoaXMub3V0bGluZS5lbmRPdXRsaW5lKCk7XG4gICAgaWYgKHRoaXMub3V0bGluZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuT3V0bGluZXMgPSB0aGlzLm91dGxpbmUuZGljdGlvbmFyeTtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuUGFnZU1vZGUgPSAnVXNlT3V0bGluZXMnO1xuICAgIH1cbiAgfVxufTtcblxuLypcclxuUERGU3RydWN0dXJlQ29udGVudCAtIGEgcmVmZXJlbmNlIHRvIGEgbWFya2VkIHN0cnVjdHVyZSBjb250ZW50XHJcbkJ5IEJlbiBTY2htaWR0XHJcbiovXG5cbmNsYXNzIFBERlN0cnVjdHVyZUNvbnRlbnQge1xuICBjb25zdHJ1Y3RvcihwYWdlUmVmLCBtY2lkKSB7XG4gICAgdGhpcy5yZWZzID0gW3tcbiAgICAgIHBhZ2VSZWYsXG4gICAgICBtY2lkXG4gICAgfV07XG4gIH1cbiAgcHVzaChzdHJ1Y3RDb250ZW50KSB7XG4gICAgc3RydWN0Q29udGVudC5yZWZzLmZvckVhY2gocmVmID0+IHRoaXMucmVmcy5wdXNoKHJlZikpO1xuICB9XG59XG5cbi8qXHJcblBERlN0cnVjdHVyZUVsZW1lbnQgLSByZXByZXNlbnRzIGFuIGVsZW1lbnQgaW4gdGhlIFBERiBsb2dpY2FsIHN0cnVjdHVyZSB0cmVlXHJcbkJ5IEJlbiBTY2htaWR0XHJcbiovXG5jbGFzcyBQREZTdHJ1Y3R1cmVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHR5cGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNoaWxkcmVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZmx1c2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGljdGlvbmFyeSA9IGRvY3VtZW50LnJlZih7XG4gICAgICAvLyBUeXBlOiBcIlN0cnVjdEVsZW1cIixcbiAgICAgIFM6IHR5cGVcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kaWN0aW9uYXJ5LmRhdGE7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgdGhpcy5faXNWYWxpZENoaWxkKG9wdGlvbnMpKSB7XG4gICAgICBjaGlsZHJlbiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aXRsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuVCA9IG5ldyBTdHJpbmcob3B0aW9ucy50aXRsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sYW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5MYW5nID0gbmV3IFN0cmluZyhvcHRpb25zLmxhbmcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5BbHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWx0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGFuZGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5FID0gbmV3IFN0cmluZyhvcHRpb25zLmV4cGFuZGVkKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFjdHVhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuQWN0dWFsVGV4dCA9IG5ldyBTdHJpbmcob3B0aW9ucy5hY3R1YWwpO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHRoaXMuYWRkKGNoaWxkKSk7XG4gICAgICB0aGlzLmVuZCgpO1xuICAgIH1cbiAgfVxuICBhZGQoY2hpbGQpIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCBjaGlsZCB0byBhbHJlYWR5LWVuZGVkIHN0cnVjdHVyZSBlbGVtZW50YCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNWYWxpZENoaWxkKGNoaWxkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cnVjdHVyZSBlbGVtZW50IGNoaWxkYCk7XG4gICAgfVxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQpIHtcbiAgICAgIGNoaWxkLnNldFBhcmVudCh0aGlzLmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkKSB7XG4gICAgICAgIGNoaWxkLnNldEF0dGFjaGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUNvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2FkZENvbnRlbnRUb1BhcmVudFRyZWUoY2hpbGQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX2F0dGFjaGVkKSB7XG4gICAgICAvLyBfY29udGVudEZvckNsb3N1cmUoKSBhZGRzIHRoZSBjb250ZW50IHRvIHRoZSBwYXJlbnQgdHJlZVxuICAgICAgY2hpbGQgPSB0aGlzLl9jb250ZW50Rm9yQ2xvc3VyZShjaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9hZGRDb250ZW50VG9QYXJlbnRUcmVlKGNvbnRlbnQpIHtcbiAgICBjb250ZW50LnJlZnMuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHBhZ2VSZWYsXG4gICAgICAgIG1jaWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3QgcGFnZVN0cnVjdFBhcmVudHMgPSB0aGlzLmRvY3VtZW50LmdldFN0cnVjdFBhcmVudFRyZWUoKS5nZXQocGFnZVJlZi5kYXRhLlN0cnVjdFBhcmVudHMpO1xuICAgICAgcGFnZVN0cnVjdFBhcmVudHNbbWNpZF0gPSB0aGlzLmRpY3Rpb25hcnk7XG4gICAgfSk7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudFJlZikge1xuICAgIGlmICh0aGlzLmRpY3Rpb25hcnkuZGF0YS5QKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cnVjdHVyZSBlbGVtZW50IGFkZGVkIHRvIG1vcmUgdGhhbiBvbmUgcGFyZW50YCk7XG4gICAgfVxuICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLlAgPSBwYXJlbnRSZWY7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgfVxuICBzZXRBdHRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICAgIGNoaWxkLnNldEF0dGFjaGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IHRoaXMuX2NvbnRlbnRGb3JDbG9zdXJlKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9hdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgfVxuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQpLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuZW5kKCkpO1xuICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9mbHVzaCgpO1xuICB9XG4gIF9pc1ZhbGlkQ2hpbGQoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlQ29udGVudCB8fCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbic7XG4gIH1cbiAgX2NvbnRlbnRGb3JDbG9zdXJlKGNsb3N1cmUpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kb2N1bWVudC5tYXJrU3RydWN0dXJlQ29udGVudCh0aGlzLmRpY3Rpb25hcnkuZGF0YS5TKTtcbiAgICBjbG9zdXJlKCk7XG4gICAgdGhpcy5kb2N1bWVudC5lbmRNYXJrZWRDb250ZW50KCk7XG4gICAgdGhpcy5fYWRkQ29udGVudFRvUGFyZW50VHJlZShjb250ZW50KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBfaXNGbHVzaGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmRpY3Rpb25hcnkuZGF0YS5QIHx8ICF0aGlzLl9lbmRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5faXNGbHVzaGFibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIF9mbHVzaCgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hlZCB8fCAhdGhpcy5faXNGbHVzaGFibGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLl9mbHVzaENoaWxkKGNoaWxkKSk7XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuXG4gICAgLy8gZnJlZSBtZW1vcnkgdXNlZCBieSBjaGlsZHJlbjsgdGhlIGRpY3Rpb25hcnkgaXRzZWxmIG1heSBzdGlsbCBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYnkgYSBwYXJlbnQgc3RydWN0dXJlIGVsZW1lbnQgb3Igcm9vdCwgYnV0IHdlIGNhblxuICAgIC8vIGF0IGxlYXN0IHRyaW0gdGhlIHRyZWUgaGVyZVxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSyA9IG51bGw7XG4gICAgdGhpcy5fZmx1c2hlZCA9IHRydWU7XG4gIH1cbiAgX2ZsdXNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LLnB1c2goY2hpbGQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUNvbnRlbnQpIHtcbiAgICAgIGNoaWxkLnJlZnMuZm9yRWFjaChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgcGFnZVJlZixcbiAgICAgICAgICBtY2lkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgaWYgKCF0aGlzLmRpY3Rpb25hcnkuZGF0YS5QZykge1xuICAgICAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLlBnID0gcGFnZVJlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUGcgPT09IHBhZ2VSZWYpIHtcbiAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LLnB1c2gobWNpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSy5wdXNoKHtcbiAgICAgICAgICAgIFR5cGU6IFwiTUNSXCIsXG4gICAgICAgICAgICBQZzogcGFnZVJlZixcbiAgICAgICAgICAgIE1DSUQ6IG1jaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qXHJcblBERk51bWJlclRyZWUgLSByZXByZXNlbnRzIGEgbnVtYmVyIHRyZWUgb2JqZWN0XHJcbiovXG5jbGFzcyBQREZOdW1iZXJUcmVlIGV4dGVuZHMgUERGVHJlZSB7XG4gIF9jb21wYXJlS2V5cyhhLCBiKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGEpIC0gcGFyc2VJbnQoYik7XG4gIH1cbiAgX2tleXNOYW1lKCkge1xuICAgIHJldHVybiBcIk51bXNcIjtcbiAgfVxuICBfZGF0YUZvcktleShrKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGspO1xuICB9XG59XG5cbi8qXHJcbk1hcmtpbmdzIG1peGluIC0gc3VwcG9ydCBtYXJrZWQgY29udGVudCBzZXF1ZW5jZXMgaW4gY29udGVudCBzdHJlYW1zXHJcbkJ5IEJlbiBTY2htaWR0XHJcbiovXG52YXIgTWFya2luZ3NNaXhpbiA9IHtcbiAgaW5pdE1hcmtpbmdzKG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0cnVjdENoaWxkcmVuID0gW107XG4gICAgaWYgKG9wdGlvbnMudGFnZ2VkKSB7XG4gICAgICB0aGlzLmdldE1hcmtJbmZvRGljdGlvbmFyeSgpLmRhdGEuTWFya2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKTtcbiAgICB9XG4gIH0sXG4gIG1hcmtDb250ZW50KHRhZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGlmICh0YWcgPT09ICdBcnRpZmFjdCcgfHwgb3B0aW9ucyAmJiBvcHRpb25zLm1jaWQpIHtcbiAgICAgIGxldCB0b0Nsb3NlID0gMDtcbiAgICAgIHRoaXMucGFnZS5tYXJraW5ncy5mb3JFYWNoKG1hcmtpbmcgPT4ge1xuICAgICAgICBpZiAodG9DbG9zZSB8fCBtYXJraW5nLnN0cnVjdENvbnRlbnQgfHwgbWFya2luZy50YWcgPT09ICdBcnRpZmFjdCcpIHtcbiAgICAgICAgICB0b0Nsb3NlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2hpbGUgKHRvQ2xvc2UtLSkge1xuICAgICAgICB0aGlzLmVuZE1hcmtlZENvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aGlzLnBhZ2UubWFya2luZ3MucHVzaCh7XG4gICAgICAgIHRhZ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoYC8ke3RhZ30gQk1DYCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5wYWdlLm1hcmtpbmdzLnB1c2goe1xuICAgICAgdGFnLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWNpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRpY3Rpb25hcnkuTUNJRCA9IG9wdGlvbnMubWNpZDtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ0FydGlmYWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuVHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYmJveCkpIHtcbiAgICAgICAgZGljdGlvbmFyeS5CQm94ID0gW29wdGlvbnMuYmJveFswXSwgdGhpcy5wYWdlLmhlaWdodCAtIG9wdGlvbnMuYmJveFszXSwgb3B0aW9ucy5iYm94WzJdLCB0aGlzLnBhZ2UuaGVpZ2h0IC0gb3B0aW9ucy5iYm94WzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0YWNoZWQpICYmIG9wdGlvbnMuYXR0YWNoZWQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBkaWN0aW9uYXJ5LkF0dGFjaGVkID0gb3B0aW9ucy5hdHRhY2hlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ1NwYW4nKSB7XG4gICAgICBpZiAob3B0aW9ucy5sYW5nKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuTGFuZyA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFsdCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkFsdCA9IG5ldyBTdHJpbmcob3B0aW9ucy5hbHQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgICAgZGljdGlvbmFyeS5FID0gbmV3IFN0cmluZyhvcHRpb25zLmV4cGFuZGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFjdHVhbCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkFjdHVhbFRleHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWN0dWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRDb250ZW50KGAvJHt0YWd9ICR7UERGT2JqZWN0LmNvbnZlcnQoZGljdGlvbmFyeSl9IEJEQ2ApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtYXJrU3RydWN0dXJlQ29udGVudCh0YWcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcGFnZVN0cnVjdFBhcmVudHMgPSB0aGlzLmdldFN0cnVjdFBhcmVudFRyZWUoKS5nZXQodGhpcy5wYWdlLnN0cnVjdFBhcmVudFRyZWVLZXkpO1xuICAgIGNvbnN0IG1jaWQgPSBwYWdlU3RydWN0UGFyZW50cy5sZW5ndGg7XG4gICAgcGFnZVN0cnVjdFBhcmVudHMucHVzaChudWxsKTtcbiAgICB0aGlzLm1hcmtDb250ZW50KHRhZywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG1jaWRcbiAgICB9KTtcbiAgICBjb25zdCBzdHJ1Y3RDb250ZW50ID0gbmV3IFBERlN0cnVjdHVyZUNvbnRlbnQodGhpcy5wYWdlLmRpY3Rpb25hcnksIG1jaWQpO1xuICAgIHRoaXMucGFnZS5tYXJraW5ncy5zbGljZSgtMSlbMF0uc3RydWN0Q29udGVudCA9IHN0cnVjdENvbnRlbnQ7XG4gICAgcmV0dXJuIHN0cnVjdENvbnRlbnQ7XG4gIH0sXG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5wYWdlLm1hcmtpbmdzLnBvcCgpO1xuICAgIHRoaXMuYWRkQ29udGVudCgnRU1DJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0cnVjdCh0eXBlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBjaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERlN0cnVjdHVyZUVsZW1lbnQodGhpcywgdHlwZSwgb3B0aW9ucywgY2hpbGRyZW4pO1xuICB9LFxuICBhZGRTdHJ1Y3R1cmUoc3RydWN0RWxlbSkge1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpO1xuICAgIHN0cnVjdEVsZW0uc2V0UGFyZW50KHN0cnVjdFRyZWVSb290KTtcbiAgICBzdHJ1Y3RFbGVtLnNldEF0dGFjaGVkKCk7XG4gICAgdGhpcy5zdHJ1Y3RDaGlsZHJlbi5wdXNoKHN0cnVjdEVsZW0pO1xuICAgIGlmICghc3RydWN0VHJlZVJvb3QuZGF0YS5LKSB7XG4gICAgICBzdHJ1Y3RUcmVlUm9vdC5kYXRhLksgPSBbXTtcbiAgICB9XG4gICAgc3RydWN0VHJlZVJvb3QuZGF0YS5LLnB1c2goc3RydWN0RWxlbS5kaWN0aW9uYXJ5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaW5pdFBhZ2VNYXJraW5ncyhwYWdlTWFya2luZ3MpIHtcbiAgICBwYWdlTWFya2luZ3MuZm9yRWFjaChtYXJraW5nID0+IHtcbiAgICAgIGlmIChtYXJraW5nLnN0cnVjdENvbnRlbnQpIHtcbiAgICAgICAgY29uc3Qgc3RydWN0Q29udGVudCA9IG1hcmtpbmcuc3RydWN0Q29udGVudDtcbiAgICAgICAgY29uc3QgbmV3U3RydWN0Q29udGVudCA9IHRoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQobWFya2luZy50YWcsIG1hcmtpbmcub3B0aW9ucyk7XG4gICAgICAgIHN0cnVjdENvbnRlbnQucHVzaChuZXdTdHJ1Y3RDb250ZW50KTtcbiAgICAgICAgdGhpcy5wYWdlLm1hcmtpbmdzLnNsaWNlKC0xKVswXS5zdHJ1Y3RDb250ZW50ID0gc3RydWN0Q29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFya0NvbnRlbnQobWFya2luZy50YWcsIG1hcmtpbmcub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGVuZFBhZ2VNYXJraW5ncyhwYWdlKSB7XG4gICAgY29uc3QgcGFnZU1hcmtpbmdzID0gcGFnZS5tYXJraW5ncztcbiAgICBwYWdlTWFya2luZ3MuZm9yRWFjaCgoKSA9PiBwYWdlLndyaXRlKCdFTUMnKSk7XG4gICAgcGFnZS5tYXJraW5ncyA9IFtdO1xuICAgIHJldHVybiBwYWdlTWFya2luZ3M7XG4gIH0sXG4gIGdldE1hcmtJbmZvRGljdGlvbmFyeSgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvID0gdGhpcy5yZWYoe30pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvO1xuICB9LFxuICBnZXRTdHJ1Y3RUcmVlUm9vdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290ID0gdGhpcy5yZWYoe1xuICAgICAgICBUeXBlOiAnU3RydWN0VHJlZVJvb3QnLFxuICAgICAgICBQYXJlbnRUcmVlOiBuZXcgUERGTnVtYmVyVHJlZSgpLFxuICAgICAgICBQYXJlbnRUcmVlTmV4dEtleTogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuU3RydWN0VHJlZVJvb3Q7XG4gIH0sXG4gIGdldFN0cnVjdFBhcmVudFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKS5kYXRhLlBhcmVudFRyZWU7XG4gIH0sXG4gIGNyZWF0ZVN0cnVjdFBhcmVudFRyZWVOZXh0S2V5KCkge1xuICAgIC8vIGluaXRpYWxpc2UgdGhlIE1hcmtJbmZvIGRpY3Rpb25hcnlcbiAgICB0aGlzLmdldE1hcmtJbmZvRGljdGlvbmFyeSgpO1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpO1xuICAgIGNvbnN0IGtleSA9IHN0cnVjdFRyZWVSb290LmRhdGEuUGFyZW50VHJlZU5leHRLZXkrKztcbiAgICBzdHJ1Y3RUcmVlUm9vdC5kYXRhLlBhcmVudFRyZWUuYWRkKGtleSwgW10pO1xuICAgIHJldHVybiBrZXk7XG4gIH0sXG4gIGVuZE1hcmtpbmdzKCkge1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290O1xuICAgIGlmIChzdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgc3RydWN0VHJlZVJvb3QuZW5kKCk7XG4gICAgICB0aGlzLnN0cnVjdENoaWxkcmVuLmZvckVhY2goc3RydWN0RWxlbSA9PiBzdHJ1Y3RFbGVtLmVuZCgpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvLmVuZCgpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgRklFTERfRkxBR1MgPSB7XG4gIHJlYWRPbmx5OiAxLFxuICByZXF1aXJlZDogMixcbiAgbm9FeHBvcnQ6IDQsXG4gIG11bHRpbGluZTogMHgxMDAwLFxuICBwYXNzd29yZDogMHgyMDAwLFxuICB0b2dnbGVUb09mZkJ1dHRvbjogMHg0MDAwLFxuICByYWRpb0J1dHRvbjogMHg4MDAwLFxuICBwdXNoQnV0dG9uOiAweDEwMDAwLFxuICBjb21ibzogMHgyMDAwMCxcbiAgZWRpdDogMHg0MDAwMCxcbiAgc29ydDogMHg4MDAwMCxcbiAgbXVsdGlTZWxlY3Q6IDB4MjAwMDAwLFxuICBub1NwZWxsOiAweDQwMDAwMFxufTtcbmNvbnN0IEZJRUxEX0pVU1RJRlkgPSB7XG4gIGxlZnQ6IDAsXG4gIGNlbnRlcjogMSxcbiAgcmlnaHQ6IDJcbn07XG5jb25zdCBWQUxVRV9NQVAgPSB7XG4gIHZhbHVlOiAnVicsXG4gIGRlZmF1bHRWYWx1ZTogJ0RWJ1xufTtcbmNvbnN0IEZPUk1BVF9TUEVDSUFMID0ge1xuICB6aXA6ICcwJyxcbiAgemlwUGx1czQ6ICcxJyxcbiAgemlwNDogJzEnLFxuICBwaG9uZTogJzInLFxuICBzc246ICczJ1xufTtcbmNvbnN0IEZPUk1BVF9ERUZBVUxUID0ge1xuICBudW1iZXI6IHtcbiAgICBuRGVjOiAwLFxuICAgIHNlcENvbW1hOiBmYWxzZSxcbiAgICBuZWdTdHlsZTogJ01pbnVzQmxhY2snLFxuICAgIGN1cnJlbmN5OiAnJyxcbiAgICBjdXJyZW5jeVByZXBlbmQ6IHRydWVcbiAgfSxcbiAgcGVyY2VudDoge1xuICAgIG5EZWM6IDAsXG4gICAgc2VwQ29tbWE6IGZhbHNlXG4gIH1cbn07XG52YXIgQWNyb0Zvcm1NaXhpbiA9IHtcbiAgLyoqXHJcbiAgICogTXVzdCBjYWxsIGlmIGFkZGluZyBBY3JvRm9ybXMgdG8gYSBkb2N1bWVudC4gTXVzdCBhbHNvIGNhbGwgZm9udCgpIGJlZm9yZVxyXG4gICAqIHRoaXMgbWV0aG9kIHRvIHNldCB0aGUgZGVmYXVsdCBmb250LlxyXG4gICAqL1xuICBpbml0Rm9ybSgpIHtcbiAgICBpZiAoIXRoaXMuX2ZvbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzZXQgYSBmb250IGJlZm9yZSBjYWxsaW5nIGluaXRGb3JtIG1ldGhvZCcpO1xuICAgIH1cbiAgICB0aGlzLl9hY3JvZm9ybSA9IHtcbiAgICAgIGZvbnRzOiB7fSxcbiAgICAgIGRlZmF1bHRGb250OiB0aGlzLl9mb250Lm5hbWVcbiAgICB9O1xuICAgIHRoaXMuX2Fjcm9mb3JtLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIEZpZWxkczogW10sXG4gICAgICBOZWVkQXBwZWFyYW5jZXM6IHRydWUsXG4gICAgICBEQTogbmV3IFN0cmluZyhgLyR7dGhpcy5fZm9udC5pZH0gMCBUZiAwIGdgKSxcbiAgICAgIERSOiB7XG4gICAgICAgIEZvbnQ6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgICBkYXRhLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIGNvbnN0IEFjcm9Gb3JtID0gdGhpcy5yZWYoZGF0YSk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtID0gQWNyb0Zvcm07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxyXG4gICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IGRvY3VtZW50LmpzXHJcbiAgICovXG4gIGVuZEFjcm9Gb3JtKCkge1xuICAgIGlmICh0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0pIHtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5fYWNyb2Zvcm0uZm9udHMpLmxlbmd0aCAmJiAhdGhpcy5fYWNyb2Zvcm0uZGVmYXVsdEZvbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmb250cyBzcGVjaWZpZWQgZm9yIFBERiBmb3JtJyk7XG4gICAgICB9XG4gICAgICBsZXQgZm9udERpY3QgPSB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZGF0YS5EUi5Gb250O1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fYWNyb2Zvcm0uZm9udHMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGZvbnREaWN0W25hbWVdID0gdGhpcy5fYWNyb2Zvcm0uZm9udHNbbmFtZV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5kYXRhLkZpZWxkcy5mb3JFYWNoKGZpZWxkUmVmID0+IHtcbiAgICAgICAgdGhpcy5fZW5kQ2hpbGQoZmllbGRSZWYpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZW5kQ2hpbGQocmVmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmLmRhdGEuS2lkcykpIHtcbiAgICAgIHJlZi5kYXRhLktpZHMuZm9yRWFjaChjaGlsZFJlZiA9PiB7XG4gICAgICAgIHRoaXMuX2VuZENoaWxkKGNoaWxkUmVmKTtcbiAgICAgIH0pO1xuICAgICAgcmVmLmVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIGZvcm0gZmllbGQgdG8gdGhlIGRvY3VtZW50LiBGb3JtIGZpZWxkcyBhcmUgaW50ZXJtZWRpYXRlXHJcbiAgICogbm9kZXMgaW4gYSBQREYgZm9ybSB0aGF0IGFyZSB1c2VkIHRvIHNwZWNpZnkgZm9ybSBuYW1lIGhlaXJhcmNoeSBhbmQgZm9ybVxyXG4gICAqIHZhbHVlIGRlZmF1bHRzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gZmllbGQgbmFtZSAoVCBhdHRyaWJ1dGUgaW4gZmllbGQgZGljdGlvbmFyeSlcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgLSBvdGhlciBhdHRyaWJ1dGVzIHRvIGluY2x1ZGUgaW4gZmllbGQgZGljdGlvbmFyeVxyXG4gICAqL1xuICBmb3JtRmllbGQobmFtZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgZmllbGREaWN0ID0gdGhpcy5fZmllbGREaWN0KG5hbWUsIG51bGwsIG9wdGlvbnMpO1xuICAgIGxldCBmaWVsZFJlZiA9IHRoaXMucmVmKGZpZWxkRGljdCk7XG4gICAgdGhpcy5fYWRkVG9QYXJlbnQoZmllbGRSZWYpO1xuICAgIHJldHVybiBmaWVsZFJlZjtcbiAgfSxcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIEZvcm0gQW5ub3RhdGlvbiB0byB0aGUgZG9jdW1lbnQuIEZvcm0gYW5ub3RhdGlvbnMgYXJlXHJcbiAgICogY2FsbGVkIFdpZGdldCBhbm5vdGF0aW9ucyBpbnRlcm5hbGx5IHdpdGhpbiBhIFBERiBmaWxlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gZm9ybSBmaWVsZCBuYW1lIChUIGF0dHJpYnV0ZSBvZiB3aWRnZXQgYW5ub3RhdGlvblxyXG4gICAqIGRpY3Rpb25hcnkpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAqL1xuICBmb3JtQW5ub3RhdGlvbihuYW1lLCB0eXBlLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9O1xuICAgIGxldCBmaWVsZERpY3QgPSB0aGlzLl9maWVsZERpY3QobmFtZSwgdHlwZSwgb3B0aW9ucyk7XG4gICAgZmllbGREaWN0LlN1YnR5cGUgPSAnV2lkZ2V0JztcbiAgICBpZiAoZmllbGREaWN0LkYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmllbGREaWN0LkYgPSA0OyAvLyBwcmludCB0aGUgYW5ub3RhdGlvblxuICAgIH1cblxuICAgIC8vIEFkZCBGaWVsZCBhbm5vdCB0byBwYWdlLCBhbmQgZ2V0IGl0J3MgcmVmXG4gICAgdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBmaWVsZERpY3QpO1xuICAgIGxldCBhbm5vdFJlZiA9IHRoaXMucGFnZS5hbm5vdGF0aW9uc1t0aGlzLnBhZ2UuYW5ub3RhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHRoaXMuX2FkZFRvUGFyZW50KGFubm90UmVmKTtcbiAgfSxcbiAgZm9ybVRleHQobmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAndGV4dCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtUHVzaEJ1dHRvbihuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdwdXNoQnV0dG9uJywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGZvcm1Db21ibyhuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdjb21ibycsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtTGlzdChuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdsaXN0JywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGZvcm1SYWRpb0J1dHRvbihuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdyYWRpb0J1dHRvbicsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtQ2hlY2tib3gobmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAnY2hlY2tib3gnLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgX2FkZFRvUGFyZW50KGZpZWxkUmVmKSB7XG4gICAgbGV0IHBhcmVudCA9IGZpZWxkUmVmLmRhdGEuUGFyZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmICghcGFyZW50LmRhdGEuS2lkcykge1xuICAgICAgICBwYXJlbnQuZGF0YS5LaWRzID0gW107XG4gICAgICB9XG4gICAgICBwYXJlbnQuZGF0YS5LaWRzLnB1c2goZmllbGRSZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZGF0YS5GaWVsZHMucHVzaChmaWVsZFJlZik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZmllbGREaWN0KG5hbWUsIHR5cGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCF0aGlzLl9hY3JvZm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGRvY3VtZW50LmluaXRGb3JtKCkgbWV0aG9kIGJlZm9yZSBhZGRpbmcgZm9ybSBlbGVtZW50cyB0byBkb2N1bWVudCcpO1xuICAgIH1cbiAgICBsZXQgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZVR5cGUodHlwZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlRmxhZ3Mob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVKdXN0aWZ5KG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlRm9udChvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZVN0cmluZ3Mob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVDb2xvcnMob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVGb3JtYXQob3B0cyk7XG4gICAgb3B0cy5UID0gbmV3IFN0cmluZyhuYW1lKTtcbiAgICBpZiAob3B0cy5wYXJlbnQpIHtcbiAgICAgIG9wdHMuUGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gICAgICBkZWxldGUgb3B0cy5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZVR5cGUodHlwZSwgb3B0cykge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIG9wdHMuRlQgPSAnVHgnO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3B1c2hCdXR0b24nKSB7XG4gICAgICBvcHRzLkZUID0gJ0J0bic7XG4gICAgICBvcHRzLnB1c2hCdXR0b24gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGlvQnV0dG9uJykge1xuICAgICAgb3B0cy5GVCA9ICdCdG4nO1xuICAgICAgb3B0cy5yYWRpb0J1dHRvbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBvcHRzLkZUID0gJ0J0bic7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29tYm8nKSB7XG4gICAgICBvcHRzLkZUID0gJ0NoJztcbiAgICAgIG9wdHMuY29tYm8gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICBvcHRzLkZUID0gJ0NoJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcm0gYW5ub3RhdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cztcbiAgfSxcbiAgX3Jlc29sdmVGb3JtYXQob3B0cykge1xuICAgIGNvbnN0IGYgPSBvcHRzLmZvcm1hdDtcbiAgICBpZiAoZiAmJiBmLnR5cGUpIHtcbiAgICAgIGxldCBmbktleXN0cm9rZTtcbiAgICAgIGxldCBmbkZvcm1hdDtcbiAgICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICAgIGlmIChGT1JNQVRfU1BFQ0lBTFtmLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm5LZXlzdHJva2UgPSBgQUZTcGVjaWFsX0tleXN0cm9rZWA7XG4gICAgICAgIGZuRm9ybWF0ID0gYEFGU3BlY2lhbF9Gb3JtYXRgO1xuICAgICAgICBwYXJhbXMgPSBGT1JNQVRfU1BFQ0lBTFtmLnR5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGZvcm1hdCA9IGYudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGYudHlwZS5zbGljZSgxKTtcbiAgICAgICAgZm5LZXlzdHJva2UgPSBgQUYke2Zvcm1hdH1fS2V5c3Ryb2tlYDtcbiAgICAgICAgZm5Gb3JtYXQgPSBgQUYke2Zvcm1hdH1fRm9ybWF0YDtcbiAgICAgICAgaWYgKGYudHlwZSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgZm5LZXlzdHJva2UgKz0gJ0V4JztcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoZi5wYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoZi5wYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxldCBwID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUX0RFRkFVTFQubnVtYmVyLCBmKTtcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoW1N0cmluZyhwLm5EZWMpLCBwLnNlcENvbW1hID8gJzAnIDogJzEnLCAnXCInICsgcC5uZWdTdHlsZSArICdcIicsICdudWxsJywgJ1wiJyArIHAuY3VycmVuY3kgKyAnXCInLCBTdHJpbmcocC5jdXJyZW5jeVByZXBlbmQpXS5qb2luKCcsJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgbGV0IHAgPSBPYmplY3QuYXNzaWduKHt9LCBGT1JNQVRfREVGQVVMVC5wZXJjZW50LCBmKTtcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoW1N0cmluZyhwLm5EZWMpLCBwLnNlcENvbW1hID8gJzAnIDogJzEnXS5qb2luKCcsJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRzLkFBID0gb3B0cy5BQSA/IG9wdHMuQUEgOiB7fTtcbiAgICAgIG9wdHMuQUEuSyA9IHtcbiAgICAgICAgUzogJ0phdmFTY3JpcHQnLFxuICAgICAgICBKUzogbmV3IFN0cmluZyhgJHtmbktleXN0cm9rZX0oJHtwYXJhbXN9KTtgKVxuICAgICAgfTtcbiAgICAgIG9wdHMuQUEuRiA9IHtcbiAgICAgICAgUzogJ0phdmFTY3JpcHQnLFxuICAgICAgICBKUzogbmV3IFN0cmluZyhgJHtmbkZvcm1hdH0oJHtwYXJhbXN9KTtgKVxuICAgICAgfTtcbiAgICB9XG4gICAgZGVsZXRlIG9wdHMuZm9ybWF0O1xuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZUNvbG9ycyhvcHRzKSB7XG4gICAgbGV0IGNvbG9yID0gdGhpcy5fbm9ybWFsaXplQ29sb3Iob3B0cy5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgaWYgKCFvcHRzLk1LKSB7XG4gICAgICAgIG9wdHMuTUsgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9wdHMuTUsuQkcgPSBjb2xvcjtcbiAgICB9XG4gICAgY29sb3IgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihvcHRzLmJvcmRlckNvbG9yKTtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGlmICghb3B0cy5NSykge1xuICAgICAgICBvcHRzLk1LID0ge307XG4gICAgICB9XG4gICAgICBvcHRzLk1LLkJDID0gY29sb3I7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICBkZWxldGUgb3B0cy5ib3JkZXJDb2xvcjtcbiAgICByZXR1cm4gb3B0cztcbiAgfSxcbiAgX3Jlc29sdmVGbGFncyhvcHRpb25zKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKEZJRUxEX0ZMQUdTW2tleV0pIHtcbiAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgIHJlc3VsdCB8PSBGSUVMRF9GTEFHU1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgb3B0aW9ucy5GZiA9IG9wdGlvbnMuRmYgPyBvcHRpb25zLkZmIDogMDtcbiAgICAgIG9wdGlvbnMuRmYgfD0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcbiAgX3Jlc29sdmVKdXN0aWZ5KG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBpZiAob3B0aW9ucy5hbGlnbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIEZJRUxEX0pVU1RJRllbb3B0aW9ucy5hbGlnbl0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IEZJRUxEX0pVU1RJRllbb3B0aW9ucy5hbGlnbl07XG4gICAgICB9XG4gICAgICBkZWxldGUgb3B0aW9ucy5hbGlnbjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgb3B0aW9ucy5RID0gcmVzdWx0OyAvLyBkZWZhdWx0XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuICBfcmVzb2x2ZUZvbnQob3B0aW9ucykge1xuICAgIC8vIGFkZCBjdXJyZW50IGZvbnQgdG8gZG9jdW1lbnQtbGV2ZWwgQWNyb0Zvcm0gZGljdCBpZiBuZWNlc3NhcnlcbiAgICBpZiAodGhpcy5fYWNyb2Zvcm0uZm9udHNbdGhpcy5fZm9udC5pZF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5fYWNyb2Zvcm0uZm9udHNbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIH1cblxuICAgIC8vIGFkZCBjdXJyZW50IGZvbnQgdG8gZmllbGQncyByZXNvdXJjZSBkaWN0IChSRCkgaWYgbm90IHRoZSBkZWZhdWx0IGFjcm9mb3JtIGZvbnRcbiAgICBpZiAodGhpcy5fYWNyb2Zvcm0uZGVmYXVsdEZvbnQgIT09IHRoaXMuX2ZvbnQubmFtZSkge1xuICAgICAgb3B0aW9ucy5EUiA9IHtcbiAgICAgICAgRm9udDoge31cbiAgICAgIH07XG5cbiAgICAgIC8vIEdldCB0aGUgZm9udFNpemUgb3B0aW9uLiBJZiBub3Qgc2V0IHVzZSBhdXRvIHNpemluZ1xuICAgICAgY29uc3QgZm9udFNpemUgPSBvcHRpb25zLmZvbnRTaXplIHx8IDA7XG4gICAgICBvcHRpb25zLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoYC8ke3RoaXMuX2ZvbnQuaWR9ICR7Zm9udFNpemV9IFRmIDAgZ2ApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcbiAgX3Jlc29sdmVTdHJpbmdzKG9wdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0ID0gW107XG4gICAgZnVuY3Rpb24gYXBwZW5kQ2hvaWNlcyhhKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFbaWR4XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdC5wdXNoKG5ldyBTdHJpbmcoYVtpZHhdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdC5wdXNoKGFbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGVuZENob2ljZXMob3B0aW9ucy5PcHQpO1xuICAgIGlmIChvcHRpb25zLnNlbGVjdCkge1xuICAgICAgYXBwZW5kQ2hvaWNlcyhvcHRpb25zLnNlbGVjdCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zZWxlY3Q7XG4gICAgfVxuICAgIGlmIChzZWxlY3QubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zLk9wdCA9IHNlbGVjdDtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoVkFMVUVfTUFQKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9uc1tWQUxVRV9NQVBba2V5XV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgWydWJywgJ0RWJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IG5ldyBTdHJpbmcob3B0aW9uc1trZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5NSyAmJiBvcHRpb25zLk1LLkNBKSB7XG4gICAgICBvcHRpb25zLk1LLkNBID0gbmV3IFN0cmluZyhvcHRpb25zLk1LLkNBKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIG9wdGlvbnMuTUsgPSBvcHRpb25zLk1LID8gb3B0aW9ucy5NSyA6IHt9O1xuICAgICAgb3B0aW9ucy5NSy5DQSA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYWJlbCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn07XG5cbnZhciBBdHRhY2htZW50c01peGluID0ge1xuICAvKipcclxuICAgKiBFbWJlZCBjb250ZW50cyBvZiBgc3JjYCBpbiBQREZcclxuICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyIHwgc3RyaW5nfSBzcmMgaW5wdXQgQnVmZmVyLCBBcnJheUJ1ZmZlciwgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9yIHBhdGggdG8gZmlsZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcbiAgICogICogb3B0aW9ucy5uYW1lOiBmaWxlbmFtZSB0byBiZSBzaG93biBpbiBQREYsIHdpbGwgdXNlIGBzcmNgIGlmIG5vbmUgc2V0XHJcbiAgICogICogb3B0aW9ucy50eXBlOiBmaWxldHlwZSB0byBiZSBzaG93biBpbiBQREZcclxuICAgKiAgKiBvcHRpb25zLmRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB0byBiZSBzaG93biBpbiBQREZcclxuICAgKiAgKiBvcHRpb25zLmhpZGRlbjogaWYgdHJ1ZSwgZG8gbm90IGFkZCBhdHRhY2htZW50IHRvIEVtYmVkZGVkRmlsZXMgZGljdGlvbmFyeS4gVXNlZnVsIGZvciBmaWxlIGF0dGFjaG1lbnQgYW5ub3RhdGlvbnNcclxuICAgKiAgKiBvcHRpb25zLmNyZWF0aW9uRGF0ZTogb3ZlcnJpZGUgY3JlYXRpb24gZGF0ZVxyXG4gICAqICAqIG9wdGlvbnMubW9kaWZpZWREYXRlOiBvdmVycmlkZSBtb2RpZmllZCBkYXRlXHJcbiAgICogICogb3B0aW9ucy5yZWxhdGlvbnNoaXA6IFJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZSBQREYgZG9jdW1lbnQgYW5kIGl0cyBhdHRhY2hlZCBmaWxlLiBDYW4gYmUgJ0FsdGVybmF0aXZlJywgJ0RhdGEnLCAnU291cmNlJywgJ1N1cHBsZW1lbnQnIG9yICdVbnNwZWNpZmllZCcuXHJcbiAgICogQHJldHVybnMgZmlsZXNwZWMgcmVmZXJlbmNlXHJcbiAgICovXG4gIGZpbGUoc3JjKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBzcmM7XG4gICAgb3B0aW9ucy5yZWxhdGlvbnNoaXAgPSBvcHRpb25zLnJlbGF0aW9uc2hpcCB8fCAnVW5zcGVjaWZpZWQnO1xuICAgIGNvbnN0IHJlZkJvZHkgPSB7XG4gICAgICBUeXBlOiAnRW1iZWRkZWRGaWxlJyxcbiAgICAgIFBhcmFtczoge31cbiAgICB9O1xuICAgIGxldCBkYXRhO1xuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNyYyBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpKSB7XG4gICAgICBkYXRhID0gc3JjO1xuICAgIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgaWYgKG1hdGNoID0gL15kYXRhOiguKj8pO2Jhc2U2NCwoLiopJC8uZXhlYyhzcmMpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIHJlZkJvZHkuU3VidHlwZSA9IG1hdGNoWzFdLnJlcGxhY2UoJy8nLCAnIzJGJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG1hdGNoWzJdLCAnYmFzZTY0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlYWQgY29udGVudHMgb2YgZmlsZSBhdCBmaWxlcGF0aCAke3NyY31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBDcmVhdGlvbkRhdGUgYW5kIE1vZERhdGVcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJpcnRodGltZSxcbiAgICAgICAgICBjdGltZVxuICAgICAgICB9ID0gZnMuc3RhdFN5bmMoc3JjKTtcbiAgICAgICAgcmVmQm9keS5QYXJhbXMuQ3JlYXRpb25EYXRlID0gYmlydGh0aW1lO1xuICAgICAgICByZWZCb2R5LlBhcmFtcy5Nb2REYXRlID0gY3RpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgY3JlYXRpb24gZGF0ZSBhbmQgbW9kaWZpZWQgZGF0ZVxuICAgIGlmIChvcHRpb25zLmNyZWF0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJlZkJvZHkuUGFyYW1zLkNyZWF0aW9uRGF0ZSA9IG9wdGlvbnMuY3JlYXRpb25EYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RpZmllZERhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZWZCb2R5LlBhcmFtcy5Nb2REYXRlID0gb3B0aW9ucy5tb2RpZmllZERhdGU7XG4gICAgfVxuICAgIC8vIGFkZCBvcHRpb25hbCBzdWJ0eXBlXG4gICAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgICAgcmVmQm9keS5TdWJ0eXBlID0gb3B0aW9ucy50eXBlLnJlcGxhY2UoJy8nLCAnIzJGJyk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNoZWNrc3VtIGFuZCBzaXplIGluZm9ybWF0aW9uXG4gICAgY29uc3QgY2hlY2tzdW0gPSBDcnlwdG9KUy5NRDUoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICByZWZCb2R5LlBhcmFtcy5DaGVja1N1bSA9IG5ldyBTdHJpbmcoY2hlY2tzdW0pO1xuICAgIHJlZkJvZHkuUGFyYW1zLlNpemUgPSBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICAvLyBzYXZlIHNvbWUgc3BhY2Ugd2hlbiBlbWJlZGRpbmcgdGhlIHNhbWUgZmlsZSBhZ2FpblxuICAgIC8vIGlmIGEgZmlsZSB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kIG1ldGFkYXRhIGV4aXN0cywgcmV1c2UgaXRzIHJlZmVyZW5jZVxuICAgIGxldCByZWY7XG4gICAgaWYgKCF0aGlzLl9maWxlUmVnaXN0cnkpIHRoaXMuX2ZpbGVSZWdpc3RyeSA9IHt9O1xuICAgIGxldCBmaWxlID0gdGhpcy5fZmlsZVJlZ2lzdHJ5W29wdGlvbnMubmFtZV07XG4gICAgaWYgKGZpbGUgJiYgaXNFcXVhbChyZWZCb2R5LCBmaWxlKSkge1xuICAgICAgcmVmID0gZmlsZS5yZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHRoaXMucmVmKHJlZkJvZHkpO1xuICAgICAgcmVmLmVuZChkYXRhKTtcbiAgICAgIHRoaXMuX2ZpbGVSZWdpc3RyeVtvcHRpb25zLm5hbWVdID0ge1xuICAgICAgICAuLi5yZWZCb2R5LFxuICAgICAgICByZWZcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIGFkZCBmaWxlc3BlYyBmb3IgZW1iZWRkZWQgZmlsZVxuICAgIGNvbnN0IGZpbGVTcGVjQm9keSA9IHtcbiAgICAgIFR5cGU6ICdGaWxlc3BlYycsXG4gICAgICBBRlJlbGF0aW9uc2hpcDogb3B0aW9ucy5yZWxhdGlvbnNoaXAsXG4gICAgICBGOiBuZXcgU3RyaW5nKG9wdGlvbnMubmFtZSksXG4gICAgICBFRjoge1xuICAgICAgICBGOiByZWZcbiAgICAgIH0sXG4gICAgICBVRjogbmV3IFN0cmluZyhvcHRpb25zLm5hbWUpXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5kZXNjcmlwdGlvbikge1xuICAgICAgZmlsZVNwZWNCb2R5LkRlc2MgPSBuZXcgU3RyaW5nKG9wdGlvbnMuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmaWxlc3BlYyA9IHRoaXMucmVmKGZpbGVTcGVjQm9keSk7XG4gICAgZmlsZXNwZWMuZW5kKCk7XG4gICAgaWYgKCFvcHRpb25zLmhpZGRlbikge1xuICAgICAgdGhpcy5hZGROYW1lZEVtYmVkZGVkRmlsZShvcHRpb25zLm5hbWUsIGZpbGVzcGVjKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZmlsZSB0byB0aGUgY2F0YWxvZ3VlIHRvIGJlIFBERi9BMyBjb21wbGlhbnRcbiAgICBpZiAodGhpcy5fcm9vdC5kYXRhLkFGKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQUYucHVzaChmaWxlc3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BRiA9IFtmaWxlc3BlY107XG4gICAgfVxuICAgIHJldHVybiBmaWxlc3BlYztcbiAgfVxufTtcblxuLyoqIGNoZWNrIHR3byBlbWJlZGRlZCBmaWxlIG1ldGFkYXRhIG9iamVjdHMgZm9yIGVxdWFsaXR5ICovXG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuU3VidHlwZSA9PT0gYi5TdWJ0eXBlICYmIGEuUGFyYW1zLkNoZWNrU3VtLnRvU3RyaW5nKCkgPT09IGIuUGFyYW1zLkNoZWNrU3VtLnRvU3RyaW5nKCkgJiYgYS5QYXJhbXMuU2l6ZSA9PT0gYi5QYXJhbXMuU2l6ZSAmJiBhLlBhcmFtcy5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpID09PSBiLlBhcmFtcy5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpICYmIChhLlBhcmFtcy5Nb2REYXRlID09PSB1bmRlZmluZWQgJiYgYi5QYXJhbXMuTW9kRGF0ZSA9PT0gdW5kZWZpbmVkIHx8IGEuUGFyYW1zLk1vZERhdGUuZ2V0VGltZSgpID09PSBiLlBhcmFtcy5Nb2REYXRlLmdldFRpbWUoKSk7XG59XG5cbnZhciBQREZBID0ge1xuICBpbml0UERGQShwU3Vic2V0KSB7XG4gICAgaWYgKHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMykgPT09ICctJykge1xuICAgICAgdGhpcy5zdWJzZXRfY29uZm9ybWFuY2UgPSBwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB0aGlzLnN1YnNldCA9IHBhcnNlSW50KHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIEJhc2ljIGNvbmZvcm1hbmNlIHdoZW4gdXNlciBkb2Vzbid0IHNwZWNpZnlcbiAgICAgIHRoaXMuc3Vic2V0X2NvbmZvcm1hbmNlID0gJ0InO1xuICAgICAgdGhpcy5zdWJzZXQgPSBwYXJzZUludChwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gIH0sXG4gIGVuZFN1YnNldCgpIHtcbiAgICB0aGlzLl9hZGRQZGZhTWV0YWRhdGEoKTtcbiAgICB0aGlzLl9hZGRDb2xvck91dHB1dEludGVudCgpO1xuICB9LFxuICBfYWRkQ29sb3JPdXRwdXRJbnRlbnQoKSB7XG4gICAgY29uc3QgaWNjUHJvZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhgJHtfX2Rpcm5hbWV9L2RhdGEvc1JHQl9JRUM2MTk2Nl8yXzEuaWNjYCk7XG4gICAgY29uc3QgY29sb3JQcm9maWxlUmVmID0gdGhpcy5yZWYoe1xuICAgICAgTGVuZ3RoOiBpY2NQcm9maWxlLmxlbmd0aCxcbiAgICAgIE46IDNcbiAgICB9KTtcbiAgICBjb2xvclByb2ZpbGVSZWYud3JpdGUoaWNjUHJvZmlsZSk7XG4gICAgY29sb3JQcm9maWxlUmVmLmVuZCgpO1xuICAgIGNvbnN0IGludGVudFJlZiA9IHRoaXMucmVmKHtcbiAgICAgIFR5cGU6ICdPdXRwdXRJbnRlbnQnLFxuICAgICAgUzogJ0dUU19QREZBMScsXG4gICAgICBJbmZvOiBuZXcgU3RyaW5nKCdzUkdCIElFQzYxOTY2LTIuMScpLFxuICAgICAgT3V0cHV0Q29uZGl0aW9uSWRlbnRpZmllcjogbmV3IFN0cmluZygnc1JHQiBJRUM2MTk2Ni0yLjEnKSxcbiAgICAgIERlc3RPdXRwdXRQcm9maWxlOiBjb2xvclByb2ZpbGVSZWZcbiAgICB9KTtcbiAgICBpbnRlbnRSZWYuZW5kKCk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLk91dHB1dEludGVudHMgPSBbaW50ZW50UmVmXTtcbiAgfSxcbiAgX2dldFBkZmFpZCgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHhtbG5zOnBkZmFpZD1cImh0dHA6Ly93d3cuYWlpbS5vcmcvcGRmYS9ucy9pZC9cIiByZGY6YWJvdXQ9XCJcIj5cbiAgICAgICAgICAgIDxwZGZhaWQ6cGFydD4ke3RoaXMuc3Vic2V0fTwvcGRmYWlkOnBhcnQ+XG4gICAgICAgICAgICA8cGRmYWlkOmNvbmZvcm1hbmNlPiR7dGhpcy5zdWJzZXRfY29uZm9ybWFuY2V9PC9wZGZhaWQ6Y29uZm9ybWFuY2U+XG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxuICAgICAgICBgO1xuICB9LFxuICBfYWRkUGRmYU1ldGFkYXRhKCkge1xuICAgIHRoaXMuYXBwZW5kWE1MKHRoaXMuX2dldFBkZmFpZCgpKTtcbiAgfVxufTtcblxudmFyIFBERlVBID0ge1xuICBpbml0UERGVUEoKSB7XG4gICAgdGhpcy5zdWJzZXQgPSAxO1xuICB9LFxuICBlbmRTdWJzZXQoKSB7XG4gICAgdGhpcy5fYWRkUGRmdWFNZXRhZGF0YSgpO1xuICB9LFxuICBfYWRkUGRmdWFNZXRhZGF0YSgpIHtcbiAgICB0aGlzLmFwcGVuZFhNTCh0aGlzLl9nZXRQZGZ1YWlkKCkpO1xuICB9LFxuICBfZ2V0UGRmdWFpZCgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHhtbG5zOnBkZnVhaWQ9XCJodHRwOi8vd3d3LmFpaW0ub3JnL3BkZnVhL25zL2lkL1wiIHJkZjphYm91dD1cIlwiPlxuICAgICAgICAgICAgPHBkZnVhaWQ6cGFydD4ke3RoaXMuc3Vic2V0fTwvcGRmdWFpZDpwYXJ0PlxuICAgICAgICA8L3JkZjpEZXNjcmlwdGlvbj5cbiAgICAgICAgYDtcbiAgfVxufTtcblxudmFyIFN1YnNldE1peGluID0ge1xuICBfaW1wb3J0U3Vic2V0KHN1YnNldCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3Vic2V0KTtcbiAgfSxcbiAgaW5pdFN1YnNldChvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLnN1YnNldCkge1xuICAgICAgY2FzZSAnUERGL0EtMSc6XG4gICAgICBjYXNlICdQREYvQS0xYSc6XG4gICAgICBjYXNlICdQREYvQS0xYic6XG4gICAgICBjYXNlICdQREYvQS0yJzpcbiAgICAgIGNhc2UgJ1BERi9BLTJhJzpcbiAgICAgIGNhc2UgJ1BERi9BLTJiJzpcbiAgICAgIGNhc2UgJ1BERi9BLTMnOlxuICAgICAgY2FzZSAnUERGL0EtM2EnOlxuICAgICAgY2FzZSAnUERGL0EtM2InOlxuICAgICAgICB0aGlzLl9pbXBvcnRTdWJzZXQoUERGQSk7XG4gICAgICAgIHRoaXMuaW5pdFBERkEob3B0aW9ucy5zdWJzZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BERi9VQSc6XG4gICAgICAgIHRoaXMuX2ltcG9ydFN1YnNldChQREZVQSk7XG4gICAgICAgIHRoaXMuaW5pdFBERlVBKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUERGTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IGBcbiAgICAgICAgPD94cGFja2V0IGJlZ2luPVwiXFx1ZmVmZlwiIGlkPVwiVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkXCI/PlxuICAgICAgICAgICAgPHg6eG1wbWV0YSB4bWxuczp4PVwiYWRvYmU6bnM6bWV0YS9cIj5cbiAgICAgICAgICAgICAgICA8cmRmOlJERiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCI+XG4gICAgICAgIGA7XG4gIH1cbiAgX2Nsb3NlVGFncygpIHtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX21ldGFkYXRhLmNvbmNhdChgXG4gICAgICAgICAgICAgICAgPC9yZGY6UkRGPlxuICAgICAgICAgICAgPC94OnhtcG1ldGE+XG4gICAgICAgIDw/eHBhY2tldCBlbmQ9XCJ3XCI/PlxuICAgICAgICBgKTtcbiAgfVxuICBhcHBlbmQoeG1sKSB7XG4gICAgbGV0IG5ld2xpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS5jb25jYXQoeG1sKTtcbiAgICBpZiAobmV3bGluZSkgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS5jb25jYXQoJ1xcbicpO1xuICB9XG4gIGdldFhNTCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gIH1cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YS5sZW5ndGg7XG4gIH1cbiAgZW5kKCkge1xuICAgIHRoaXMuX2Nsb3NlVGFncygpO1xuICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fbWV0YWRhdGEudHJpbSgpO1xuICB9XG59XG5cbnZhciBNZXRhZGF0YU1peGluID0ge1xuICBpbml0TWV0YWRhdGEoKSB7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBQREZNZXRhZGF0YSgpO1xuICB9LFxuICBhcHBlbmRYTUwoeG1sKSB7XG4gICAgbGV0IG5ld2xpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdGhpcy5tZXRhZGF0YS5hcHBlbmQoeG1sLCBuZXdsaW5lKTtcbiAgfSxcbiAgX2FkZEluZm8oKSB7XG4gICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cIlwiIHhtbG5zOnhtcD1cImh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9cIj5cbiAgICAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4ke3RoaXMuaW5mby5DcmVhdGlvbkRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnLicpWzBdICsgXCJaXCJ9PC94bXA6Q3JlYXRlRGF0ZT5cbiAgICAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+JHt0aGlzLmluZm8uQ3JlYXRvcn08L3htcDpDcmVhdG9yVG9vbD5cbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGApO1xuICAgIGlmICh0aGlzLmluZm8uVGl0bGUgfHwgdGhpcy5pbmZvLkF1dGhvciB8fCB0aGlzLmluZm8uU3ViamVjdCkge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9XCJcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCI+XG4gICAgICAgICAgICBgKTtcbiAgICAgIGlmICh0aGlzLmluZm8uVGl0bGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgICAgIDxkYzp0aXRsZT5cbiAgICAgICAgICAgICAgICAgICAgPHJkZjpBbHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPVwieC1kZWZhdWx0XCI+JHt0aGlzLmluZm8uVGl0bGV9PC9yZGY6bGk+XG4gICAgICAgICAgICAgICAgICAgIDwvcmRmOkFsdD5cbiAgICAgICAgICAgICAgICA8L2RjOnRpdGxlPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5BdXRob3IpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgICAgIDxkYzpjcmVhdG9yPlxuICAgICAgICAgICAgICAgICAgICA8cmRmOlNlcT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGk+JHt0aGlzLmluZm8uQXV0aG9yfTwvcmRmOmxpPlxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpTZXE+XG4gICAgICAgICAgICAgICAgPC9kYzpjcmVhdG9yPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5TdWJqZWN0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgICAgICA8ZGM6ZGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxyZGY6QWx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz1cIngtZGVmYXVsdFwiPiR7dGhpcy5pbmZvLlN1YmplY3R9PC9yZGY6bGk+XG4gICAgICAgICAgICAgICAgICAgIDwvcmRmOkFsdD5cbiAgICAgICAgICAgICAgICA8L2RjOmRlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgICAgICBgKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cIlwiIHhtbG5zOnBkZj1cImh0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy9cIj5cbiAgICAgICAgICAgIDxwZGY6UHJvZHVjZXI+JHt0aGlzLmluZm8uQ3JlYXRvcn08L3BkZjpQcm9kdWNlcj5gLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuaW5mby5LZXl3b3Jkcykge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPHBkZjpLZXl3b3Jkcz4ke3RoaXMuaW5mby5LZXl3b3Jkc308L3BkZjpLZXl3b3Jkcz5gLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGApO1xuICB9LFxuICBlbmRNZXRhZGF0YSgpIHtcbiAgICB0aGlzLl9hZGRJbmZvKCk7XG4gICAgdGhpcy5tZXRhZGF0YS5lbmQoKTtcblxuICAgIC8qXHJcbiAgICBNZXRhZGF0YSB3YXMgaW50cm9kdWNlZCBpbiBQREYgMS40LCBzbyBhZGRpbmcgaXQgdG8gMS4zIFxyXG4gICAgd2lsbCBsaWtlbHkgb25seSB0YWtlIHVwIG1vcmUgc3BhY2UuXHJcbiAgICAqL1xuICAgIGlmICh0aGlzLnZlcnNpb24gIT0gMS4zKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhUmVmID0gdGhpcy5yZWYoe1xuICAgICAgICBsZW5ndGg6IHRoaXMubWV0YWRhdGEuZ2V0TGVuZ3RoKCksXG4gICAgICAgIFR5cGU6ICdNZXRhZGF0YScsXG4gICAgICAgIFN1YnR5cGU6ICdYTUwnXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYud3JpdGUoQnVmZmVyLmZyb20odGhpcy5tZXRhZGF0YS5nZXRYTUwoKSwgJ3V0Zi04JykpO1xuICAgICAgdGhpcy5tZXRhZGF0YVJlZi5lbmQoKTtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5NZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFSZWY7XG4gICAgfVxuICB9XG59O1xuXG4vKlxyXG5QREZEb2N1bWVudCAtIHJlcHJlc2VudHMgYW4gZW50aXJlIFBERiBkb2N1bWVudFxyXG5CeSBEZXZvbiBHb3ZldHRcclxuKi9cbmNsYXNzIFBERkRvY3VtZW50IGV4dGVuZHMgc3RyZWFtLlJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvLyBQREYgdmVyc2lvblxuICAgIHN3aXRjaCAob3B0aW9ucy5wZGZWZXJzaW9uKSB7XG4gICAgICBjYXNlICcxLjQnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxLjQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMS41JzpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMS41O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuNic6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDEuNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcxLjcnOlxuICAgICAgY2FzZSAnMS43ZXh0Myc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDEuNztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxLjM7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdoZXRoZXIgc3RyZWFtcyBzaG91bGQgYmUgY29tcHJlc3NlZFxuICAgIHRoaXMuY29tcHJlc3MgPSB0aGlzLm9wdGlvbnMuY29tcHJlc3MgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5jb21wcmVzcyA6IHRydWU7XG4gICAgdGhpcy5fcGFnZUJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXJTdGFydCA9IDA7XG5cbiAgICAvLyBUaGUgUERGIG9iamVjdCBzdG9yZVxuICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICB0aGlzLl93YWl0aW5nID0gMDtcbiAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgY29uc3QgUGFnZXMgPSB0aGlzLnJlZih7XG4gICAgICBUeXBlOiAnUGFnZXMnLFxuICAgICAgQ291bnQ6IDAsXG4gICAgICBLaWRzOiBbXVxuICAgIH0pO1xuICAgIGNvbnN0IE5hbWVzID0gdGhpcy5yZWYoe1xuICAgICAgRGVzdHM6IG5ldyBQREZOYW1lVHJlZSgpXG4gICAgfSk7XG4gICAgdGhpcy5fcm9vdCA9IHRoaXMucmVmKHtcbiAgICAgIFR5cGU6ICdDYXRhbG9nJyxcbiAgICAgIFBhZ2VzLFxuICAgICAgTmFtZXNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxhbmcpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5MYW5nID0gbmV3IFN0cmluZyh0aGlzLm9wdGlvbnMubGFuZyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGN1cnJlbnQgcGFnZVxuICAgIHRoaXMucGFnZSA9IG51bGw7XG5cbiAgICAvLyBJbml0aWFsaXplIG1peGluc1xuICAgIHRoaXMuaW5pdE1ldGFkYXRhKCk7XG4gICAgdGhpcy5pbml0Q29sb3IoKTtcbiAgICB0aGlzLmluaXRWZWN0b3IoKTtcbiAgICB0aGlzLmluaXRGb250cyhvcHRpb25zLmZvbnQpO1xuICAgIHRoaXMuaW5pdFRleHQoKTtcbiAgICB0aGlzLmluaXRJbWFnZXMoKTtcbiAgICB0aGlzLmluaXRPdXRsaW5lKCk7XG4gICAgdGhpcy5pbml0TWFya2luZ3Mob3B0aW9ucyk7XG4gICAgdGhpcy5pbml0U3Vic2V0KG9wdGlvbnMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbWV0YWRhdGFcbiAgICB0aGlzLmluZm8gPSB7XG4gICAgICBQcm9kdWNlcjogJ1BERktpdCcsXG4gICAgICBDcmVhdG9yOiAnUERGS2l0JyxcbiAgICAgIENyZWF0aW9uRGF0ZTogbmV3IERhdGUoKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmZvKSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5vcHRpb25zLmluZm8pIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5vcHRpb25zLmluZm9ba2V5XTtcbiAgICAgICAgdGhpcy5pbmZvW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheVRpdGxlKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMgPSB0aGlzLnJlZih7XG4gICAgICAgIERpc3BsYXlEb2NUaXRsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgZmlsZSBJRFxuICAgIHRoaXMuX2lkID0gUERGU2VjdXJpdHkuZ2VuZXJhdGVGaWxlSUQodGhpcy5pbmZvKTtcblxuICAgIC8vIEluaXRpYWxpemUgc2VjdXJpdHkgc2V0dGluZ3NcbiAgICB0aGlzLl9zZWN1cml0eSA9IFBERlNlY3VyaXR5LmNyZWF0ZSh0aGlzLCBvcHRpb25zKTtcblxuICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAvLyBQREYgdmVyc2lvblxuICAgIHRoaXMuX3dyaXRlKGAlUERGLSR7dGhpcy52ZXJzaW9ufWApO1xuXG4gICAgLy8gNCBiaW5hcnkgY2hhcnMsIGFzIHJlY29tbWVuZGVkIGJ5IHRoZSBzcGVjXG4gICAgdGhpcy5fd3JpdGUoJyVcXHhGRlxceEZGXFx4RkZcXHhGRicpO1xuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBwYWdlXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRmlyc3RQYWdlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5hZGRQYWdlKCk7XG4gICAgfVxuICB9XG4gIGFkZFBhZ2Uob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICh7XG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgcGFnZSBpZiBuZWVkZWRcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5idWZmZXJQYWdlcykge1xuICAgICAgdGhpcy5mbHVzaFBhZ2VzKCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgcGFnZSBvYmplY3RcbiAgICB0aGlzLnBhZ2UgPSBuZXcgUERGUGFnZSh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9wYWdlQnVmZmVyLnB1c2godGhpcy5wYWdlKTtcblxuICAgIC8vIGFkZCB0aGUgcGFnZSB0byB0aGUgb2JqZWN0IHN0b3JlXG4gICAgY29uc3QgcGFnZXMgPSB0aGlzLl9yb290LmRhdGEuUGFnZXMuZGF0YTtcbiAgICBwYWdlcy5LaWRzLnB1c2godGhpcy5wYWdlLmRpY3Rpb25hcnkpO1xuICAgIHBhZ2VzLkNvdW50Kys7XG5cbiAgICAvLyByZXNldCB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gICAgdGhpcy54ID0gdGhpcy5wYWdlLm1hcmdpbnMubGVmdDtcbiAgICB0aGlzLnkgPSB0aGlzLnBhZ2UubWFyZ2lucy50b3A7XG5cbiAgICAvLyBmbGlwIFBERiBjb29yZGluYXRlIHN5c3RlbSBzbyB0aGF0IHRoZSBvcmlnaW4gaXMgaW5cbiAgICAvLyB0aGUgdG9wIGxlZnQgcmF0aGVyIHRoYW4gdGhlIGJvdHRvbSBsZWZ0XG4gICAgdGhpcy5fY3RtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCB0aGlzLnBhZ2UuaGVpZ2h0KTtcbiAgICB0aGlzLmVtaXQoJ3BhZ2VBZGRlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbnRpbnVlT25OZXdQYWdlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYWdlTWFya2luZ3MgPSB0aGlzLmVuZFBhZ2VNYXJraW5ncyh0aGlzLnBhZ2UpO1xuICAgIHRoaXMuYWRkUGFnZShvcHRpb25zKTtcbiAgICB0aGlzLmluaXRQYWdlTWFya2luZ3MocGFnZU1hcmtpbmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBidWZmZXJlZFBhZ2VSYW5nZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuX3BhZ2VCdWZmZXJTdGFydCxcbiAgICAgIGNvdW50OiB0aGlzLl9wYWdlQnVmZmVyLmxlbmd0aFxuICAgIH07XG4gIH1cbiAgc3dpdGNoVG9QYWdlKG4pIHtcbiAgICBsZXQgcGFnZTtcbiAgICBpZiAoIShwYWdlID0gdGhpcy5fcGFnZUJ1ZmZlcltuIC0gdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0XSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc3dpdGNoVG9QYWdlKCR7bn0pIG91dCBvZiBib3VuZHMsIGN1cnJlbnQgYnVmZmVyIGNvdmVycyBwYWdlcyAke3RoaXMuX3BhZ2VCdWZmZXJTdGFydH0gdG8gJHt0aGlzLl9wYWdlQnVmZmVyU3RhcnQgKyB0aGlzLl9wYWdlQnVmZmVyLmxlbmd0aCAtIDF9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2UgPSBwYWdlO1xuICB9XG4gIGZsdXNoUGFnZXMoKSB7XG4gICAgLy8gdGhpcyBsb2NhbCB2YXJpYWJsZSBleGlzdHMgc28gd2UncmUgZnV0dXJlLXByb29mIGFnYWluc3RcbiAgICAvLyByZWVudHJhbnQgY2FsbHMgdG8gZmx1c2hQYWdlcy5cbiAgICBjb25zdCBwYWdlcyA9IHRoaXMuX3BhZ2VCdWZmZXI7XG4gICAgdGhpcy5fcGFnZUJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXJTdGFydCArPSBwYWdlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgcGFnZSBvZiBwYWdlcykge1xuICAgICAgdGhpcy5lbmRQYWdlTWFya2luZ3MocGFnZSk7XG4gICAgICBwYWdlLmVuZCgpO1xuICAgIH1cbiAgfVxuICBhZGROYW1lZERlc3RpbmF0aW9uKG5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcmdzID0gWydYWVonLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICB9XG4gICAgaWYgKGFyZ3NbMF0gPT09ICdYWVonICYmIGFyZ3NbMl0gIT09IG51bGwpIHtcbiAgICAgIGFyZ3NbMl0gPSB0aGlzLnBhZ2UuaGVpZ2h0IC0gYXJnc1syXTtcbiAgICB9XG4gICAgYXJncy51bnNoaWZ0KHRoaXMucGFnZS5kaWN0aW9uYXJ5KTtcbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5EZXN0cy5hZGQobmFtZSwgYXJncyk7XG4gIH1cbiAgYWRkTmFtZWRFbWJlZGRlZEZpbGUobmFtZSwgcmVmKSB7XG4gICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5FbWJlZGRlZEZpbGVzKSB7XG4gICAgICAvLyBkaXNhYmxpbmcgL0xpbWl0cyBmb3IgdGhpcyB0cmVlIGZpeGVzIGF0dGFjaG1lbnRzIG5vdCBzaG93aW5nIGluIEFkb2JlIFJlYWRlclxuICAgICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRW1iZWRkZWRGaWxlcyA9IG5ldyBQREZOYW1lVHJlZSh7XG4gICAgICAgIGxpbWl0czogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBmaWxlc3BlYyB0byBFbWJlZGRlZEZpbGVzXG4gICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRW1iZWRkZWRGaWxlcy5hZGQobmFtZSwgcmVmKTtcbiAgfVxuICBhZGROYW1lZEphdmFTY3JpcHQobmFtZSwganMpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkphdmFTY3JpcHQpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkphdmFTY3JpcHQgPSBuZXcgUERGTmFtZVRyZWUoKTtcbiAgICB9XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICBKUzogbmV3IFN0cmluZyhqcyksXG4gICAgICBTOiAnSmF2YVNjcmlwdCdcbiAgICB9O1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkphdmFTY3JpcHQuYWRkKG5hbWUsIGRhdGEpO1xuICB9XG4gIHJlZihkYXRhKSB7XG4gICAgY29uc3QgcmVmID0gbmV3IFBERlJlZmVyZW5jZSh0aGlzLCB0aGlzLl9vZmZzZXRzLmxlbmd0aCArIDEsIGRhdGEpO1xuICAgIHRoaXMuX29mZnNldHMucHVzaChudWxsKTsgLy8gcGxhY2Vob2xkZXIgZm9yIHRoaXMgb2JqZWN0J3Mgb2Zmc2V0IG9uY2UgaXQgaXMgZmluYWxpemVkXG4gICAgdGhpcy5fd2FpdGluZysrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX3JlYWQoKSB7fVxuICAvLyBkbyBub3RoaW5nLCBidXQgdGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgYnkgbm9kZVxuXG4gIF93cml0ZShkYXRhKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhICsgJ1xcbicsICdiaW5hcnknKTtcbiAgICB9XG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQgKz0gZGF0YS5sZW5ndGg7XG4gIH1cbiAgYWRkQ29udGVudChkYXRhKSB7XG4gICAgdGhpcy5wYWdlLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9yZWZFbmQocmVmKSB7XG4gICAgdGhpcy5fb2Zmc2V0c1tyZWYuaWQgLSAxXSA9IHJlZi5vZmZzZXQ7XG4gICAgaWYgKC0tdGhpcy5fd2FpdGluZyA9PT0gMCAmJiB0aGlzLl9lbmRlZCkge1xuICAgICAgdGhpcy5fZmluYWxpemUoKTtcbiAgICAgIHJldHVybiB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5mbHVzaFBhZ2VzKCk7XG4gICAgdGhpcy5faW5mbyA9IHRoaXMucmVmKCk7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMuaW5mbykge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuaW5mb1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IG5ldyBTdHJpbmcodmFsKTtcbiAgICAgIH1cbiAgICAgIGxldCBlbnRyeSA9IHRoaXMucmVmKHZhbCk7XG4gICAgICBlbnRyeS5lbmQoKTtcbiAgICAgIHRoaXMuX2luZm8uZGF0YVtrZXldID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMuX2luZm8uZW5kKCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9mb250RmFtaWxpZXMpIHtcbiAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLl9mb250RmFtaWxpZXNbbmFtZV07XG4gICAgICBmb250LmZpbmFsaXplKCk7XG4gICAgfVxuICAgIHRoaXMuZW5kT3V0bGluZSgpO1xuICAgIHRoaXMuZW5kTWFya2luZ3MoKTtcbiAgICBpZiAodGhpcy5zdWJzZXQpIHtcbiAgICAgIHRoaXMuZW5kU3Vic2V0KCk7XG4gICAgfVxuICAgIHRoaXMuZW5kTWV0YWRhdGEoKTtcbiAgICB0aGlzLl9yb290LmVuZCgpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5QYWdlcy5lbmQoKTtcbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZW5kKCk7XG4gICAgdGhpcy5lbmRBY3JvRm9ybSgpO1xuICAgIGlmICh0aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5WaWV3ZXJQcmVmZXJlbmNlcy5lbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NlY3VyaXR5KSB7XG4gICAgICB0aGlzLl9zZWN1cml0eS5lbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBfZmluYWxpemUoKSB7XG4gICAgLy8gZ2VuZXJhdGUgeHJlZlxuICAgIGNvbnN0IHhSZWZPZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgdGhpcy5fd3JpdGUoJ3hyZWYnKTtcbiAgICB0aGlzLl93cml0ZShgMCAke3RoaXMuX29mZnNldHMubGVuZ3RoICsgMX1gKTtcbiAgICB0aGlzLl93cml0ZSgnMDAwMDAwMDAwMCA2NTUzNSBmICcpO1xuICAgIGZvciAobGV0IG9mZnNldCBvZiB0aGlzLl9vZmZzZXRzKSB7XG4gICAgICBvZmZzZXQgPSBgMDAwMDAwMDAwMCR7b2Zmc2V0fWAuc2xpY2UoLTEwKTtcbiAgICAgIHRoaXMuX3dyaXRlKG9mZnNldCArICcgMDAwMDAgbiAnKTtcbiAgICB9XG5cbiAgICAvLyB0cmFpbGVyXG4gICAgY29uc3QgdHJhaWxlciA9IHtcbiAgICAgIFNpemU6IHRoaXMuX29mZnNldHMubGVuZ3RoICsgMSxcbiAgICAgIFJvb3Q6IHRoaXMuX3Jvb3QsXG4gICAgICBJbmZvOiB0aGlzLl9pbmZvLFxuICAgICAgSUQ6IFt0aGlzLl9pZCwgdGhpcy5faWRdXG4gICAgfTtcbiAgICBpZiAodGhpcy5fc2VjdXJpdHkpIHtcbiAgICAgIHRyYWlsZXIuRW5jcnlwdCA9IHRoaXMuX3NlY3VyaXR5LmRpY3Rpb25hcnk7XG4gICAgfVxuICAgIHRoaXMuX3dyaXRlKCd0cmFpbGVyJyk7XG4gICAgdGhpcy5fd3JpdGUoUERGT2JqZWN0LmNvbnZlcnQodHJhaWxlcikpO1xuICAgIHRoaXMuX3dyaXRlKCdzdGFydHhyZWYnKTtcbiAgICB0aGlzLl93cml0ZShgJHt4UmVmT2Zmc2V0fWApO1xuICAgIHRoaXMuX3dyaXRlKCclJUVPRicpO1xuXG4gICAgLy8gZW5kIHRoZSBzdHJlYW1cbiAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCBQREZEb2N1bWVudF0nO1xuICB9XG59XG5jb25zdCBtaXhpbiA9IG1ldGhvZHMgPT4ge1xuICBPYmplY3QuYXNzaWduKFBERkRvY3VtZW50LnByb3RvdHlwZSwgbWV0aG9kcyk7XG59O1xubWl4aW4oTWV0YWRhdGFNaXhpbik7XG5taXhpbihDb2xvck1peGluKTtcbm1peGluKFZlY3Rvck1peGluKTtcbm1peGluKEZvbnRzTWl4aW4pO1xubWl4aW4oVGV4dE1peGluKTtcbm1peGluKEltYWdlc01peGluKTtcbm1peGluKEFubm90YXRpb25zTWl4aW4pO1xubWl4aW4oT3V0bGluZU1peGluKTtcbm1peGluKE1hcmtpbmdzTWl4aW4pO1xubWl4aW4oQWNyb0Zvcm1NaXhpbik7XG5taXhpbihBdHRhY2htZW50c01peGluKTtcbm1peGluKFN1YnNldE1peGluKTtcblBERkRvY3VtZW50LkxpbmVXcmFwcGVyID0gTGluZVdyYXBwZXI7XG5cbmV4cG9ydCBkZWZhdWx0IFBERkRvY3VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRma2l0LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfkit/js/pdfkit.es.js\n");

/***/ })

};
;